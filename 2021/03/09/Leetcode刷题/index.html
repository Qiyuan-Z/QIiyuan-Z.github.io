<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode刷题(Python3及Java实现) | Yuan</title><meta name="keywords" content="leetcode"><meta name="author" content="Qiyuan-Z"><meta name="copyright" content="Qiyuan-Z"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本系列是本人在刷题过程中，参考《小浩算法》的题型分类所做。由于小浩在大多数题目并未使用统一的语言实现，这里本人给出了Python和Java的实现。目前Python实现已完成，Java实现仍在更新中。若有错误或者更好的解决方法，欢迎提出。  数组系列1.交集 此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就"><meta property="og:type" content="article"><meta property="og:title" content="Leetcode刷题(Python3及Java实现)"><meta property="og:url" content="https://qiyuan-z.github.io/2021/03/09/Leetcode%E5%88%B7%E9%A2%98/index.html"><meta property="og:site_name" content="Yuan"><meta property="og:description" content="本系列是本人在刷题过程中，参考《小浩算法》的题型分类所做。由于小浩在大多数题目并未使用统一的语言实现，这里本人给出了Python和Java的实现。目前Python实现已完成，Java实现仍在更新中。若有错误或者更好的解决方法，欢迎提出。  数组系列1.交集 此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/src=http _pic4.zhimg.com_v2-c6e719d4cf7f2e31a6656295f3da40ba_1440w.jpg source=172ae18b&refer=http _pic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg.jpg"><meta property="article:published_time" content="2021-03-09T10:57:57.768Z"><meta property="article:modified_time" content="2022-01-03T05:29:27.899Z"><meta property="article:author" content="Qiyuan-Z"><meta property="article:tag" content="leetcode"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/src=http _pic4.zhimg.com_v2-c6e719d4cf7f2e31a6656295f3da40ba_1440w.jpg source=172ae18b&refer=http _pic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qiyuan-z.github.io/2021/03/09/Leetcode%E5%88%B7%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Qiyuan-Z","link":"链接: ","source":"来源: Yuan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-03 13:29:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Leetcode刷题(Python3及Java实现)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-09T10:57:57.768Z" title="发表于 2021-03-09 18:57:57">2021-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-03T05:29:27.899Z" title="更新于 2022-01-03 13:29:27">2022-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">81.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>321分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote><p>本系列是本人在刷题过程中，参考<a target="_blank" rel="noopener" href="https://www.geekxh.com/0.0.%E5%AD%A6%E4%B9%A0%E9%A1%BB%E7%9F%A5/01.html">《小浩算法》</a>的题型分类所做。由于小浩在大多数题目并未使用统一的语言实现，这里本人给出了Python和Java的实现。目前Python实现已完成，Java实现仍在更新中。若有错误或者更好的解决方法，欢迎提出。</p></blockquote><h2 id="数组系列"><a href="#数组系列" class="headerlink" title="数组系列"></a>数组系列</h2><h3 id="1-交集"><a href="#1-交集" class="headerlink" title="1.交集"></a>1.交集</h3><blockquote><p>此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了&lt;元素,出现次数&gt;</p></blockquote><p><strong>[第349题]</strong> 给定两个数组，编写一个函数来计算它们的交集。</p><ul><li><p>示例 1：<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></li><li><p>示例 2：<br>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[9,4]</p></li></ul><p>说明： <strong>输出结果中的每个元素一定是唯一的。</strong> 我们可以不考虑输出结果的顺序。</p><p><strong>方法一：映射字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        key = &#123;&#125;</span><br><span class="line">        result=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums1:</span><br><span class="line">        	<span class="comment">#遍历nums1，初始化字典key</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> key:</span><br><span class="line">                key[v] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> key:</span><br><span class="line">            	<span class="comment">#如果元素相同，将其存入result中，并将出现次数减1</span></span><br><span class="line">                <span class="keyword">if</span> key[v] &gt; <span class="number">0</span>:</span><br><span class="line">                    key[v] -= <span class="number">1</span></span><br><span class="line">                    result.append(v)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:60 ms,击败了74.80% 的Python3用户<br>内存消耗:13.4 MB,击败了70.92% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//getOrDefault()，当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1) map.put(num, map.getOrDefault(num, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(num, -<span class="number">1</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(num, map.get(num)-<span class="number">1</span>);</span><br><span class="line">                res[count++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回指定长度的新数组对象</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了84.57% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了7.70% 的用户</p><p><strong>方法二：set函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    	<span class="comment">#set转化成无重复元素的集合取交集</span></span><br><span class="line">        result = <span class="built_in">set</span>(nums1).intersection(<span class="built_in">set</span>(nums2))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br></pre></td></tr></table></figure><p>执行耗时:64 ms,击败了57.06% 的Python3用户<br>内存消耗:13.3 MB,击败了88.25% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums1) map.add(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.contains(num))&#123;</span><br><span class="line">                res[count++] = num;</span><br><span class="line">                map.remove(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回指定长度的新数组对象</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了94.86% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了58.09% 的用户</p><p><strong>[第350题]</strong> 给定两个数组，编写一个函数来计算它们的交集。</p><ul><li><p>示例 1：<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></li><li><p>示例 2：<br>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[9,4]</p></li></ul><p>说明：<strong>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</strong>我们可以不考虑输出结果的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        key = &#123;&#125;</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="comment">#遍历nums1，初始化字典key</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> key:</span><br><span class="line">                key[v] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                key[v] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> key:</span><br><span class="line">                <span class="comment">#如果元素相同，将其存入result中，并将出现次数减1</span></span><br><span class="line">                <span class="keyword">if</span> key[v] &gt; <span class="number">0</span>:</span><br><span class="line">                    key[v] -= <span class="number">1</span></span><br><span class="line">                    result.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了97.73% 的Python3用户<br>内存消耗:13.5 MB,击败了36.24% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(num, -<span class="number">1</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res[count++] = num ;</span><br><span class="line">                map.put(num,map.get(num) -<span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回指定长度的新数组对象</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了73.45% 的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了16.45% 的用户</p><p><strong>[题目进阶]</strong> 如果给定的数组已经排好序呢？你将如何优化你的算法？假如两个数组都是有序的，分别为：arr1 = [1,2,3,4,4,13]，arr2 = [1,2,3,9,10]</p><blockquote><p>对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法</p><p>设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起<br>向后移动，并且将相等的元素放入空白数组。</p><p>如果两个指针的元素不相等，我们将小的元素的指针后移。继续进行判断。</p><p>反复以上步骤，直到任意一个数组终止。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        result = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums1) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">                result.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:68 ms,击败了46.68% 的Python3用户<br>内存消耗:13.4 MB,击败了44.53% 的Python3用户</p><h3 id="2-最长公共前缀"><a href="#2-最长公共前缀" class="headerlink" title="2.最长公共前缀"></a>2.最长公共前缀</h3><blockquote><p>我们要想寻找最长公共前缀，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。<br>假定我们现在就从一个数组中寻找最长公共前缀，那么首先，我们可以将第一个元素设置为基准<br>元素x0。假如数组为[“flow”,”flower”,”flight”]，flow就是我们的基准元素x0。</p><p>然后我们只需要依次将基准元素和后面的元素进行比较（假定后面的元素依次为x1,x2,x3….），不断更<br>新基准元素，直到基准元素和所有元素都满足最长公共前缀的条件，就可以得到最长公共前缀。</p><p>具体比对过程如下：</p><p>如果strings.Index(x1,x) == 0，则直接跳过（因为此时x就是x1的最长公共前缀），对比下一个元<br>素。（如flower和flow进行比较）</p><p>如果strings.Index(x1,x) != 0, 则截取掉基准元素x的最后一个元素，再次和x1进行比较，直至满足<br>string.Index(x1,x) == 0，此时截取后的x为x和x1的最长公共前缀。（如flight和flow进行比较，依<br>次截取出flow-flo-fl，直到fl被截取出，此时fl为flight和flow的最长公共前缀）</p></blockquote><p><strong>[第14题]</strong> 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。</p><ul><li><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></li><li><p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></li></ul><p>说明: 所有输入只包含小写字母 a-z 。</p><p><strong>方法一：比对基准元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#基准元素</span></span><br><span class="line">            result = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#基准元素和后面的元素进行比较</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># find:在[beg, end]范围内查找substring，找到返回substr的起始下标，否则返回-1。</span></span><br><span class="line">            <span class="comment"># 前缀起始坐标必须为0开始，中间不算</span></span><br><span class="line">            <span class="keyword">while</span> k.find(result) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#调整基准元素</span></span><br><span class="line">                    result = result[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了98.27% 的Python3用户<br>内存消耗:13.4 MB,击败了56.76% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置基准元素</span></span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//与后续字符串比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.length; i++)&#123;</span><br><span class="line">            <span class="comment">//若不包含，则缩小范围</span></span><br><span class="line">             <span class="keyword">while</span>(!strs[i].startsWith(res))&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                res = res.substring(<span class="number">0</span>, res.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.7 MB, 在所有 Java 提交中击败了30.89% 的用户</p><p><strong>方法二：利用ASCII码</strong></p><blockquote><p>利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        s1 = <span class="built_in">min</span>(strs)</span><br><span class="line">        s2 = <span class="built_in">max</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s1):</span><br><span class="line">            <span class="keyword">if</span> x != s2[i]:</span><br><span class="line">                <span class="keyword">return</span> s2[:i]</span><br><span class="line">        <span class="keyword">return</span> s1</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了61.62% 的Python3用户<br>内存消耗:13.3 MB,击败了85.07% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String min = strs[<span class="number">0</span>];</span><br><span class="line">        String max = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(String s: strs)&#123;</span><br><span class="line">            <span class="comment">//若字符串等于参数字符串、则返回0，字符串小于参数字符串、则返回值小于0，字符串大于参数字符串、返回值大于0。</span></span><br><span class="line">            <span class="keyword">if</span>(s.compareTo(max) &gt; <span class="number">0</span>) max = s;</span><br><span class="line">            <span class="keyword">if</span>(s.compareTo(min) &lt; <span class="number">0</span>) min = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;min.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min.charAt(i) != max.charAt(i)) <span class="keyword">return</span> min.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了85.32% 的用户<br>内存消耗：36.8 MB, 在所有 Java 提交中击败了20.75% 的用户</p><p><strong>方法三：利用zip函数</strong></p><blockquote><p>利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀</p><p>比如strs=[“flow”,”flower”,”flight”]，则zip(*strs)将依次取出[‘f’,’f’,’f’]、[‘l’,’l’,’l’]、……、[‘’, ‘r’,’t’]，通过set去重，则[‘f’]、[‘l’]、……、[‘’, ‘r’,’t’]，长度大于1之前的就是公共前缀</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        ss = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">set</span>, <span class="built_in">zip</span>(*strs)))</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(ss):</span><br><span class="line">            x = <span class="built_in">list</span>(x)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = res + x[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了81.85% 的Python3用户<br>内存消耗:13.4 MB,击败了50.03% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        List&lt;Set&lt;Character&gt;&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() &gt; maxLength) maxLength = s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxLength; i++)&#123;</span><br><span class="line">            Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String s: strs)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; s.length()) set.add(s.charAt(i));</span><br><span class="line">                <span class="keyword">else</span> set.add(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ss.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Set&lt;Character&gt; set: ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.size() &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> s: set) res += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：16 ms, 在所有 Java 提交中击败了5.83% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了5.05% 的用户</p><h3 id="3-买卖股票的最佳时机"><a href="#3-买卖股票的最佳时机" class="headerlink" title="3.买卖股票的最佳时机"></a>3.买卖股票的最佳时机</h3><p><strong>[第122题]</strong> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</strong></p><ul><li><p>示例 1: 输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p></li><li><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p></li><li><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></li></ul><blockquote><p>1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出<br>售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。</p><p>2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机<br>会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到最大化。这个条件也是相当重要的，<br>如果我们把这里变成，最多完成两笔交易，就变成另一道题。</p><p>假设给定的数组为：[7, 1, 5, 3, 6, 4] 我们将其绘制成折线图，，我们要在满足1和2的条件下获取最大利益，其实就是尽可能多的低价买入高价卖出。而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出所有的上升波段的和。如图里就是A+B，也就是（5-1）+（6-3） = 7，就是我们能获取到的最大利益。</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/1.jpg" alt></p><p><strong>方法一：贪心算法</strong></p><blockquote><p>只要今天价格小于明天价格就在今天买入然后明天卖出</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; prices[i+<span class="number">1</span>]:</span><br><span class="line">                profit += (prices[i+<span class="number">1</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span>  profit</span><br></pre></td></tr></table></figure><p>执行耗时:84 ms,击败了53.70% 的Python3用户<br>内存消耗:14.7 MB,击败了38.34% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[i+<span class="number">1</span>]) profit+=(prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了99.57% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了79.49% 的用户</p><p><strong>方法二：DP动态规划</strong></p><blockquote><p>第i天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment">#不持有股票分为：1.1一直都不买入仍是昨天的未持有 2.今天卖出，即昨天加今天卖出的钱</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            <span class="comment">#持有股票分为：1.昨天没有持有，今天买入 2.昨天已买入一直持有着</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i], dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span>  dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:136 ms,击败了5.26% 的Python3用户<br>内存消耗:16.4 MB,击败了5.02% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]); </span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了19.71% 的用户<br>内存消耗：38 MB, 在所有 Java 提交中击败了91.41% 的用户</p><h3 id="4-旋转数组"><a href="#4-旋转数组" class="headerlink" title="4.旋转数组"></a>4.旋转数组</h3><p><strong>[第189题]</strong> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><ul><li>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:向右旋转 1 步: [7,1,2,3,4,5,6]，向右旋转 2 步: [6,7,1,2,3,4,5]，向右旋转 3 步: [5,6,7,1,2,3,4]</li><li>示例 2:<br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释: 向右旋转 1 步: [99,-1,-100,3]，向右旋转 2 步: [3,99,-1,-100]</li></ul><p>说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 <strong>要求使用空间复杂度为 O(1) 的原地算法。</strong></p><blockquote><p>这个方法基于这个事实：若我们需要将数组中的元素向右移动 k 个位置， 那么 k%l (l为数组长<br>度) 的尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>通过观察我们可以得到，我们只需要将所有元素反转，然后反转前 k 个元素，再反转后面l-k个元素，就能得到想要的结果。</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/2.jpg" alt></p><p><strong>方法一：翻转三次</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="comment"># 定义反转函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">switch</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">while</span> (a&lt;b):    <span class="comment"># 从两头往中间交换</span></span><br><span class="line">                nums[a], nums[b] = nums[b], nums[a]</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 三次反转</span></span><br><span class="line">        switch(<span class="number">0</span>, n-<span class="number">1</span>)  <span class="comment"># 反转整体</span></span><br><span class="line">        switch(<span class="number">0</span>, k-<span class="number">1</span>)    <span class="comment"># 反转前k个元素</span></span><br><span class="line">        switch(k, n-<span class="number">1</span>)    <span class="comment"># 反转后面元素</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了94.96% 的Python3用户<br>内存消耗:13.5 MB,击败了76.57% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">                nums[start] = nums[end];</span><br><span class="line">                nums[end] = tmp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：39 MB, 在所有 Java 提交中击败了45.62% 的用户</p><p><strong>方法二：利用切片翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.reverse()</span><br><span class="line">        nums[:k] = <span class="built_in">reversed</span>(nums[:k])</span><br><span class="line">        nums[k:] = <span class="built_in">reversed</span>(nums[k:])</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了85.56% 的Python3用户<br>内存消耗:13.6 MB,击败了27.15% 的Python3用户</p><p><strong>方法三：利用切片移位（不考虑原地算法）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        nums[:] = nums[-k:] + nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了85.56% 的Python3用户<br>内存消耗:13.6 MB,击败了44.31% 的Python3用户</p><h3 id="5-原地删除"><a href="#5-原地删除" class="headerlink" title="5.原地删除"></a>5.原地删除</h3><p><strong>[第27题]</strong> 给你一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，并返回移除后数组的新长度。 <strong>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</strong> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><ul><li>示例 1:<br>给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</li><li>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 应使用逆序</span></span><br><span class="line">        <span class="comment"># 如果是正序的话，删除一个索引所对应的值后</span></span><br><span class="line">        <span class="comment"># python会自动吧删除的位置补上来</span></span><br><span class="line">        <span class="comment"># 这样就会导致从删除位位置到最后一位的索引和原索引相差1个</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">del</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了72.46% 的Python3用户<br>内存消耗:13.4 MB,击败了33.88% 的Python3用户</p><blockquote><p>因为题目说了不需要考虑数组中超出新长度后面的元素，所以不需要真的移除，只要将其值覆盖即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[count]=nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.3 MB, 在所有 Java 提交中击败了8.49% 的用户</p><p><strong>[第26题]</strong> 给定一个<strong>排序数组</strong>，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</strong></p><ul><li>示例 1:<br>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</li><li>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组nums的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</li></ul><blockquote><p>这道题的重点是原地两个字，也就是要求必须在 O(1) 的空间下完成。并且题中已经告知了数组为有序数组，这样重复的元素一定是连在一起的，我们只需要一个一个移除重复的元素即可</p></blockquote><p><strong>方法一：循环移除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">del</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了88.67% 的Python3用户<br>内存消耗:14.2 MB,击败了96.20% 的Python3用户</p><blockquote><p>与27题同理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>]) nums[++count] = nums[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了80.44% 的用户<br>内存消耗：40.4 MB, 在所有 Java 提交中击败了19.16% 的用户</p><p><strong>方法二：set函数（不考虑原地算法）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums[:] = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(nums)))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了99.68% 的Python3用户<br>内存消耗:14.4 MB,击败了64.71% 的Python3用户</p><h3 id="6-加一"><a href="#6-加一" class="headerlink" title="6.加一"></a>6.加一</h3><p><strong>[第66题]</strong> 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位，数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。</p><ul><li><p>示例 1:<br>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p></li><li><p>示例 2:<br>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p></li></ul><blockquote><p>根据题目，我们需要加一！没错，加一很重要。因为它只是加一，所以我们会考虑到两种情况：</p><p>普通情况，除9之外的数字加1。<br>特殊情况，9加1。（因为9加1需要进位）</p><p>所以我们只需要模拟这两种运算，就可以顺利进行求解！</p></blockquote><p><strong>方法一：模拟运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        addon = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            digits[i] += addon</span><br><span class="line">            <span class="comment"># 将进位归0</span></span><br><span class="line">            addon = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 个位加1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(digits) - <span class="number">1</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 逢十进一</span></span><br><span class="line">            <span class="keyword">if</span> digits[i] == <span class="number">10</span>:</span><br><span class="line">                addon = <span class="number">1</span></span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">        <span class="comment">#类似99，或者999，我们需要进行扩充数组</span></span><br><span class="line">        <span class="keyword">if</span> addon == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了70.94% 的Python3用户<br>内存消耗:13.4 MB,击败了46.46% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> addon = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==digits.length-<span class="number">1</span>) digits[i]++;</span><br><span class="line">            res[i+<span class="number">1</span>] = digits[i] + addon;</span><br><span class="line">            addon = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(res[i+<span class="number">1</span>]==<span class="number">10</span>)&#123;</span><br><span class="line">                addon = <span class="number">1</span>;</span><br><span class="line">                res[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(addon==<span class="number">1</span>) res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> addon==<span class="number">1</span>?res: Arrays.copyOfRange(res, <span class="number">1</span>, res.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37 MB, 在所有 Java 提交中击败了29.28% 的用户</p><p><strong>方法二：利用Python特性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 整形转字符</span></span><br><span class="line">        digits = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> digits]</span><br><span class="line">        <span class="comment"># 拼接字符转数字</span></span><br><span class="line">        digits = <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(digits))</span><br><span class="line">        <span class="comment"># 加1</span></span><br><span class="line">        digits += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 数字转列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(digits)))</span><br></pre></td></tr></table></figure><p>执行耗时:48 ms,击败了18.72% 的Python3用户<br>内存消耗:13.4 MB,击败了33.38% 的Python3用户</p><h3 id="7-两数之和"><a href="#7-两数之和" class="headerlink" title="7.两数之和"></a>7.两数之和</h3><p><strong>[第1题]</strong> 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><ul><li>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</li></ul><p><strong>方法一：暴力解法</strong></p><blockquote><p>首先我们拿到题目一看，马上可以想到暴力题解。我们只需要 “遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">return</span> i, nums[i+<span class="number">1</span>:].index(target-nums[i])+i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>执行耗时:964 ms,击败了38.87% 的Python3用户<br>内存消耗:14.1 MB,击败了85.75% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==tmp) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了44.60% 的用户</p><blockquote><p>可以看到该种解题方式的时间复杂度过高，达到了O(n²)。为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。我们可以想到用哈希表的方式，通过以空间换取时间的方式来进行。</p></blockquote><p><strong>方法二：哈希表</strong></p><blockquote><p>首先先遍历数组nums，i 为当前下标。将每一个遍历的值放入字典中作为key。</p><p>同时，对每个值都判断字典中是否存在target-nums[i]的key值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            another_num = target - num</span><br><span class="line">            <span class="keyword">if</span> another_num <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> [hashmap[another_num], index]</span><br><span class="line">            hashmap[num] = index</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了91.51% 的Python3用户<br>内存消耗:14.6 MB,击败了37.49% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i])) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]), i&#125;;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了34.68% 的用户</p><h3 id="8-三数之和"><a href="#8-三数之和" class="headerlink" title="8.三数之和"></a>8.三数之和</h3><p><strong>[第15题]</strong> 给你一个包含n个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。</p><ul><li>示例：<br>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</li></ul><blockquote><p>本题的暴力题解可以仿照二数之和，直接三层遍历，取和为0的三元组，并记录下来，最后再去重。但是作为一个有智慧的人，我们不能这么去做。</p><p>假若我们的数组为：[-1, 0, 1, 2, -1, -4]<br>首先我们先把数组排个序，因为我们要同时找三个数，所以<strong>采取固定一个数，同时用双指针来查找另外两个数的方式。</strong>所以初始化时，我们选择固定第一个元素（当然，这一轮走完了，这个蓝框框我们就要也往前移动），同时将下一个元素和末尾元素分别设上 left 和 right 指针。画出图来就是下面这个样子：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/37.png" alt><br>因为我们已经排好了序，如果<strong>固定下来的数（上面蓝色框框）本身就大于 0，那三数之和必然无法等于 0。</strong><br>现在我们的排序就发挥出用处了，<strong>如果和大于0，那就说明 right 的值太大，需要左移。如果和小于0，那就说明 left 的值太小，需要右移。</strong><br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/38.png" alt><br>其中：在第6行时，因为三数之和大于0，所以right进行了左移。最后一行，跳过了重复的-1。<br><strong>除了固定下来的i值（蓝框框），left 和 right 当然也是需要处理重复的情况。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 进行排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 固定值大于0退出循环</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 过滤固定值重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 左指针</span></span><br><span class="line">            L = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右指针</span></span><br><span class="line">            R = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="comment"># 满足条件添加res</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                    <span class="comment">#满足条件后，移动双指针，跳过重复的</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] == nums[L + <span class="number">1</span>]:</span><br><span class="line">                        L = L + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] == nums[R - <span class="number">1</span>]:</span><br><span class="line">                        R = R - <span class="number">1</span></span><br><span class="line">                    L = L + <span class="number">1</span></span><br><span class="line">                    R = R - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 三数之和大于0,右指针左移</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    R = R - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 三数之和小于0,左指针右移</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = L + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:836 ms,击败了79.07% 的Python3用户<br>内存消耗:16 MB,击败了43.03% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[l] + nums[r] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[l], nums[r])));</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>]) r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>) r--;</span><br><span class="line">                <span class="keyword">else</span> l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：29 ms, 在所有 Java 提交中击败了31.84% 的用户<br>内存消耗：42.5 MB, 在所有 Java 提交中击败了48.86% 的用户</p><h3 id="9-Z字形变换"><a href="#9-Z字形变换" class="headerlink" title="9.Z字形变换"></a>9.Z字形变换</h3><p><strong>[第6题]</strong> 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L C I R<br>E T O E S I I G<br>E D H N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows);</p><ul><li>示例 1:<br>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”</li><li>示例 2:<br>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L D R<br>E O E I I<br>E C I H N<br>T S G</li></ul><blockquote><p><strong>根据 numRows 的大小来回进行放置即可</strong>（即从0到n-1，再从n-1到0）。具体的请看下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/39.png" alt><br>我们能看出来，<strong>每 2n-2 即为一个周期</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        temp = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numRows)]</span><br><span class="line">        period = numRows * <span class="number">2</span> - <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 每2n-2为周期</span></span><br><span class="line">            mod = index % period</span><br><span class="line">            <span class="comment"># 0到n-1</span></span><br><span class="line">            <span class="keyword">if</span> mod &lt; numRows:</span><br><span class="line">                temp[mod] += value</span><br><span class="line">            <span class="comment"># n-1到0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp[period - mod] += value</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(temp)</span><br></pre></td></tr></table></figure><p>执行耗时:56 ms,击败了95.52% 的Python3用户<br>内存消耗:13.6 MB,击败了16.18% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String[] tmp = <span class="keyword">new</span> String[numRows];</span><br><span class="line">        Arrays.fill(tmp, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> period = numRows * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mod = i % period;</span><br><span class="line">            <span class="keyword">if</span>(mod &lt; numRows) tmp[mod] += s.charAt(i);</span><br><span class="line">            <span class="keyword">else</span> tmp[period-mod] += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str: tmp)&#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：18 ms, 在所有 Java 提交中击败了20.92% 的用户<br>内存消耗：39.5 MB, 在所有 Java 提交中击败了13.73% 的用户</p><h2 id="链表系列"><a href="#链表系列" class="headerlink" title="链表系列"></a>链表系列</h2><h3 id="1-删除链表倒数第N个节点"><a href="#1-删除链表倒数第N个节点" class="headerlink" title="1.删除链表倒数第N个节点"></a>1.删除链表倒数第N个节点</h3><blockquote><p>在链表的题目中，十道有九道会用到哨兵节点，所以我们先讲一下什么是哨兵节点。<br>哨兵节点，其实就是一个附加在原链表最前面用来简化边界条件的附加节点，它的值域不存储任何东<br>西，只是为了操作方便而引入。比如原链表为 a -&gt; b -&gt; c，则加了哨兵节点的链表即为 x -&gt; a -&gt; b &gt; c。</p><p>那我们为什么需要引入哨兵节点呢?举个例子，比如我们要删除某链表的第一个元素，常见的删除链表<br>的操作是找到要删元素的前一个元素，假如我们记为pre。我们通过：</p><p>pre.Next = pre.Next.Next</p><p>来进行删除链表的操作。但是此时若是删除第一个元素的话，你就很难进行了，因为按道理来讲，此时<br>第一个元素的前一个元素就是nil（空的），如果使用pre就会报错。那如果此时你设置了哨兵节点的<br>话，此时的pre就是哨兵节点了。这样对于链表中的任何一个元素，你要删除都可以通过 pre.Next =<br>pre.Next.Next 的方式来进行，这就是哨兵节点的作用。</p></blockquote><p><strong>[第19题]</strong> 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><ul><li>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</li></ul><p>说明： 给定的 n 保证是有效的。<br>进阶： 你能尝试使用一趟扫描实现吗？</p><blockquote><p>首先我们思考，让我们删除倒数第N个元素，那我们只要找到倒数第N个元素就可以了，那怎么找<br>呢？我们只需要设置两个指针变量，中间间隔N-1元素。当后面的指针遍历完所有元素指向nil<br>时，前面的指针就指向了我们要删除的元素。</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/3.jpg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 思路：双指针法。</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 先让fast走n步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">None</span>:  <span class="comment"># 若走了n步后为None，则表明删除的为head节点</span></span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> != <span class="literal">None</span>:  <span class="comment"># slow和fast同时往前走</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span>  <span class="comment"># 当fast走到头时，second即是要删除节点的前一个节点位置</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 删除该节点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了82.68% 的Python3用户<br>内存消耗:13.4 MB,击败了31.27% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= n) slow = slow.next;   </span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.5 MB, 在所有 Java 提交中击败了33.64% 的用户</p><h3 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2.合并两个有序链表"></a>2.合并两个有序链表</h3><p><strong>[第21题]</strong> 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><ul><li>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</li></ul><blockquote><p>首先我们维护一个prehead的哨兵节点。我们其实只需要调整它的next指针。让它总是指向l1或者l2中较小的一个，直到l1或者l2任一指向null。这样到了最后，如果l1还是l2中任意一方还有余下元素没有用到，那余下的这些元素一定大于prehead已经合并完的链表（因为是有序链表）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 创建一个新链表</span></span><br><span class="line">        cur = ListNode()</span><br><span class="line">        <span class="comment"># 设置哨兵节点</span></span><br><span class="line">        result = cur</span><br><span class="line">        <span class="comment"># 指向两者中小的</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 将其中一方剩余的添加进来</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了48.83% 的Python3用户<br>内存消耗:13.3 MB,击败了79.52% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = res;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>) p.next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="keyword">null</span>) p.next = l2;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了10.58% 的用户</p><h3 id="3-环形链表"><a href="#3-环形链表" class="headerlink" title="3.环形链表"></a>3.环形链表</h3><p><strong>[第141题]</strong> 给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果pos是 -1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回true 。 否则，返回false 。</p><ul><li>示例 1：输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</li><li>示例 2：输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</li><li>示例 3：输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</li></ul><p>进阶：你能用O(1)（即，常量）内存解决此问题吗？</p><p><strong>方法一：哈希表判定</strong></p><blockquote><p>思路：通过hash表来检测节点之前是否被访问过，来判断链表是否成环。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="built_in">hash</span>[head] = <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>执行耗时:64 ms,击败了58.42% 的Python3用户<br>内存消耗:16.4 MB,击败了32.63% 的Python3用户</p><p><strong>方法二：双指针</strong></p><blockquote><p>本题标准解法！常识内容，必须掌握！</p><p>思路来源：先想象一下，两名运动员以不同速度在跑道上进行跑步会怎么样？相遇！好了，这道题你会<br>了。</p><p>解题方法：通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指<br>针每次移动一步，而快指针每次移动两步。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 慢指针，每次走一步; 快指针，每次走两步</span></span><br><span class="line">            slow, fast = slow.<span class="built_in">next</span>, fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 快慢指针相遇，表示有环</span></span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>执行耗时:48 ms,击败了99.09% 的Python3用户<br>内存消耗:16.3 MB,击败了77.10% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode fast = head;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：39.7 MB, 在所有 Java 提交中击败了13.26% 的用户</p><h3 id="4-两数相加"><a href="#4-两数相加" class="headerlink" title="4.两数相加"></a>4.两数相加</h3><p><strong>[第2题]</strong> 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><ul><li>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</li></ul><blockquote><p>加法肯定是从最低位到最高位进行相加，也就是这里的<strong>链表头到链表尾进行相加，所以需要遍历链表</strong>。</p><p>令 l1 和 l2 指向两个链表的头，用一个tmp值来存储同一位相加的结果，以及一个新的链表来存储tmp的值。</p><p><strong>所有模拟运算的题目，都需要考虑进位</strong>。<strong>我们使用tmp携带进位的值到下一位的运算</strong>。自然，这里的链表也不能直接存储tmp的值了，而是要存储tmp%10的值。重复这个步骤，<strong>直到两个链表都遍历完成，并且 tmp 没有进位值</strong>。</p><p><strong>因为我们没有构造哨兵节点，所以此时不太容易直接返回新链表</strong>。所以在整个流程的第一步，我们还需要用一个哨兵节点指向我们的新链表。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="built_in">list</span> = ListNode()</span><br><span class="line">        result = <span class="built_in">list</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> tmp != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                tmp += l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                tmp += l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">list</span>.<span class="built_in">next</span> = ListNode(tmp % <span class="number">10</span>)</span><br><span class="line">            tmp //= <span class="number">10</span></span><br><span class="line">            <span class="built_in">list</span> = <span class="built_in">list</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>执行耗时:72 ms,击败了84.37% 的Python3用户<br>内存消耗:13.6 MB,击败了6.12% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p = res;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span> || tmp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了49.86% 的用户</p><h2 id="动态规划系列"><a href="#动态规划系列" class="headerlink" title="动态规划系列"></a>动态规划系列</h2><blockquote><p>关于动态规划的资料很多，官方的定义是指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。概念中的各阶段之间的关系，其实指的就是状态转移方程。很多人觉得DP难（下文统称动态规划为DP），根本原因是因为DP跟一些固定形式的算法不同（比如DFS、二分法、KMP），它没有实际的步骤规定第一步、第二步来做什么，所以准确来说，DP其实是一种解决问题的思想。</p><p>这种思想的本质是：一个规模比较大的问题（可以用两三个参数表示的问题），可以通过若干规模较小的问题的结果来得到的（通常会寻求到一些特殊的计算逻辑，如求最值等）。</p><p>那么我们应该如何通过子问题去得到大规模问题呢？这就用到了状态转移方程，我们一般看到的状态转移方程，基本都是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;opt ：指代特殊的计算逻辑，通常为 max or min。</span><br><span class="line">&gt;i,j,k 都是在定义DP方程中用到的参数。</span><br><span class="line">&gt;dp[i] = opt(dp[i-1])+1</span><br><span class="line">&gt;dp[i][j] = w(i,j,k) + opt(dp[i-1][k])</span><br><span class="line">&gt;dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...)</span><br></pre></td></tr></table></figure><p>每一个状态转移方程，多少都有一些细微的差别。这个其实很容易理解，世间的关系多了去了，不可能抽象出完全可以套用的公式。所以我个人其实不建议去死记硬背各种类型的状态转移方程。</p></blockquote><h3 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1.爬楼梯"></a>1.爬楼梯</h3><p><strong>[第70题]</strong> 假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定n是一个正整数。</p><ul><li>示例 1：<br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</li></ul><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><ul><li>示例 2：<br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</li></ul><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><blockquote><p>通过分析我们可以明确，该题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建。满足“将大问题分解为若干个规模较小的问题”的条件。所我们令dp[n]表示能到达第n阶的方法总数，可以得到如下状态转移方程：</p><p>dp[n]=dp[n-1]+dp[n-2]</p><p>上 1 阶台阶：有1种方式。<br>上 2 阶台阶：有1+1和2两种方式。<br>上 3 阶台阶：到达第3阶的方法总数就是到第1阶和第2阶的方法数之和。<br>上 n 阶台阶，到达第n阶的方法总数就是到第 (n-1) 阶和第 (n-2) 阶的方法数之和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n &gt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">                dp.append(dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了87.16% 的Python3用户<br>内存消耗:13.4 MB,击败了50.33% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了38.13% 的用户</p><h3 id="2-最大子序和"><a href="#2-最大子序和" class="headerlink" title="2.最大子序和"></a>2.最大子序和</h3><p><strong>[第53题]</strong> 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><ul><li>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为6。</li></ul><blockquote><p>首先我们分析题目，一个连续子数组一定要以一个数作为结尾，那么我们可以将状态定义成如下：</p><p>dp[i]：表示以nums[i]结尾的连续子数组的最大和。</p><p>根据状态的定义，我们继续进行分析：如果要得到dp[i]，那么nums[i]一定会被选取。并且dp[i]所表示的连续子序列与dp[i-1]所表示的连续子序列很可能就差一个nums[i] 。即：</p><p>dp[i] = dp[i-1]+nums[i] , if (dp[i-1] &gt;= 0)</p><p>但是这里我们遇到一个问题，很有可能dp[i-1]本身是一个负数。那这种情况的话，如果dp[i]通过dp[i-1]+nums[i] 来推导，那么结果其实反而变小了，因为我们dp[i]要求的是最大和。所以在这种情况下，如果dp[i-1] &lt; 0，那么dp[i]其实就是nums[i]的值。即</p><p>dp[i] = nums[i] , if (dp[i-1] &lt; 0)</p><p>综上分析，我们可以得到：</p><p>dp[i]=max(nums[i], dp[i−1]+nums[i])</p><p>得到了状态转移方程，但是我们还需要通过一个已有的状态的进行推导，我们可以想到dp[0]一定是以nums[0]进行结尾，所以</p><p>dp[i] = dp[i-1]+nums[i] , if (dp[i-1] &gt;= 0)<br>dp[0] = nums[0]</p><p>在很多题目中，因为dp[i]本身就定义成了题目中的问题，所以dp[i]最终就是要的答案。但是这里状态中的定义，并不是题目中要的问题，不能直接返回最后的一个状态 (这一步经常有初学者会摔跟头)。所以最终的答案，其实我们是寻找：</p><p>max(dp[0], dp[1], …, d[i-1], dp[i])</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp.append(<span class="built_in">max</span>(nums[i], dp[i-<span class="number">1</span>]+nums[i]))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了90.97% 的Python3用户<br>内存消耗:14.2 MB,击败了24.24% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了94.84% 的用户<br>内存消耗：38.3 MB, 在所有 Java 提交中击败了76.68% 的用户</p><h3 id="3-最长上升子序列"><a href="#3-最长上升子序列" class="headerlink" title="3.最长上升子序列"></a>3.最长上升子序列</h3><p><strong>[第300题]</strong> 给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><ul><li>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</li></ul><p>说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</p><blockquote><p>首先我们分析题目，要找的是最长上升子序列（Longest Increasing Subsequence，LIS）。因为题目中没有要求连续，所以LIS可能是连续的，也可能是非连续的。同时，LIS符合可以从其子问题的最优解来进行构建的条件。所以我们可以尝试用动态规划来进行求解。首先我们定义状态：</p><p>dp[i] ：表示以nums[i]结尾的最长上升子序列的长度</p><p>我们分两种情况进行讨论：</p><p>如果nums[i]比前面的所有元素都小，那么dp[i]等于1（即它本身）（该结论正确）</p><p>如果nums[i]前面存在比他小的元素，那么dp[i]就等于dp[i] = max(dp[j]+1，dp[k]+1，dp[p]+1，…..)<br>只要满足：<br>nums[i] &gt; nums[j]<br>nums[i] &gt; nums[k]<br>nums[i] &gt; nums[p]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>]</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[j]+<span class="number">1</span>, dp[i])</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:1344 ms,击败了26.36% 的Python3用户<br>内存消耗:13.6 MB,击败了5.92% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) maxLen = Math.max(maxLen, dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxLen;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：67 ms, 在所有 Java 提交中击败了75.12% 的用户<br>内存消耗：38.3 MB, 在所有 Java 提交中击败了15.62% 的用户</p><h3 id="4-三角形最小路径和"><a href="#4-三角形最小路径和" class="headerlink" title="4.三角形最小路径和"></a>4.三角形最小路径和</h3><p><strong>[第120题]</strong> 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点在这里指的是下标与上一层结点下标相同或者等上一层结点下标 + 1的两个点。</p><ul><li>例如，给定三角形：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[	[2],     </span><br><span class="line">   [3,4],    </span><br><span class="line">  [6,5,7],   </span><br><span class="line"> [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure> 自顶向下的最小路径和为11（即，2 + 3 + 5 + 1 = 11）。</li></ul><blockquote><p>我们根据题目中给出的条件：每一步只能移动到下一行中相邻的结点上。其实也就等同于，每一步我们只能往下移动一格或者右下移动一格。将其转化成代码，假如2所在的元素位置为[0,0]，那我们往下移动就只能移动到[1,0]或者[1,1]的位置上。假如5所在的位置为[2,1]，同样也只能移动到[3,1]和[3,2]的位置上。</p><p>所以我们通过动态规划进行求解。首先，我们定义状态：<br><code>dp[i][j] : 表示包含第i行j列元素的最小路径和</code><br>我们很容易想到可以自顶向下进行分析。并且，无论最后的路径是哪一条，它一定要经过最顶上的元<br>素，即<code>[0,0]</code>。所以我们需要对<code>dp[0][0]</code>进行初始化。<br><code>dp[0][0] = [0][0]位置所在的元素值</code><br>继续分析，如果我们要求<code>dp[i][j]</code>，那么其一定会从自己头顶上的两个元素移动而来。<br>得到状态转移方程：<br><code>dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j]</code><br>但是，我们这里会遇到一个问题！除了最顶上的元素之外，<br><strong>最左边的元素只能从自己头顶而来</strong><br><strong>最右边的元素只能从自己左上角而来</strong><br>然后，我们观察发现，位于第2行的元素，都是特殊元素（因为都只能从[0,0]的元素走过来）<br>我们可以直接将其特殊处理，得到：<br><code>dp[1][0] = triangle[1][0] + triangle[0][0]</code><br><code>dp[1][1] = triangle[1][1] + triangle[0][0]</code><br>最后，我们只要找到最后一行元素中，路径和最小的一个，就是我们的答案。即：<br><code>l：dp数组长度</code><br><code>result = min(dp[l-1,0]，dp[l-1,1]，dp[l-1,2]....)</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(triangle) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(triangle)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i])):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    triangle[i][j] = triangle[i - <span class="number">1</span>][j] + triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="built_in">len</span>(triangle[i]) - <span class="number">1</span>:</span><br><span class="line">                    triangle[i][j] = triangle[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    triangle[i][j] = <span class="built_in">min</span>(triangle[i - <span class="number">1</span>][j], triangle[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(triangle[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了96.02% 的Python3用户<br>内存消耗:14 MB,击败了39.84% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle.get(i).size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = triangle.get(i).get(j) + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == triangle.get(i).size()-<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i - <span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == n-<span class="number">1</span>) res = Math.min(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了21.88% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了5.22% 的用户</p><p><strong>优化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="comment">//因为当前状态只与上一行的列有关，因此可以压缩空间</span></span><br><span class="line">        <span class="comment">//dp[j]代表第j列的最小路径和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//更新最后一列</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="comment">//更新中间列</span></span><br><span class="line">            <span class="comment">//需要逆序，否则上一列的值会被覆盖</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新第0列</span></span><br><span class="line">            dp[<span class="number">0</span>] += triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minTotal = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了94.30% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了5.22% 的用户</p><h3 id="5-最小路径和"><a href="#5-最小路径和" class="headerlink" title="5.最小路径和"></a>5.最小路径和</h3><p><strong>[第64题]</strong> 给定一个包含非负整数的m x n网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。</p><ul><li>示例:<br>输入:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[1,3,1],</span><br><span class="line">[1,5,1],</span><br><span class="line">[4,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure> 输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</li></ul><blockquote><p>该题与上一道求三角形最小路径和一样，题目明显符合可以从子问题的最优解进行构建，所以我们考虑使用动态规划进行求解。首先，我们定义状态：<br><code>dp[i][j] : 表示包含第i行j列元素的最小路径和</code><br>同样，因为任何一条到达右下角的路径，都会经过<code>[0,0]</code>这个元素。所以我们需要对<code>dp[0][0]</code>进行初始化。<br><code>dp[0][0] = [0][0]位置所在的元素值</code><br>如果我们要求<code>dp[i][j]</code> ，那么它一定是从自己的上方或者左边移动而来<br>进而我们得到状态转移方程：<br><code>dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]</code><br>同样我们需要考虑两种特殊情况：<br><strong>最上面一行，只能由左边移动而来</strong><br><strong>最左边一列，只能由上面移动而来</strong><br>最后，因为我们的目标是从左上角走到右下角，整个网格的最小路径和其实就是包含右下角元素的最小路径和。即：<br><code>最终结果就是：dp[l-1][len(dp[l-1])-1]</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">and</span> (j == <span class="number">0</span>):</span><br><span class="line">                    grid[i][j] = grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> (i == <span class="number">0</span>) <span class="keyword">and</span> (j != <span class="number">0</span>):</span><br><span class="line">                    grid[i][j] = grid[i][j-<span class="number">1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> (i != <span class="number">0</span>) <span class="keyword">and</span> (j == <span class="number">0</span>):</span><br><span class="line">                    grid[i][j] = grid[i-<span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid[i][j] = <span class="built_in">min</span>(grid[i][j-<span class="number">1</span>], grid[i-<span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:72 ms,击败了19.09% 的Python3用户<br>内存消耗:14.8 MB,击败了23.49% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) grid[i][j] = grid[i][j-<span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) grid[i][j] = grid[i-<span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = Math.min(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了15.82% 的用户<br>内存消耗：41 MB, 在所有 Java 提交中击败了86.60% 的用户</p><h3 id="6-打家劫舍"><a href="#6-打家劫舍" class="headerlink" title="6.打家劫舍"></a>6.打家劫舍</h3><p><strong>[第198题]</strong> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li>示例 1：<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃1号房屋 (金额 = 1) ，然后偷窃3号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</li><li>示例 2：<br>输入：[2,7,9,3,1]#<br>输出：12<br>解释：偷窃1号房屋 (金额 = 2), 偷窃3号房屋 (金额 = 9)，接着偷窃5号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</li></ul><blockquote><p>定义出状态:<br><code>dp[i] : 偷盗至第i个房子时，所获取的最大利益</code><br>因为小偷一定会从前偷到最后（强调：偷盗至第i个房间，不代表小偷要从第i个房间中获取财物）。所以我们的最终答案很容易确定。即：<code>dp[i]</code><br>由于不可以在相邻的房屋闯入，所以至i房屋可盗窃的最大值，要么就是至i-1房屋可盗窃的最大值，要么就是至i-2房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值，即：<br><code>dp[i] = max(dp[i-2]+nums[i], dp[i-1])</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">                nums[i] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i] = <span class="built_in">max</span>(nums[i-<span class="number">2</span>]+nums[i], nums[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> nums[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了96.55% 的Python3用户<br>内存消耗:13.5 MB,击败了5.36% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.8 MB, 在所有 Java 提交中击败了61.62% 的用户</p><h2 id="字符串系列"><a href="#字符串系列" class="headerlink" title="字符串系列"></a>字符串系列</h2><h3 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1.反转字符串"></a>1.反转字符串</h3><p><strong>[第344题]</strong> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。</p><ul><li>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</li><li>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</li></ul><blockquote><p>这是一道相当简单的经典题目，直接上题解：使用双指针进行反转字符串。<br>假设输入字符串为[“h”,”e”,”l”,”l”,”0”]<br>定义left和right分别指向首元素和尾元素<br>当left &lt; right ，进行交换。<br>交换完毕，left++，right—<br>直至left == right</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:48 ms,击败了77.38% 的Python3用户<br>内存消耗:14.6 MB,击败了7.10% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            swap(s, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] ch,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = ch[i];</span><br><span class="line">        ch[i] = ch[j];</span><br><span class="line">        ch[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：45.2 MB, 在所有 Java 提交中击败了33.90% 的用户</p><h3 id="2-字符串中的第一个唯一字符"><a href="#2-字符串中的第一个唯一字符" class="headerlink" title="2.字符串中的第一个唯一字符"></a>2.字符串中的第一个唯一字符</h3><p><strong>[第387题]</strong> 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><ul><li>示例：<br>s = “leetcode” 返回 0<br>s = “loveleetcode” 返回 2</li></ul><p>提示：你可以假定该字符串只包含小写字母。</p><p><strong>方法一：用字典</strong></p><blockquote><p>在数组中记录每个字母的最后一次出现的所在索引。然后再通过一次循环，比较各个字母第一次出现的索引是否为最后一次的索引。如果是，我们就找到了我们的目标，如果不是我们将其设为 -1（标示该元素非目标元素）如果第二次遍历最终没有找到目标，直接返回 -1即可。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="built_in">dict</span>[s[i]] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">dict</span>[s[i]]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">dict</span>[s[i]] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:128 ms,击败了61.83% 的Python3用户<br>内存消耗:13.7 MB,击败了5.07% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) map.put(s.charAt(i), i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == map.get(s.charAt(i))) <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">else</span> map.put(s.charAt(i), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：35 ms, 在所有 Java 提交中击败了27.69% 的用户<br>内存消耗：39.1 MB, 在所有 Java 提交中击败了27.58% 的用户</p><p><strong>方法二：用集合</strong></p><blockquote><p>集合的特性为集合中每个元素都是独一无二的，我们可以利用这特性，将列表转换为集合。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 转为集合, 将去重后的集合再转化为列表</span></span><br><span class="line">        unique = <span class="built_in">list</span>(<span class="built_in">set</span>(s))</span><br><span class="line">        <span class="comment"># 按原列表索引排序，不改变顺序</span></span><br><span class="line">        unique.sort(key=s.index)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> unique:</span><br><span class="line">            <span class="keyword">if</span> s.count(i) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> s.index(i)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:76 ms,击败了94.58% 的Python3用户<br>内存消耗:13.7 MB,击败了5.07% 的Python3用户</p><h3 id="3-实现Sunday匹配"><a href="#3-实现Sunday匹配" class="headerlink" title="3.实现Sunday匹配"></a>3.实现Sunday匹配</h3><p><strong>[第28题]</strong> 实现strStr()函数。给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置 (从0开始)。如果不存在，则返回-1。</p><ul><li>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</li><li>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</li></ul><p>说明:<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当needle是空字符串时我们应当返回0 。这与C语言的strstr()以及Java的indexOf()定义相符。</p><blockquote><p>先普及几个概念：</p><ul><li>串：串是字符串的简称</li><li>空串：长度为零的串称为空串</li><li>主串：包含子串的串相应地称为主串</li><li>子串：串中任意个连续字符组成的子序列称为该串的子串</li><li>模式串：子串的定位运算又称为串的模式匹配，是一种求子串第一个字符在主串中序号的运算。被匹配的主串称为目标串，子串称为模式串。</li></ul><p>对于SUNDAY算法，我们<strong>从头部开始比较，一旦发现不匹配，直接找到主串中位于模式串后面的第一个字符</strong>，即下面绿色的 “s”。（因为，无论模式串移动多少步，模式串后的第一个字符都要参与下一次比较，也就是这里的 “s”）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/53.png" alt></p><p>找到了模式串后的第一个字符 “s”，接下来该怎么做？我们需要<strong>查看模式串中是否包含这个元素，如果不包含那就可以跳过一大片，从该字符的下一个字符开始比较。</strong></p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/54.png" alt></p><p>因为仍然不匹配（空格和l），我们继续重复上面的过程。找到模式串的下一个元素：t</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/55.png" alt></p><p>现在有意思了，我们发现t被包含于模式串中，并且t出现在模式串倒数第3个。所以我们把模式串向前移动3个单位：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/56.png" alt></p><p>捞干货，这个过程里我们做了一些什么：</p><ul><li>对齐目标串和模式串，从前向后匹配</li><li><strong>关注主串中位于模式串后面的第一个元素（核心）</strong></li><li>如果关注的字符没有在子串中出现则直接跳过</li><li>否则开始移动模式串，移动位数 = 子串长度 - 该字符最右出现的位置(以0开始)</li></ul></blockquote><p>然而这种方法，我这里用Python写会超时，估计原因在于查找索引太耗时，还是用子串逐一比较来的实在<img src="file:///C:\Users\Qiyuan-Z\AppData\LocalLow\Baidu\BAIDUP~1\dict\Default\0F25D2~1.PNG" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        L, n = <span class="built_in">len</span>(needle), <span class="built_in">len</span>(haystack)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n - L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[start: start + L] == needle:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了97.51% 的Python3用户<br>内存消耗:13.7 MB,击败了17.10% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="keyword">null</span> || needle == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目标串匹配索</span></span><br><span class="line">        <span class="keyword">int</span> originIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//模式串匹配索引</span></span><br><span class="line">        <span class="keyword">int</span> aimIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 成功匹配完终止条件：所有needle均成功匹配</span></span><br><span class="line">        <span class="keyword">while</span> (aimIndex &lt; needle.length()) &#123;</span><br><span class="line">            <span class="comment">// 针对origin匹配完，但needle未匹配完情况处理</span></span><br><span class="line">            <span class="keyword">if</span> (originIndex &gt; haystack.length() - <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(originIndex) == needle.charAt(aimIndex)) &#123;</span><br><span class="line">                <span class="comment">// 匹配则index均加1</span></span><br><span class="line">                originIndex++;</span><br><span class="line">                aimIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//下一个目标字符索引</span></span><br><span class="line">                <span class="keyword">int</span> nextCharIndex = originIndex - aimIndex + needle.length();</span><br><span class="line">                <span class="comment">//判断下一个目标字符（图里的那个绿框框）是否存在。</span></span><br><span class="line">                <span class="keyword">if</span> (nextCharIndex &lt; haystack.length()) &#123;</span><br><span class="line">                    <span class="comment">// 判断目标字符在模式串中匹配到，返回最后一个匹配的index</span></span><br><span class="line">                    <span class="keyword">int</span> step = needle.lastIndexOf(haystack.charAt(nextCharIndex));</span><br><span class="line">                    <span class="keyword">if</span> (step == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 不存在的话，设置到目标字符的下一个元素</span></span><br><span class="line">                        originIndex = nextCharIndex + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 存在的话，移动对应的数字（参考上文中的存在公式）</span></span><br><span class="line">                        originIndex = nextCharIndex - step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//模式串总是从第一个开始匹配</span></span><br><span class="line">                    aimIndex = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originIndex - aimIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了28.87% 的用户<br>内存消耗：37 MB, 在所有 Java 提交中击败了68.02% 的用户</p><h3 id="4-大数打印"><a href="#4-大数打印" class="headerlink" title="4.大数打印"></a>4.大数打印</h3><div class="table-container"><table><thead><tr><th>剑指offer 17：大数打印</th></tr></thead><tbody><tr><td>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出 1、2、3 一直到最大的3位数 999。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1 </span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><p><strong>题目升级</strong>： <strong>这道题目的名字叫做大数打印，如果阈值超出long类型，该怎么办呢？请手动实现一下！</strong></p><blockquote><p><strong>采用数组进行存储</strong>。</p><ul><li>对最低位nSum的值递增（也就是字符串加1运算），当大于等于10时，我们把进位标识改为1，同时恢复对nSum减10（29-31）</li><li>通过判断首位是否进位来判断到达最大的n位数情况。比如n=4，只有对9999加1，才会对第一个字符进位。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        num = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        isBegin = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> isBegin:</span><br><span class="line">            <span class="comment"># tmp用于存储进位，初始值为1代表加1</span></span><br><span class="line">            tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</span></span><br><span class="line">                tmp, num[i] = <span class="built_in">divmod</span>(num[i] + tmp, <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">if</span> tmp &gt; <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> tmp == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 直到最后一位仍进位就结束</span></span><br><span class="line">                    isBegin = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> isBegin:</span><br><span class="line">                result.append(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, num))))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行用时：200 ms, 在所有 Python3 提交中击败了5.22% 的用户<br>内存消耗：20.3 MB, 在所有 Python3 提交中击败了18.63% 的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">char</span>[] num  = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        Arrays.fill(num, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isBegin = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(isBegin)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = num[i] - <span class="string">&#x27;0&#x27;</span> + tmp;</span><br><span class="line">                num[i] = (<span class="keyword">char</span>) (sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                tmp = sum / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> isBegin = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isBegin) res[index++] = saveNumber(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveNumber</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isBegin = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : number) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isBegin &amp;&amp; c != <span class="string">&#x27;0&#x27;</span>) isBegin = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBegin) res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：60 ms, 在所有 Java 提交中击败了5.31% 的用户<br>内存消耗：46.3 MB, 在所有 Java 提交中击败了91.10% 的用户</p><h3 id="5-验证回文串"><a href="#5-验证回文串" class="headerlink" title="5.验证回文串"></a>5.验证回文串</h3><div class="table-container"><table><thead><tr><th>第125题：验证回文串</th></tr></thead><tbody><tr><td>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</td></tr></tbody></table></div><p><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><blockquote><p>“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</p><p>当然，对于本题而言，因为原字符串还包括了除字母，数字之外的一些幺蛾子，所以我们可以考虑将其替换或跳过。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 转换成小写</span></span><br><span class="line">        s = s.lower()</span><br><span class="line">        <span class="comment"># 两头遍历比对</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        	<span class="comment"># 跳过特殊符号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ((s[i] &gt;= <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">or</span> (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ((s[j] &gt;= <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s[j] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">or</span> (s[j] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s[j] &lt;= <span class="string">&#x27;z&#x27;</span>)):</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>执行耗时:60 ms,击败了61.53% 的Python3用户<br>内存消耗:13.8 MB,击败了53.68% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!((str.charAt(l) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(l) &lt;= <span class="string">&#x27;9&#x27;</span>) || (str.charAt(l) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str.charAt(l) &lt;= <span class="string">&#x27;z&#x27;</span>)))&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!((str.charAt(r) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(r) &lt;= <span class="string">&#x27;9&#x27;</span>) || (str.charAt(r) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str.charAt(r) &lt;= <span class="string">&#x27;z&#x27;</span>)))&#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(l) != str.charAt(r)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了64.94% 的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了73.12% 的用户</p><h3 id="6-KMP"><a href="#6-KMP" class="headerlink" title="6.KMP"></a>6.KMP</h3><blockquote><p>KMP 算法常被称为“看毛片算法”，由一个姓K的，一个姓M的，一个姓P 一起提出。<strong>是一种由暴力匹配改进的字符串匹配算法</strong>。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/57.png" alt></p><p>暴力匹配，就是目标串和模式串一个一个的对比。假若我们目标串长度为m，模式串长度为n。模式串与目标串至少比较m次，又因其自身长度为n，所以理论的时间复杂度为<strong>O(m*n)。</strong> 但因为途中遇到不能匹配的字符时，就可以停止，并不需要完全对比（比如上图第2行）<strong>。所以虽然理论时间复杂度为</strong> O(m*n) ，但其实大部分情况效率高很多。</p><p>下面直接给出 <strong>KMP算法</strong> 的操作流程：</p><ul><li>假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置</li><li>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j] ），都令 i++，j++，继续匹配下一个字符； 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j] ），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P相对于文本串 S 向右移动了 j - next [j] 位</li><li>换言之，将模式串 P 失配位置的 next 数组的值对应的模式串 P 的索引位置移动到失配处</li></ul><p>以下图文本串 S 与模式串 P 为例：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/58.jpg" alt><br>求得每一个子串的所有前缀与后缀。<br><strong>前缀</strong>指除了最后一个字符以外，一个字符串的全部头部组合；<strong>后缀</strong>指除了第一个字符以外，一个字符串的全部尾部组合。</p><p>求得原模式串 P 的子串对应的各个前缀后缀的公共元素的<strong>最大长度表</strong>下图。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/59.jpg" alt></p><p>根据<strong>最大长度表</strong>去求<strong>next数组</strong>：<strong>next数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</strong>。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/60.jpg" alt></p><p>好了，获取了<strong>next 数组</strong>后，<strong>KMP 算法</strong>的操作就很清晰了。</p><p>将模式串 P 与文本串 S 的字母一个个进行匹配，当失配的时候，模式串向右移动。比如模式串的 <strong>b</strong> 与文本串的 <strong>c</strong> 失配了，找出失配处模式串的<strong>next数组</strong>里面对应的值，这里为 <strong>0</strong>，然后将索引为 <strong>0</strong> 的位置移动到失配处。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/61.jpg" alt></p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/62.jpg" alt></p></blockquote><p>例子：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/156.png" alt><br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/154.png" alt><br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/155.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="comment">//得到目标子串的部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;next=&quot;</span>+ Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">&quot;index= &quot;</span> +index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表，是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//若匹配不成功，目标子串偏移, 移动位数为（已匹配字符数-部分匹配值）相当于next右移</span></span><br><span class="line">            <span class="comment">//因此j = j - next[j-1]或j = next[j-1]都可</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) j= next[j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//记录已匹配的字符数</span></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) j++;</span><br><span class="line">            <span class="comment">//匹配成功, 返回索引</span></span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配不成功，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到一个字符串（子串）的部分匹配值表</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line">        <span class="comment">//创建一个next数组保存部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果字符串是长度为1部分匹配值就是0</span></span><br><span class="line">        <span class="comment">// i相当于后缀，一步步遍历目标串的子串, j代表公共前缀长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt; dest.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//若后缀不等于前缀，则公共前缀长归0</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//随着后缀长度增加 若后缀一直等于前缀，公共前缀长+1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) j++;</span><br><span class="line">            <span class="comment">//部分匹配值为公共前缀长</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-旋转字符串"><a href="#7-旋转字符串" class="headerlink" title="7.旋转字符串"></a>7.旋转字符串</h3><div class="table-container"><table><thead><tr><th>第796题：旋转字符串</th></tr></thead><tbody><tr><td>给定两个字符串, A 和 B。A 的旋转操作就是将 A 最左边的字符移动到最右边。例如, 若 A = ‘abcde’，在移动一次之后结果就是’bcdea’ 。如果在若干次旋转操作之后，A 能变成B，那么返回True。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: A = &#x27;abcde&#x27;, B = &#x27;cdeab&#x27;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: A = &#x27;abcde&#x27;, B = &#x27;abced&#x27;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> A 和 B 长度不超过 100。</p><blockquote><p>无论它怎样旋转，最终的 A + A包含了所有可以通过旋转操作从 A 得到的字符串：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/63.png" alt><br>那我们只需要判断 B 是否为 A + A 的子串就可以了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span>(<span class="params">self, A: <span class="built_in">str</span>, B: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(A) == <span class="built_in">len</span>(B) <span class="keyword">and</span> (B <span class="keyword">in</span> (A + A))</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了35.30% 的Python3用户<br>内存消耗:13.4 MB,击败了48.35% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        String s = A + A;</span><br><span class="line">        <span class="keyword">return</span> A.length()==B.length() &amp;&amp; s.contains(B)?<span class="keyword">true</span>: <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.5 MB, 在所有 Java 提交中击败了37.20% 的用户</p><h3 id="8-最后一个单词的长度"><a href="#8-最后一个单词的长度" class="headerlink" title="8.最后一个单词的长度"></a>8.最后一个单词的长度</h3><div class="table-container"><table><thead><tr><th>第58题：最后一个单词的长度</th></tr></thead><tbody><tr><td>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</td></tr></tbody></table></div><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot; </span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p><blockquote><p>题中的陷阱在于，<strong>结尾处仍然可能有空格</strong>。</p><p>所以一般的解题思路为，先去掉末尾的空格，然后从尾向前开始遍历，直到遇到第一个空格处结束。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 去除字符串开头或者结尾的空格,再按空格划分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.strip().split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了94.69% 的Python3用户<br>内存消耗:13.6 MB,击败了12.63% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] str = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str[str.length-<span class="number">1</span>].length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了38.46% 的用户<br>内存消耗：37.2 MB, 在所有 Java 提交中击败了8.91% 的用户</p><h2 id="二叉树系列"><a href="#二叉树系列" class="headerlink" title="二叉树系列"></a>二叉树系列</h2><h3 id="1-最大深度与DFS"><a href="#1-最大深度与DFS" class="headerlink" title="1.最大深度与DFS"></a>1.最大深度与DFS</h3><blockquote><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。树比链表稍微复杂，因为链表是线性数据结构，而树不是。树的问题很多都可以由广度优先搜索或深度优先搜索解决。</p></blockquote><p><strong>[第104题]</strong> 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。</p><ul><li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">     / \</span><br><span class="line">    15  7</span><br></pre></td></tr></table></figure> 返回它的最大深度 3 。</li></ul><p><strong>方法一：递归求解</strong></p><blockquote><p>每个节点的深度与它左右子树的深度有关，且等于其左右子树最大深度值加上1，即<br><code>maxDepth(root) = max(maxDepth(root.left), maxDepth(root.right)) + 1</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:56 ms,击败了54.54% 的Python3用户<br>内存消耗:15.4 MB,击败了12.04% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了12.93% 的用户</p><p><strong>方法二：非递归DFS</strong></p><blockquote><p>DFS：深度优先搜索算法（Depth First Search），对于二叉树而言，它沿着<strong>树的深度遍历树的节点，尽可能深的搜索树的分支，这一过程一直进行到已发现从源节点可达的所有节点为止。</strong><br>如下图二叉树，它的访问顺序为：A-B-D-E-C-F-G<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    a</span><br><span class="line">   / \</span><br><span class="line">  b    c</span><br><span class="line"> / \  / \</span><br><span class="line">d   e f  g</span><br></pre></td></tr></table></figure><br>虽然我们用递归的方式根据DFS的思想顺利完成了题目。但是这种方式的缺点却显而易见。因为在递归中，如果层级过深，我们很可能保存过多的临时变量，导致栈溢出。这也是为什么我们一般不在后台代码中使用递归的原因。<br>事实上，函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。而递归调用，只有走到最后的结束点后函数才能依次退出，而未到达最后的结束点之前，占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值，从而导致栈溢出，导致程序的异常退出。<br>如何将递归的代码转化成非递归的形式。这里请记住，<strong>99%的递归转非递归，都可以通过栈来进行实现。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#stack记录的是节点</span></span><br><span class="line">        <span class="comment">#是同时入栈同时出栈，level记录的是节点在第几层</span></span><br><span class="line">        stack = []</span><br><span class="line">        level = [<span class="number">1</span>]</span><br><span class="line">        maxdepth = <span class="number">0</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment">#stack中的元素和level中的元素同时出栈</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            temp = level.pop()</span><br><span class="line">            maxdepth = <span class="built_in">max</span>(temp, maxdepth)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 同时入栈</span></span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                level.append(temp + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="comment"># 同时入栈</span></span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                level.append(temp + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxdepth</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了97.17% 的Python3用户<br>内存消耗:14.6 MB,击败了81.81% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; level = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxdepth = <span class="number">0</span>;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        level.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> tmp = level.pop();</span><br><span class="line">            maxdepth = Math.max(maxdepth, tmp);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                level.push(tmp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">                level.push(tmp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxdepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了16.83% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了94.17% 的用户</p><p>如果不理解代码，请看下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/4.jpg" alt></p><p>1：首先将a压入栈<br>2：a弹栈，将c、b压入栈（注意顺序）<br>3：b弹栈，将e、d压入栈<br>4：d、e、c弹栈，将g、f压入栈<br>5：f、g弹栈</p><p><strong>唯一需要强调的是，为什么需要先右后左压入数据？是因为我们需要将先访问的数据，后压入栈（请思考栈的特点）。</strong></p><h3 id="2-层次遍历与BFS"><a href="#2-层次遍历与BFS" class="headerlink" title="2.层次遍历与BFS"></a>2.层次遍历与BFS</h3><blockquote><p>在上一节中，我们通过例题学习了二叉树的DFS（深度优先搜索），其实就是沿着一个方向一直<br>向下遍历。那我们可不可以按照高度一层一层的访问树中的数据呢？当然可以，就是本节中我们<br>要讲的BFS（宽度优先搜索），同时也被称为广度优先搜索。</p><p>其实就是从上到下，先把每一层遍历完之后再遍历一下一层。假如我们的树如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    a</span><br><span class="line">   / \</span><br><span class="line">  b    c</span><br><span class="line"> / \  / \</span><br><span class="line">d   e f  g</span><br></pre></td></tr></table></figure><br>按照BFS，访问顺序如下：<br><code>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g</code></p></blockquote><p><strong>[第102题]</strong> 给你一个二叉树，请你返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</p><ul><li>示例：<br>二叉树：[3,9,20,null,null,15,7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure> 返回其层次遍历结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p><strong>方法一：DFS递归求解</strong></p><blockquote><p>想到递归，我们一般先想到DFS。我们可以对该二叉树进行先序遍历（根左右的顺序），同时，记录节点所在的层次level，并且对每一层都定义一个数组，然后将访问到的节点值放入对应层的数组中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.result = []</span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span>(<span class="params">self, node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.result) &lt; level + <span class="number">1</span>:</span><br><span class="line">            self.result.append([])</span><br><span class="line">        self.result[level].append(node.val)</span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了94.65% 的Python3用户<br>内存消耗:14 MB,击败了11.12% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        levelOrder(root, result, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; result, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (result.size() &lt; level + <span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(level).add(root.val);</span><br><span class="line">        levelOrder(root.left, result, level + <span class="number">1</span>);</span><br><span class="line">        levelOrder(root.right, result, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了14.02% 的用户</p><p><strong>方法二：BFS求解</strong></p><blockquote><p>上面的解法，其实相当于是用DFS的方法实现了二叉树的BFS。那我们能不能直接使用BFS的方式进行解题呢？当然，我们可以使用Queue的数据结构。我们将root节点初始化进队列，通过消耗尾部，插入头部的方式来完成BFS。</p></blockquote><p>具体步骤如下图：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/5.jpg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 初始化队列</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_level = []</span><br><span class="line">            <span class="comment"># 同一层从右进，从左出</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                current_level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="comment"># 添加每层的节点</span></span><br><span class="line">            result.append(current_level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了84.08% 的Python3用户<br>内存消耗:13.7 MB,击败了32.49% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了94.76% 的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了68.05% 的用户</p><h3 id="3-BST与其验证"><a href="#3-BST与其验证" class="headerlink" title="3.BST与其验证"></a>3.BST与其验证</h3><blockquote><p>先看定义：二叉搜索树（Binary Search Tree），（又：二叉查找树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：若<strong>它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</strong>；它的左、右子树也分别为二叉搜索树。</p><p>这里强调一下子树的概念：设T是有根树，a是T中的一个顶点，由<strong>a以及a的所有后裔（后代）</strong>导出的子图称为有向树T的子树。具体来说，<strong>子树就是树的其中一个节点以及其下面的所有的节点</strong>所构成的树。</p><p>比如下面这就是一颗二叉搜索树：</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/6.jpg" alt></p><blockquote><p>下面这两个都不是：</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/7.jpg" alt></p><blockquote><p><1>图中4节点位置的数值应该大于根节点</1></p><p><2>图中3节点位置的数值应该大于根节点</2></p></blockquote><p><strong>[第98题]</strong> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</p><ul><li>示例 1:<br>输入:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure> 输出: true</li><li>示例 2:<br>输入:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   / \</span><br><span class="line">     3   6</span><br></pre></td></tr></table></figure> 输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。</li></ul><blockquote><p>首先看完题目，我们很容易想到遍历整棵树，比较所有节点，通过左节点值&lt;节点值，右节点值&gt;节点值的方式来进行求解。但是这种解法是错误的，因为对于任意一个节点，我们不光需要左节点值小于该节点，并且左子树上的所有节点值都需要小于该节点。（右节点一致）所以我们在此引入上界与下界，用以保存之前的节点中出现的最大值与最小值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isBST(root, -inf, inf)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBST</span>(<span class="params">self, root, <span class="built_in">min</span>, <span class="built_in">max</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> &gt;= root.val) <span class="keyword">or</span> (<span class="built_in">max</span> &lt;= root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBST(root.left, <span class="built_in">min</span>, root.val) <span class="keyword">and</span> self.isBST(root.right, root.val, <span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了88.67% 的Python3用户<br>内存消耗:15.8 MB,击败了38.48% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(root.left, min, root.val) &amp;&amp; isBST(root.right, root.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了7.36% 的用户</p><h3 id="4-BST的查找"><a href="#4-BST的查找" class="headerlink" title="4.BST的查找"></a>4.BST的查找</h3><p><strong>[第700题]</strong> 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><ul><li>例如，<br>给定二叉搜索树:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure> 和值: 2<br>你应该返回如下子树:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure> 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</li></ul><blockquote><p>假设目标值为 val，根据BST的特性，我们可以很容易想到查找过程<br>如果val小于当前结点的值，转向其左子树继续搜索；<br>如果val大于当前结点的值，转向其右子树继续搜索；<br>如果已找到，则返回当前结点。</p></blockquote><p><strong>方法一：递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>执行耗时:116 ms,击败了10.76% 的Python3用户<br>内存消耗:15.5 MB,击败了33.59% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：39.2 MB, 在所有 Java 提交中击败了83.28% 的用户</p><p><strong>方法二：迭代</strong></p><blockquote><p>递归与迭代的区别<br>递归：重复调用函数自身实现循环称为递归；<br>迭代：利用变量的原值推出新值称为迭代，或者说迭代是函数内某段代码实现循环；</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>执行耗时:76 ms,击败了99.39% 的Python3用户<br>内存消耗:15.6 MB,击败了6.14% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; val) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：39.6 MB, 在所有 Java 提交中击败了8.04% 的用户</p><h3 id="5-BST的删除"><a href="#5-BST的删除" class="headerlink" title="5.BST的删除"></a>5.BST的删除</h3><p><strong>[第450题]</strong> 给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。<br>说明： 要求算法时间复杂度为O(h)，h为树的高度。</p><ul><li>示例:<br>root = [5,3,6,2,4,null,7]<br>key = 3<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br></pre></td></tr></table></figure> 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   6</span><br><span class="line"> /     \</span><br><span class="line">2       7</span><br></pre></td></tr></table></figure> 另一个正确答案是 [5,2,6,null,4,null,7]。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">2   6</span><br><span class="line"> \   \</span><br><span class="line">  4   7</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们要删除BST的一个节点，首先需要找到该节点。而找到之后，会出现三种情况。</p><p>1、待删除的节点左子树为空，让待删除节点的右子树替代自己。<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/8.jpg" alt><br>2、待删除的节点右子树为空，让待删除节点的左子树替代自己。<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/9.jpg" alt><br>3、如果待删除的节点的左右子树都不为空。我们需要找到<strong>比当前节点小的最大节点（前驱）</strong>，来替换自己</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/10.jpg" alt></p><p>或者<strong>比当前节点大的最小节点（后继）</strong>，来替换自己。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/11.jpg" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#第一种和第二种情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                root = root.left <span class="keyword">if</span> root.left <span class="keyword">else</span> root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 第三种情况，查找后继</span></span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                root.val = cur.val</span><br><span class="line">                <span class="comment"># 找到右子树最小值，再通过主递归函数删除最小值</span></span><br><span class="line">                <span class="comment"># 出口就是 if not root.left or not root.right: root = root.left if root.left else root.right</span></span><br><span class="line">                root.right = self.deleteNode(root.right, cur.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>执行耗时:72 ms,击败了99.85% 的Python3用户<br>内存消耗:17.6 MB,击败了24.40% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span> )&#123;</span><br><span class="line">                root = root.left!=<span class="keyword">null</span>?root.left: root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode cur = root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left!=<span class="keyword">null</span>) cur = cur.left;</span><br><span class="line">                root.val = cur.val;</span><br><span class="line">                root.right = deleteNode(root.right, cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了62.43% 的用户</p><h3 id="6-平衡二叉树"><a href="#6-平衡二叉树" class="headerlink" title="6.平衡二叉树"></a>6.平衡二叉树</h3><p><strong>[第110题]</strong> 给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p><ul><li>示例 1:<br>给定二叉树 [3,9,20,null,null,15,7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7 </span><br></pre></td></tr></table></figure> 返回 true 。</li><li>示例 2:<br>给定二叉树 [1,2,2,3,3,null,null,4,4]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure> 返回 false 。</li></ul><blockquote><p>我们想判断一棵树是否满足平衡二叉树，无非就是判断当前结点的两个孩子是否满足平衡，同时两个孩子的高度差是否超过1。那只要我们可以得到高度，再基于高度进行判断即可。</p><p>这里唯一要注意的是，当我们判定其中任意一个节点如果不满足平衡二叉树时，那说明整棵树已经不是一颗平衡二叉树，我们可以对其进行阻断，不需要继续递归下去。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不平衡的情况有3种：左树不平衡、右树不平衡、左树和右树差的绝对值大于1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isBalanced(root.left) <span class="keyword">or</span> <span class="keyword">not</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        leftH = self.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">        rightH = self.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftH - rightH) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 树的深度为左右俩子树最大深度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:64 ms,击败了73.12% 的Python3用户<br>内存消耗:17.3 MB,击败了66.69% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!isBalanced(root.left) || !isBalanced(root.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> leftH = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightH = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(leftH - rightH) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了99.97% 的用户<br>内存消耗：39.2 MB, 在所有 Java 提交中击败了5.03% 的用户</p><h3 id="7-完全二叉树"><a href="#7-完全二叉树" class="headerlink" title="7.完全二叉树"></a>7.完全二叉树</h3><blockquote><p>如果<strong>二叉树中除了叶子结点，每个结点的度都为 2</strong>，则此二叉树称为<strong>满二叉树</strong>。（<strong>二叉树的度代表某个结点的孩子或者说直接后继的个数</strong>。对于二叉树而言，1度是只有一个孩子或者说单子树,2度是有两个孩子或者说左右子树都有。）</p><p>满二叉树如下：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/12.jpg" alt><br>如果<strong>二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为<br>完全二叉树</strong>。</p><p>比如下面这颗：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/13.jpg" alt><br>而这颗就不是：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/14.jpg" alt></p></blockquote><p><strong>[第222题]</strong> 给出一个完全二叉树，求出该树的节点个数。<br>说明：<br>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h层，则该层包含1~ 2h个节点。</p><ul><li>示例:<br>输入:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br></pre></td></tr></table></figure> 输出: 6</li></ul><p><strong>方法一：递归求解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure><p>执行耗时:88 ms,击败了91.26% 的Python3用户<br>内存消耗:20.5 MB,击败了6.22% 的Python3用户</p><p>但是很明显，出题者肯定不是要这种答案。因为这种答案和完全二叉树一毛钱关系都没有。所以我们继<br>续思考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：41.1 MB, 在所有 Java 提交中击败了23.37% 的用户</p><p><strong>方法二：经典解法</strong></p><blockquote><p>由于题中已经告诉我们这是一颗完全二叉树，我们又已知了完全二叉树除了最后一层，其他层都是满的，并且最后一层的节点全部靠向了左边。那我们可以想到，可以将该完全二叉树可以分割成<strong>若干满二叉树和完全二叉树，满二叉树直接根据层高h计算出节点为2^h-1，然后继续计算子树中完全二叉树节点</strong>。那如何分割成若干满二叉树和完全二叉树呢？<strong>对任意一个子树，遍历其左子树层高left，右子树层高right，相等左子树则是满二叉树，否则右子树是满二叉树</strong>。</p><p>如下：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/15.jpg" alt><br>左子树为满二叉树<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/16.jpg" alt><br>右子树为满二叉树</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算左右子树高度</span></span><br><span class="line">        lh, rh = self.__getHeight(root.left), self.__getHeight(root.right)</span><br><span class="line">        <span class="keyword">if</span> lh == rh:  <span class="comment"># 左右子树高度相同，说明左子树必满 则节点数=左子树节点 + root节点(=1) + 递归找右子树</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">pow</span>(<span class="number">2</span>, lh) - <span class="number">1</span>) + <span class="number">1</span> + self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 左子树比右子树高，说明右子树必满 同理</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">pow</span>(<span class="number">2</span>, rh) - <span class="number">1</span>) + <span class="number">1</span> + self.countNodes(root.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getHeight</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><p>执行耗时:88 ms,击败了91.26% 的Python3用户<br>内存消耗:20.4 MB,击败了47.22% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lh = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rh = getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(lh == rh) <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">2</span>, lh) - <span class="number">1</span>) + <span class="number">1</span> + countNodes(root.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">2</span>, rh) - <span class="number">1</span>) + <span class="number">1</span> + countNodes(root.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：41 MB, 在所有 Java 提交中击败了50.61% 的用户</p><h3 id="8-二叉树的剪枝"><a href="#8-二叉树的剪枝" class="headerlink" title="8.二叉树的剪枝"></a>8.二叉树的剪枝</h3><blockquote><p>假设有一棵树，最上层的是root节点，而<strong>父节点会依赖子节点</strong>。如果现在有一些节点已经标记为无效，我们要删除这些无效节点。<strong>如果无效节点的依赖的节点还有效，那么不应该删除</strong>，如果无效节点和它的子节点都无效，则可以删除。剪掉这些节点的过程，称为剪枝，目的是<strong>用来处理二叉树模型中的依赖问题</strong>。</p></blockquote><p><strong>[第814题]</strong> 给定二叉树根结点root，此外树的每个结点的值要么是0，要么是1。返回移除了所有不包含 1 的子树的原二叉树。( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p><ul><li><p>示例1:<br>输入: [1,null,0,0,1]<br>输出: [1,null,0,null,1]<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/17.jpg" alt><br>解释:<br>只有红色节点满足条件“所有不包含 1 的子树”。<br>右图为返回的答案。</p></li><li><p>示例2:<br>输入: [1,0,1,0,0,0,1]<br>输出: [1,null,1,null,1]<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/18.jpg" alt></p></li><li><p>示例3:<br>输入: [1,1,0,1,1,0,1,0]<br>输出: [1,1,0,1,1,null,1]<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/19.jpg" alt></p></li></ul><p>说明:<br>给定的二叉树最多有100个节点。<br>每个节点的值只会为0或1。</p><blockquote><p>剪什么大家应该都能理解。那关键是怎么剪？过程也很简单，<strong>在递归的过程中，如果当前结点的左右节点皆为空，且当前结点为0，我们就将当前节点剪掉即可</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了78.18% 的Python3用户<br>内存消耗:13.5 MB,击败了5.40% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.1 MB, 在所有 Java 提交中击败了37.22% 的用户</p><h2 id="回溯系列"><a href="#回溯系列" class="headerlink" title="回溯系列"></a>回溯系列</h2><h3 id="1-全排列算法"><a href="#1-全排列算法" class="headerlink" title="1.全排列算法"></a>1.全排列算法</h3><blockquote><p>什么是全排列？从 n 个不同元素中任取 m（m≤n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列。当 m=n 时所有的排列情况叫全排列。</p></blockquote><p><strong>[第46题]</strong> 给定一个没有重复数字的序列，返回其所有可能的全排列。</p><ul><li>示例:<br>输入: [1,2,3]<br>输出:<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</li></ul><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>比如我们选择三个数字：</p><ul><li>在枚举第一位的时候，就有三种情况</li><li>在枚举第二位的时候，就只有两种情况（前面已经出现的一个数字不可以再出现）</li><li>在枚举第三位的时候，就只有一种情况（前面已经出现的两个数字不可以再出现）</li></ul><p>整个代码其实就干了这么一件事！其实就是说<strong>当枚举到最后一位的时候，这个就是我们要的排列结果，所以我们要放入到全排列结果集中。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        self.result = []</span><br><span class="line">        tmp = []</span><br><span class="line">        self.dfs(nums, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nums, tmp</span>):</span></span><br><span class="line">        <span class="comment"># 若长度相等，则添加到结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(tmp[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">                    <span class="comment"># 枚举第一位</span></span><br><span class="line">                    tmp.append(i)</span><br><span class="line">                    <span class="comment"># 找出第一位固定后的排列情况</span></span><br><span class="line">                    self.dfs(nums, tmp)</span><br><span class="line">                    <span class="comment"># 清除选择过的数字</span></span><br><span class="line">                    tmp.pop(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了94.22% 的Python3用户<br>内存消耗:13.5 MB,击败了67.02% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//数组转列表</span></span><br><span class="line">            ans.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//与当前level交换的可能</span></span><br><span class="line">            <span class="comment">//i = level时不动, i &gt; level时交换</span></span><br><span class="line">            swap(nums, i, level);</span><br><span class="line">            <span class="comment">//与下一level交换的可能</span></span><br><span class="line">            <span class="comment">//同理level+1可能不动，可能与大于level+1的数交换</span></span><br><span class="line">            dfs(nums, level + <span class="number">1</span>, ans);</span><br><span class="line">            <span class="comment">//恢复</span></span><br><span class="line">            swap(nums, i, level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口系列"><a href="#滑动窗口系列" class="headerlink" title="滑动窗口系列"></a>滑动窗口系列</h2><h3 id="1-滑动窗口最大值"><a href="#1-滑动窗口最大值" class="headerlink" title="1.滑动窗口最大值"></a>1.滑动窗口最大值</h3><p><strong>[第239题]</strong> 给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p><ul><li>示例:<br>输入: nums = [1,3,-1,-3,5,3,6,7], 和k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7 </span><br></pre></td></tr></table></figure></li></ul><p><strong>方法一：暴力求解</strong></p><blockquote><p>可以<strong>通过遍历所有的滑动窗口，找到每一个窗口的最大值，来进行暴力求解</strong>。那一共有多少个滑动窗口呢，小学题目，可以得到共有L-k+1个窗口。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - k + <span class="number">1</span>):</span><br><span class="line">            result.append(<span class="built_in">max</span>(nums[i: k + i]))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>运行失败:<br>Time Limit Exceeded<br>运行速度不行，会超时。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.length)&#123;</span><br><span class="line">            res[index++] = maxArray(nums, l, r);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = nums[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxValue) maxValue = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java也超时。。。。</p><p><strong>方法二：线性题解</strong></p><blockquote><p>最典型的解法还是使用双端队列，只要遍历该数组，同时在双端队列的头去维护当前窗口的最大值（在遍历过程中，发现当前元素比队列中的元素大，就将原来队列中的元素祭天），在整个遍历的过程中我们再记录下每一个窗口的最大值到结果数组中。最终结果数组就是我们想要的</p><p>假设nums = [1,3,-1,-3,5,3,6,7]，和k = 3</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/20.jpg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (<span class="built_in">len</span>(queue) &gt; <span class="number">0</span>) <span class="keyword">and</span> (nums[i] &gt; queue[-<span class="number">1</span>]):</span><br><span class="line">                <span class="comment"># 将比当前元素小的元素祭天</span></span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(nums[i])</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> nums[i - k] == queue[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 维护队列，保证其头元素为当前窗口最大值, 而不是之前窗口</span></span><br><span class="line">                <span class="comment"># 即当前窗口恰好与之前窗口的最大值分离时，要舍去之前窗口的最大值</span></span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 放入结果数组</span></span><br><span class="line">                result.append(queue[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:416 ms,击败了22.57% 的Python3用户<br>内存消耗:25.4 MB,击败了7.76% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//Queue窄化了LinkedList的访问,由于需要从右边弹出，这里使用LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty() &amp;&amp; queue.peekLast() &lt; nums[i]) queue.pollLast();</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k &amp;&amp; nums[i-k] == queue.peek()) queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>) res[i - k + <span class="number">1</span>] = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：38 ms, 在所有 Java 提交中击败了50.52% 的用户<br>内存消耗：52.7 MB, 在所有 Java 提交中击败了52.71% 的用户</p><h3 id="2-无重复字符的最长子串"><a href="#2-无重复字符的最长子串" class="headerlink" title="2.无重复字符的最长子串"></a>2.无重复字符的最长子串</h3><blockquote><p>对于大部分滑动窗口类型的题目，一般是<strong>考察字符串的匹配</strong>。比较标准的题目，会给出一个<strong>模式串B</strong>，以及一个<strong>目标串A</strong>。然后提出问题，找到<strong>A中符合对B一些限定规则的子串或者对A一些限定规则的结果</strong>，最终<strong>再将搜索出的子串完成题意中要求的组合或者其他</strong>。</p><p>而对于这一类题目，我们常用的解题思路，是去<strong>维护一个可变长度的滑动窗口</strong>。无论是使用<strong>双指针</strong>，还是使用<strong>双端队列</strong>，又或者用<strong>游标</strong>等其他奇技淫巧，目的都是一样的。</p></blockquote><p><strong>[第3题]</strong> 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><ul><li>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li><li>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</li><li>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。</li></ul><p><strong>方法一：双指针</strong></p><blockquote><p>假设我们的输入为“abcabcbb”，我们只需要维护一个窗口在输入字符串中进行移动。如下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/21.jpg" alt><br>当下一个元素在窗口没有出现过时，我们扩大窗口。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/22.jpg" alt><br>当下一个元素在窗口中出现过时，我们缩小窗口，将<strong>出现过的元素以及其左边的元素</strong>统统移出：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/23.jpg" alt><br>在整个过程中，我们<strong>记录下窗口出现过的最大值</strong>即可。而我们唯一要做的，只需要尽可能扩大窗口。</p><p>那我们代码中通过什么来维护这样的一个窗口呢？anyway~ 不管是队列，双指针，甚至通过map来<br>做，都可以。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                result.append(s[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                maxlen = <span class="built_in">max</span>(maxlen, right-left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><p>执行耗时:136 ms,击败了21.58% 的Python3用户<br>内存消耗:13.7 MB,击败了5.01% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(right))) set.remove(s.charAt(left++));</span><br><span class="line">            <span class="keyword">else</span> set.add(s.charAt(right++));</span><br><span class="line">            maxLen = Math.max(set.size(), maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：12 ms, 在所有 Java 提交中击败了23.70% 的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了23.38% 的用户</p><p><strong>方法二：字典</strong></p><blockquote><p>通过观察，我们能看出来。如果是最坏情况的话，我们每一个字符都可能会访问两次，left一次，right一次，时间复杂度达到了O(2N)</p><p>假设我们的字符串为“abcdc”，对于abc我们都访问了2次。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/24.jpg" alt><br>那如何来进一步优化呢？其实我们可以定义<strong>字符到索引的映射</strong>，而不是简单通过一个集合来判断字符是否存在。这样的话，当我们<strong>找到重复的字符时，我们可以立即跳过该窗口</strong>，而不需要对之前的元素进行再次访问。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/25.jpg" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 如果有重复字符直接跳过该窗口</span></span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                left = <span class="built_in">max</span>(<span class="built_in">map</span>[s[right]], left)</span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, right-left+<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">map</span>[s[right]] = right + <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><p>执行耗时:68 ms,击败了86.27% 的Python3用户<br>内存消耗:13.5 MB,击败了34.59% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right))) left = Math.max(left, map.get(s.charAt(right)));</span><br><span class="line">            maxLen = Math.max(right-left+<span class="number">1</span>, maxLen);</span><br><span class="line">            map.put(s.charAt(right), right+<span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：9 ms, 在所有 Java 提交中击败了40.45% 的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了61.39% 的用户</p><p><strong>方法三：利用ASCII映射，数组代替字典</strong></p><blockquote><p>我们可以使用一个128位的数组来替代字典。（因为ASCII码表里的字符总共有128个。ASCII码的长度是一个字节，8位，理论上可以表示256个字符，但是许多时候只谈128个。具体原因可以下去自行学习~）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        charIndex = [<span class="number">0</span>]*<span class="number">128</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 如果有重复字符直接跳过该窗口</span></span><br><span class="line">            <span class="comment"># ord()将字符转ASCII码</span></span><br><span class="line">            left = <span class="built_in">max</span>(charIndex[<span class="built_in">ord</span>(s[right])], left)</span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, right-left+<span class="number">1</span>)</span><br><span class="line">            charIndex[<span class="built_in">ord</span>(s[right])] = right + <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><p>执行耗时:68 ms,击败了86.27% 的Python3用户<br>内存消耗:13.5 MB,击败了11.53% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] charIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            left = Math.max(left, charIndex[s.charAt(right) + <span class="number">0</span>]);</span><br><span class="line">            maxLen = Math.max(right-left+<span class="number">1</span>, maxLen);</span><br><span class="line">            charIndex[s.charAt(right) + <span class="number">0</span>] = right + <span class="number">1</span>;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了88.31% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了40.58% 的用户</p><h3 id="3-找到字符串中所有字母异位词"><a href="#3-找到字符串中所有字母异位词" class="headerlink" title="3.找到字符串中所有字母异位词"></a>3.找到字符串中所有字母异位词</h3><p><strong>[第438题]</strong> 给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过20100。<br>说明：<br>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。</p><ul><li>示例 1:<br>输入: s: “cbaebabacd” p: “abc”<br>输出: [0, 6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。</li><li>示例 2:<br>输入: s: “abab” p: “ab”<br>输出: [0, 1, 2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</li></ul><blockquote><p>我们通过双指针维护一个窗口，由于我们只需要判断字母异位词，我们可以将窗口初始化大小和目标串保持一致。</p><p>而判断字母异位词，我们需要<strong>保证窗口中的字母出现次数与目标串中的字母出现次数一致</strong>。</p><p>我们通过移动窗口，来更新窗口数组，进而和目标数组匹配，匹配成功进行记录。每一次窗口移动，<strong>左指针前移</strong>，原来<strong>左指针位置处的数值减1，表示字母移出</strong>；<strong>同时右指针前移，右指针位置处的数值加1，表示字母移入</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 思路:</span></span><br><span class="line">        <span class="comment"># 想象一个窗口在s上向右移动,窗口宽度为len(p)</span></span><br><span class="line">        <span class="comment"># 只要窗口内的字符串各字符数量与p中一致,则匹配成功</span></span><br><span class="line">        <span class="comment"># 窗口在向右移动的时候,只需要将最左端的值从字典中删除,将最右端+1的值加入字典即可.</span></span><br><span class="line"></span><br><span class="line">        pmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 初始化目标窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">            <span class="comment">#  get() 函数返回指定键的值, 如果键不在字典中返回默认值 None 或者设置的默认值。</span></span><br><span class="line">            pmap[i] = pmap.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        plenth = <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">        rlist = []</span><br><span class="line">        rmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 每次移动窗口，右指针值加1</span></span><br><span class="line">            rmap[v] = rmap.get(v, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 与目标窗口匹配，返回左指针索引</span></span><br><span class="line">            <span class="keyword">if</span> rmap == pmap:</span><br><span class="line">                rlist.append(i - plenth + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 每次移动窗口，左指针值减1，当为0时删除</span></span><br><span class="line">            <span class="keyword">if</span> i - plenth + <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                rmap[s[i - plenth + <span class="number">1</span>]] = rmap.get(s[i - plenth + <span class="number">1</span>]) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> rmap[s[i - plenth + <span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> rmap[s[i - plenth + <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rlist</span><br></pre></td></tr></table></figure><p>执行耗时:144 ms,击败了48.40% 的Python3用户<br>内存消耗:14.2 MB,击败了87.61% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; pmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> pLength = p.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pLength; i++) pmap.put(p.charAt(i), pmap.getOrDefault(p.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        Map&lt;Character, Integer&gt; rList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            rList.put(s.charAt(i), rList.getOrDefault(s.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(rList.equals(pmap)) res.add(i-pLength+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((i - pLength + <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                rList.put(s.charAt(i - pLength + <span class="number">1</span>), rList.get(s.charAt(i - pLength + <span class="number">1</span>))-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (rList.get(s.charAt(i - pLength + <span class="number">1</span>)) == <span class="number">0</span>) rList.remove(s.charAt(i - pLength + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：118 ms, 在所有 Java 提交中击败了15.26% 的用户<br>内存消耗：39.8 MB, 在所有 Java 提交中击败了21.13% 的用户</p><h3 id="4-和为S的连续正数序列"><a href="#4-和为S的连续正数序列" class="headerlink" title="4.和为S的连续正数序列"></a>4.和为S的连续正数序列</h3><p><strong>[剑指57-II]</strong> 输入一个正整数target ，输出所有和为target的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><ul><li>示例 1：<br>输入：target = 9<br>输出：[[2,3,4],[4,5]]</li><li>示例 2：<br>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</li></ul><blockquote><p>假若我们输入的target为9，大脑中应该有下面这么个玩意：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/40.png" alt><br>然后我们通过左右指针来维护一个滑动窗口，同时计算窗口内的值是否是目标值：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/41.png" alt><br>如果窗口的值过小，我们就移动右边界。<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/42.png" alt><br>如果窗口的值过大，我们就移动左边界。<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/43.png" alt><br>剩下的就是反复上面的操作就可以了。<strong>对于任意一个正整数，总是小于它的中值与中值+1的和。</strong><br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/44.png" alt><br>比如这里的100，就一定小于50+51，换成其他数也一样。换句话说，<strong>一旦窗口左边界超过中值，窗口内的和一定会大于target</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> tmp &lt; target:</span><br><span class="line">                tmp += j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp &gt; target:</span><br><span class="line">                tmp -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(i, j)])</span><br><span class="line">                tmp -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:104 ms,击败了84.47% 的Python3用户<br>内存消耗:13.5 MB,击败了19.37% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= target / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; target) tmp += right++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; target) tmp -= left++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) temp[i] = left + i;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                tmp -= left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了79.58% 的用户<br>内存消耗：36.6 MB, 在所有 Java 提交中击败了47.66% 的用户</p><h2 id="博弈论系列"><a href="#博弈论系列" class="headerlink" title="博弈论系列"></a>博弈论系列</h2><blockquote><p>本系列将为大家带来一整套的博弈论问题。因为在面试的过程中，除了常规的算法题目，我们经<br>常也会被问到一些趣味题型来考察思维，而这类问题中，很多都有博弈论的影子存在。这些公司里以FLAG（Facebook, LinkedIn, Amazon, Google）为典型，特别喜欢考察本类题型。同时，本系列将不一定都是算法问题，不是IT行业的小伙伴也可以进行学习，来提高分析问题的能力~</p></blockquote><h3 id="1-囚徒困境"><a href="#1-囚徒困境" class="headerlink" title="1.囚徒困境"></a>1.囚徒困境</h3><p>一件严重的纵火案发生后，警察在现场抓到两个犯罪嫌疑人。事实上，正是他们一起放火烧了这座仓库。但是，警方没有掌握足够的证据，只得把他们分开囚禁起来，要求他们坦白交代。</p><p>在分开囚禁后，警察对其分别告知：<br>如果你坦白，而对方不坦白，则将你释放，判对方8年。<br>如果你不坦白，而对方坦白，则将对方释放，而判你8年。<br>如果你两都坦白了，则判你两各自4年。<br>那么两个囚犯应该如何做，是互相背叛还是一起合作？</p><p><strong>题目分析</strong> 从表面上看，其实囚犯最应该的就是一起合作，都不坦白，这样因为证据不足，会将两人都进行释放。<br>但是！因为事实确实是两人放的火，所以他们<strong>不得不进行思考，另一人采取了什么样的行为？</strong></p><p>犯人甲当然不傻，他根本无法相信同伙不会向警方提供任何信息！因为如果同伙一旦坦白，而自己这边如果什么都没说的话，就可以潇洒而去。但他同时也意识到，他的同伙也不傻，也会同样来这样设想他。</p><p>所以犯人甲的结论是，<strong>唯一理性的选择就是背叛同伙</strong>，把一切都告诉警方！这样的话，如果他的同伙笨得只会保持沉默，那么他就会是那个离开的人。而如果他的同伙也根据这个逻辑向警方交代了，那么也没有关系，起码他不必服最重的刑！</p><p>这场博弈的过程，<strong>显然不是顾及团体利益的最优解决方案</strong>。以全体利益而言，如果两个参与者都合作保持沉默，两人都可以无罪释放，总体利益更高！但根据假设（人性），二人<strong>均为理性的个人</strong>，且只追求自己的个人利益。均衡状况会是两个囚徒都选择背叛，这就是“困境”所在！</p><p>事实上，这种<strong>两人都选择坦白的策略以及因此被判4年的结局</strong>被称作“<strong>纳什均衡</strong>”（也叫非合作均衡），换言之，在此情况下，<strong>无一参与者可以“独自行动”（即单方面改变决定）而增加收获</strong>。</p><p>我们看一下官方释意是多么难懂“所谓纳什均衡，指的是参与人的一种策略组合，在该策略组合上，<strong>任何参与人单独改变策略都不会得到好处</strong>。”简单点讲，如果在一个策略组合上，当所有其他人都不改变策略时，没有人会改变自己的策略，则该策略组合就是一个纳什均衡。</p><h3 id="2-辛普森悖论"><a href="#2-辛普森悖论" class="headerlink" title="2.辛普森悖论"></a>2.辛普森悖论</h3><p>羊羊医院里统计了两种胆结石治疗方案的治愈率。在统计过程中，医生将病人分为大胆结石和小胆结石两组。统计结果如下：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/26.jpg" alt></p><ul><li>对于小胆结石而言，手术A的治愈率（93%）高于手术B（87%）</li><li>对于大胆结石而言，手术A的治愈率（73%）高于手术B（69%）</li></ul><p><strong>羊羊医院的医生得出结论：</strong></p><p>无论是对于大小胆结石，手术A的治愈率都胜过手术B。</p><p>但是真的是这样吗？当然不是，我们根据样本统计出大小胆结石总计的治愈率，发现<strong>手术B(治愈率83%)其实是要高于手术A(治愈率78%)</strong>。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/27.jpg" alt></p><p>为什么会出现这样的结果？这就是著名的<strong>辛普森悖论</strong>。</p><p><strong>题目分析</strong> 得到了结论，我们来思考背后的东西。在我们的直觉里有这样一个逻辑：<strong>如果一个事物的各部分都分别大于另一个事物的各部分，那么这个事物大于另一个事物</strong>。比如：我们的直觉告诉我们如果手术A在两组病人中都更好，那么在所有病人中也应该更好。<br>我们可以将其公式化（<strong>该公式错误</strong>），假设：</p><p>A=A1+A2+….+An<br>B=B1+B2+….+Bn<br>如果对i=1,2…,n都有Ai&gt;Bi，则A&gt;B</p><p>乍一看，我们觉得该公式没有问题，所以这个公式也就代表了我们大部分人的思维工作。其实在这个公式中，隐藏掉了一个很重要的条件：<strong>A1、A2、An 以及 B1、B2、Bn 并不能简单的通过“加”来得到 A或者B</strong>。这就是<strong>可加性</strong>的前提。在大脑的思维过程中，因为我们很难直接看到这个前提，进而就导致了我们错误的思考！</p><p>下面我们举一些在生活中常见的辛普森悖论例子：</p><ul><li>打麻将的时候，把把都赢小钱，造成赢钱的假象，其实不如别人赢一把大的。</li><li>在苹果和安卓的竞争中，你听见身边的人都在逃离苹果，奔向安卓。但是其实苹果的流入率还是要高于安卓。（有数据证明，很经典的案例）</li><li>你男票，这里比别人差，那里比别人差，但是其实他真的比别的男生差吗？（这个纯属本人胡扯了..）</li></ul><h3 id="3-红眼睛和蓝眼睛"><a href="#3-红眼睛和蓝眼睛" class="headerlink" title="3.红眼睛和蓝眼睛"></a>3.红眼睛和蓝眼睛</h3><p>一个岛上有100个人，其中有5个红眼睛，95个蓝眼睛。这个岛有三个奇怪的宗教规则。</p><p>1.他们不能照镜子，不能看自己眼睛的颜色。<br>2.他们不能告诉别人对方的眼睛是什么颜色。<br>3.一旦有人知道了自己是红眼睛，他就必须在当天夜里自杀。</p><p>某天，有个旅行者到了这个岛上。由于不知道这里的规矩，所以他在和全岛人一起狂欢的时候，不留神就说了一句话：【你们这里有红眼睛的人。】</p><p>问题：假设这个岛上的人每天都可以看到其他所有人，每个人都可以做出缜密的逻辑推理，请问岛上会发生什么？</p><p><strong>题目分析</strong> 题目乍看之下，没有任何逻辑可言！以目测条件，基本无法完成任何正常的推理。但是在仔细推敲之后，我们可以将问题简化，从假设只有1个红眼睛开始分析。</p><p>我们假设岛上只有1个红眼睛的人，还有99个都是蓝眼睛。因为这个旅行者说了“这里有红眼睛的人”，<strong>那么在第一天的时候，这个红眼睛会发现其他的人都是蓝眼睛</strong>（与此同时，其他人因为看到了这个红眼睛的人，所以都确认了自己的安全）<strong>那么这天晚上，这个红眼睛的人一定会自杀！</strong></p><p>继续分析，假设这个岛上有2个红眼睛，那么当旅行者说“这里有红眼睛的人”之后的第一天，这两个红眼睛分别发现还有别的红眼睛存在，所以他们当天晚上认为自己是安全的。但是到了第二天，红眼睛惊讶的发现，<strong>另一个红眼睛的人竟然没有自杀（说明岛上有不止一个红眼睛），并且当天他们也没有发现有别的红眼睛存在（说明另一个红眼睛就是自己）</strong>WTF，那肯定另一个红眼睛就是自己了，所以<strong>在第二天夜里，两个红眼睛的人会同时自杀！</strong></p><p>继续分析，假如岛上红眼睛有3个。那么在第一天，红眼睛发现了岛上还有另外两个红眼睛，红眼睛呵呵一笑，“反正不是我”。到了第二天，红眼睛仍然看到了另外两个红眼睛，红眼睛心想，”这下你两该完蛋了吧”，毕竟你两都知道了自己是红眼睛，晚上回去统统自杀吧！（根据上面的推论得出）但是惊奇的是，<strong>到了第三天，红眼睛发现另外两个红眼睛竟然都没有自杀。（说明岛上红眼睛的人不止两个）</strong>并且当天红眼睛也没发现新的红眼睛（<strong>说明还有一个红眼睛就是自己</strong>）所以在第三天的夜里，三个红眼睛会同时自杀。</p><p>根据上面的推论，<strong>假设有N个红眼睛，那么到了第N天，这N个红眼睛就会自杀</strong>。所以最终这个岛上红眼睛的人会统统自杀！这就是答案，生活就是这么朴实无华，且枯燥。</p><p><strong>旅客的挽回</strong><br>上面的分析大家应该都看懂了。但若是在旅客说完这句话后，其并没有离开这个岛。同时他也看到了周围人眼里的惊慌和失措，这个时候，旅客为自己的行为感到了懊恼和悔恨！旅客决定对自己的话进行挽回，旅客又该怎么做呢？</p><p>这里我提供一种思路，<strong>旅客可以在第N次集会上杀掉N个红眼睛</strong>，让这N个红眼睛 “GO TO SLEEP”，就可以中断事件的推理。事实上，基于人道主义，旅客并不需要手动杀人，她只需要在第N天的时候告诉这N个人，你们是红眼睛，那么这天晚上，这N个人就会自杀。”All RETURN”，一切将回归秩序~</p><h3 id="4-海盗分金币"><a href="#4-海盗分金币" class="headerlink" title="4.海盗分金币"></a>4.海盗分金币</h3><p>在大海上，有5个海盗抢得100枚金币，他们决定每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得半数或半数以上的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼。那么第一个提出方案的人要怎么做，才能使自己的利益最大化？</p><p>海盗们有如下特点：<br>1.足智多谋，总是采取最优策略。<br>2.贪生怕死，尽量保全自己性命。<br>3.贪得无厌，希望自己得到越多宝石越好<br>4.心狠手辣，在自己利益最大的情况下希望越多人死越好。<br>5.疑心多虑，不信任彼此，尽量确保自身利益不寄希望与别人给自己更大利益。</p><p><strong>题目分析</strong> 首先我们很容易会觉得，抽签到第一个提方案的海盗会很吃亏！因为只要死的人够多，那么平均每个人获取的金币就最多，而第一个提方案的人是最容易死的。但是事实是，在满足海盗特点的基础上，<strong>第一个提方案的海盗是最赚的</strong>，我们一起来分析一下。</p><p>假如我们设想只有两个海盗。那么不管第一个说什么，只要第二个人不同意，第二个人就可以得到全部的金币！所以第一个海盗必死无疑，这个大家都能理解。（当然，这样的前提是一号提出方案后不可以马上自己同意，不然如果自己提出给自己全部金币的方案，然后自己支持，这样就是二号必死无疑）</p><p>假如现在我们加入第三个海盗，这时候原来的一号成为了二号，二号成为了三号。这时候现在的二号心里会清楚，<strong>如果他投死了一号，那么自己必死无疑！</strong>所以根据贪生怕死的原则，二号肯定会让一号存活。而此时一号心理也清楚，无论自己提出什么样的方案，二号都会让自己存活，而这时只要加上自己的一票，就有半数通过，所以一号提出方案：把金币都给我。</p><p>现在又继续加入了新的海盗！原来的1,2,3号，成为了现在的2,3,4号。这时候新的一号海盗洞悉了奥秘，知道了<strong>如果自己死了，二号就可以获取全部的金币</strong>，所以提出给三号和四号一人一个金币，一起投死2号。而与此同时，现在的3号和4号获取的要比三个人时多（三个人时自己获取不了任何金币），所以他们会同意这个方案！</p><p>现在加入我们的大Boss，最后一个海盗。根据分析，大Boss海盗1号推知出2号的方案后就可以提出(97,0,1,2,0)或者(97,0,1,0,2)的方案。这样的分配方案对现在的3号海盗相比现在的2号的分配方案还多了一枚金币，就会投赞成票，4号或者5号因为得到了2枚金币，相比2号的一枚多，也会支持1号，加上1号自己的赞成票，方案就会通过，即1号提出(97,0,1,2,0)或(97,0,1,0,2)的分配方案，大Boss成功获得了97枚金币。</p><p><strong>思考</strong> 最终，大Boss一号海盗得到97枚金币，投死了老二和老五，这竟然是我们分析出的最佳方案！这个答案明显是反直觉的，如果你是老大，你敢这样分金币，必死无疑。可是，推理过程却非常严谨，无懈可击，那么问题出在哪里呢？</p><p>其实，在”海盗分赃”模型中，任何”分配者”想让自己的方案获得通过的关键是，事先考虑清楚”对手”的分配方案是什么，<strong>并用最小的代价获取最大收益，拉拢”对手”分配方案中最不得意的人们</strong>。1号看起来最有可能喂鲨鱼，但他牢牢地把握住先发优势，结果不但消除了死亡威胁，还收益最大。而5号，看起来最安全，没有死亡的威胁，甚至还能坐收渔人之利，却因不得不看别人脸色行事而只能分得一小杯羹。</p><p>不过，模型任意改变一个假设条件，最终结果都不一样。而现实世界远比模型复杂。<strong>因为假定所有人都理性，本身就是不理性的。</strong>回到“海盗分金”的模型中，只要3号、4号或5号中有一个人偏离了绝对聪明的假设，海盗1号无论怎么分都可能会被扔到海里去了。所以，1号首先要考虑的就是他的海盗兄弟们的聪明和理性究竟靠得住靠不住，否则先分者必定倒霉。</p><p>如果某人和一号本身不对眼，就想丢他喂鲨鱼。果真如此，1号自以为得意的方案岂不成了自掘坟墓。再就是俗话所说的“人心隔肚皮”。由于信息不对称，谎言和虚假承诺就大有用武之地，而阴谋也会像杂草般疯长，并借机获益。如果2号对3、4、5号大放烟幕弹，宣称对于1号所提出任何分配方案，他一定会再多加上一个金币给他们。这样，结果又当如何？</p><p>通常，现实中人人都有自认的公平标准，因而时常会嘟嚷：“<strong>谁动了我的奶酪？</strong>”可以料想，一旦1号所提方案和其所想的不符，就会有人大闹。当大家都闹起来的时候，1号能拿着97枚金币毫发无损、镇定自若地走出去吗？最大的可能就是，海盗们会要求修改规则，然后重新分配。当然，大家也可以讲清楚下次再得100枚金币时，先由2号海盗来分…然后是3号……颇有点像美国总统选举，轮流主政。说白了，其实是民主形式下的分赃制。</p><p>最可怕的是其他四人形成一个反1号的大联盟并制定出新规则：四人平分金币，将1号扔进大海。这就颇有点阿Q式的革命理想：高举平均主义的旗帜，将富人扔进死亡深渊。</p><h3 id="5-智猪博弈"><a href="#5-智猪博弈" class="headerlink" title="5.智猪博弈"></a>5.智猪博弈</h3><p>假设猪圈里有一头大猪、一头小猪。猪圈的一头有猪食槽，另一头安装着控制猪食供应的按钮，按一下按钮会有10个单位的猪食进槽，,但是按按钮以后跑到食槽所需要付出的劳动量，加起来要消耗相当于2个单位的猪食。并且因为按钮和食槽分置笼子的两端，等到按按钮的猪付出劳动跑到食槽的时候，坐享其成的另一头猪早已吃了不少。如果大猪先到（小猪按），大猪吃掉9个单位，小猪只能吃到1个单位；如果同时到达（也就是一起按），大猪吃掉7个单位，小猪吃到3个单位；如果小猪先到（大猪按），小猪可以吃到4个单位，而大猪吃到6个单位。那么，在两头猪都足够聪明的前提下，最终的结果是什么？</p><blockquote><p>首先小猪如果去按按钮，然后再回来的话，只能吃到一份猪食，直接就嗝屁了，这种可能性肯定是不行的。自然，这时大猪也就只有去按按钮这一个选项了。所以最终的结果会是：<strong>小猪选择等待，大猪去按按钮</strong>。</p><ul><li><p>如果小猪和大猪同时行动的话，则它们同时到达食槽，分别得到1个单位和5个单位的纯收益（付出4个单位的成本）</p></li><li><p>如果大猪行动，小猪等待，小猪可得到4个单位的纯收益，大猪得到的6个单位，付出2个单位的成本，实得4个单位；</p></li><li><p>如果大猪等待，小猪行动，小猪只能吃到1个单位，则小猪的收入将不抵成本，纯收益为-1。</p></li><li><p>如果大猪等待，小猪也等待，那么小猪的收益为零，成本也为零，总之，小猪等待还是要优于行动。</p></li></ul><p>这道题目是一个很经典的“<strong>劣势策略”下的可预测问题</strong>，其在各高校经济学课程中也被放在一个举足轻重的地位上。原因无他，正是大猪做出这样一个“决策”，目的不是出于对小猪的爱，<strong>而是基于“自利”的原则</strong>。</p></blockquote><h3 id="6-生男生女问题"><a href="#6-生男生女问题" class="headerlink" title="6.生男生女问题"></a>6.生男生女问题</h3><div class="table-container"><table><thead><tr><th>题目：国家为了调控男女比例，制定了一个政策：新婚夫妇都必须生娃（接地气），如果生出的是男娃就不能再生了，如果生出的是女娃就必须继续生下去，直到生出第一个男娃为止（出题人牛P）。</th></tr></thead><tbody><tr><td>问题是：若干年后，该国的男女比例会发生怎样的变化？</td></tr></tbody></table></div><blockquote><p>其实这个问题答案是比较反直觉的：<strong>没有变化</strong>。原因是因为：<strong>生男生女的概率永远都是百分之50</strong>。</p><p>或者我们也可以换一种思路：我们不妨假设把一大批新婚夫妇关在一个超大的屋子里，逼着他们进行一轮一轮的生孩子游戏。第一轮里，有一半的夫妇生了男娃，退出了游戏；另一半夫妇得到的是女娃，进入第二轮。在第二轮里面，又有一半由于生出男娃而退出，自然，另一半生出女娃的夫妇进入第三轮……注意到，在每一轮里，新生男娃和新生女娃都是一样多的，因此把所有轮数合在一起看，男娃的总数和女娃的总数也一定是相同的。</p></blockquote><h3 id="7-硬币问题"><a href="#7-硬币问题" class="headerlink" title="7.硬币问题"></a>7.硬币问题</h3><div class="table-container"><table><thead><tr><th>题目：A和B两人为了竞价一个拍卖品，决定用抛掷硬币的办法来判断谁有资格。为了让游戏过程更加刺激，A提出了这样一个方案：连续抛掷硬币，直到最近三次硬币抛掷结果是“正反反”或者“反反正”。如果是前者，那么A获胜；如果是后者，那么B获胜</th></tr></thead><tbody><tr><td>问题是：B应该接受A的提议吗？换句话说，这个游戏是公平的吗？</td></tr></tbody></table></div><blockquote><p>事实，该游戏并不公平。虽然“正反反”和“反反正”在频率上出现的一样，但是其之间却有一个竞争关系：<strong>一旦抛硬币产生其中一种序列，游戏即结束</strong>。所以不论何时，只要抛出一个正面，也就意味着B必输无疑。换句话说，在整个游戏的前两次抛掷中，只要出现“正正”，“正反”，“反正”其中任一，A则一定会取得胜利。A和B的概率比达到3:1，优势不言而喻。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/45.png" alt></p></blockquote><h3 id="8-画圈圈的问题"><a href="#8-画圈圈的问题" class="headerlink" title="8.画圈圈的问题"></a>8.画圈圈的问题</h3><div class="table-container"><table><thead><tr><th>面试题：小浩出去面试时，面试官拿出一张纸，在纸上从左到右画了一百个小圆圈（手速快，没办法）接下来，面试官要求两人轮流涂掉其中一个或者两个相邻的小圆圈。</th></tr></thead><tbody><tr><td>规定：谁涂掉最后一个小圆圈谁就赢了（换句话说，谁没有涂的了谁就输了）。问题是：小浩应该选取先涂还是后涂？如何才能有必胜策略？</td></tr></tbody></table></div><blockquote><p> 作为聪明机智的小浩（没见过这么夸自己的），最后当然是小浩获胜。获胜的方法：<strong>小浩强烈要求先手进行游戏，并且在游戏开始时，先把正中间的两个小圆圈涂黑，于是左右两边各剩下了49个圆圈</strong>。像是下面这样：</p><p> <img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/46.png" alt><br> 然后小浩开始模仿（逼死）面试官，面试官在左边涂掉哪些圆圈，小浩就对称地在右边涂掉哪些圆圈；面试官在右边涂掉哪些圆圈， 小浩就对称地在左边涂掉哪些圆圈。因此，只要面试官有走的，小浩就一定有走的，最终保证能获胜。</p><p> 在博弈论中，这类游戏就叫做“<strong>无偏博弈</strong>”（impartial game）。<strong>在无偏博弈中，如果对于某个棋局状态，谁遇到了它谁就有办法必胜，我们就把它叫做“必胜态”；如果对于某个棋局状态，谁遇到了它对手就会有办法必胜，我们就把它叫做“必败态”</strong>。</p></blockquote><h3 id="9-巧克力问题"><a href="#9-巧克力问题" class="headerlink" title="9.巧克力问题"></a>9.巧克力问题</h3><div class="table-container"><table><thead><tr><th>面试题：小浩出去面试时，面试官掏出一块10×10个小块的巧克力。首先，面试官把巧克力掰成两大块，并且吃掉其中一块，把另一块交给小浩。小浩再把剩下的巧克力掰成两大块，吃掉其中一块，把另一块交回给面试官。两个人就这样无聊且枯燥的掰呀掰。。。</th></tr></thead><tbody><tr><td>规定：谁没办法往下继续掰，谁就输了。如果面试官先开始掰的话，面试官和小浩谁有必胜策略？（面试官输了，小浩将赢得面试）</td></tr></tbody></table></div><blockquote><p>作为聪明机智的小浩（没见过这么夸自己的），最后当然是小浩获胜。获胜的方法：<strong>只要小浩一直保持巧克力是正方形就可以了</strong>。不管面试官咋掰，最后都会掰成一个长宽不相等的正方形。直到最后一次将其变成一个1×1的巧克力，此时面试官就输掉了面试。哦不，是小浩赢得了面试。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/47.png" alt></p></blockquote><p><strong>[超级改编版]</strong> 如果巧克力换成边长为10的等边三角形，长这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/48.png" alt></p><p>每次只能<strong>沿着线条掰下一个小等边三角形吃掉</strong>，假若还是由面试官开局，请问，谁必胜？</p><blockquote><p>等边三角形是小浩赢。</p><p>1.面试官先手沿着任意一条线掰开。<br>2.剩下的等腰梯形中，小浩从面试官掰开处将等腰梯形掰成等边三角形和平行四边形，将平行四边形还给面试官。<br>3.面试官在平行四边形的两个角中任意掰出个等边三角形。<br>4.小浩掰另一个角大小跟面试官一致，此时剩下的巧克力有三种可能的形态：</p><ul><li>平行四边形缺了两个小角：此形状给面试官 他已经没有办法掰出一个等边三角形。面试官输了。</li><li>依然是平行四边形：陷入此步循环，直到掰没了：最后的平行四边形可以由两个等边三角形组合而成，小浩后掰，小浩赢了。</li></ul></blockquote><h3 id="10-大鱼和小鱼的问题"><a href="#10-大鱼和小鱼的问题" class="headerlink" title="10.大鱼和小鱼的问题"></a>10.大鱼和小鱼的问题</h3><div class="table-container"><table><thead><tr><th>大鱼小鱼的问题：假设有10条鱼，它们从小到大依次编号为1, 2, …, 10。我们规定，吃鱼必须要严格按顺序执行。也就是说，大鱼只能吃比自己小一级的鱼，不能越级吃更小的鱼；并且只有等到第k条鱼吃了第k-1条鱼后，第k+1条鱼才能吃第k条鱼。</th></tr></thead><tbody><tr><td>同时：第1条鱼则啥都不能吃，只有被吃的份儿。我们假设，如果有小鱼吃的话，大鱼肯定不会放过；但是，保全性命的优先级显然更高，在吃小鱼之前，大鱼得先保证自己不会被吃掉才行。假设每条鱼都是无限聪明的（并且它们也都知道这一点，并且它们也都知道它们知道这一点……），那么第1条鱼能存活下来吗？</td></tr></tbody></table></div><blockquote><p>我们是有十条鱼，分析起来是比较麻烦的。所以我们从最简单的两条鱼开始分析：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/49.png" alt><br>两条鱼的情况下，第二条鱼就是无敌的存在，他不用担心自己被吃掉！如果是三条鱼：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/50.png" alt><br>3条鱼的情况下，第2条鱼不能吃第1条鱼，否则将化为只有2条鱼的情形，它将会被第3条鱼吃掉。如果是四条鱼，就有意思了：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/51.png" alt><br>此时第2条鱼可以大胆地吃掉第1条鱼，因为根据前面的结论，它知道第3条鱼是不敢吃它的。问题来了，五条鱼会如何：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/52.png" alt><br>5条鱼的情况下，第2条鱼是不敢吃第1条鱼的，因为如果它吃了第一条鱼。问题转化为4条鱼的场景，原3号鱼就可以大胆吃掉原2号鱼，因为它知道4号鱼是不敢吃它的，否则5号鱼就会吃掉4号鱼（绕不绕）。</p><p>我们发现一个有趣的结论，只要鱼有奇数个，那么第一条鱼将总是可以活下来。如果鱼是偶数个，那么第二条鱼将总是可以吃掉第一条鱼，将状态转化到奇数条鱼的场景。</p><p>所以该题的答案是：不能，在十条鱼的场景下，第一条鱼必死无疑。</p></blockquote><h2 id="排序系列"><a href="#排序系列" class="headerlink" title="排序系列"></a>排序系列</h2><h3 id="1-按奇偶排序数组"><a href="#1-按奇偶排序数组" class="headerlink" title="1.按奇偶排序数组"></a>1.按奇偶排序数组</h3><blockquote><p>插入排序：就是炸金花的时候，你接一个同花顺的过程。（标准定义：在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的）</p></blockquote><p><strong>[第905题]</strong> 给定一个非负整数数组A，返回一个数组，在该数组中， A的所有偶数元素之后跟着所有奇数元素。你可以返回满足此条件的任何数组作为答案。</p><ul><li>示例：<br>输入：[3,1,2,4]<br>输出：[2,4,3,1]<br>输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</li></ul><blockquote><p>这道题，按照插入排序的思想，很容易可以想到题解。我们只需要遍历数组，当我们遇到偶数时，将其插入到数组前最近的一个为奇数的位置，<strong>与该位置的奇数元素交换</strong>。为了达成该目的，我们引入一个指针 j，来维持这样一个奇数的位置。</p><p>假设我们的数组为：[3,1,2,4]</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/28.jpg" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                A[j], A[i] = A[i], A[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><p>执行耗时:100 ms,击败了61.73% 的Python3用户<br>内存消耗:13.9 MB,击败了50.05% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">0</span>) swap(A, i, j++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：39.6 MB, 在所有 Java 提交中击败了5.02% 的用户</p><h2 id="位运算系列"><a href="#位运算系列" class="headerlink" title="位运算系列"></a>位运算系列</h2><h3 id="1-使用位运算求和"><a href="#1-使用位运算求和" class="headerlink" title="1.使用位运算求和"></a>1.使用位运算求和</h3><blockquote><p>该题很容易出现在各大厂的面试中，属于必须掌握的题型。</p></blockquote><p><strong>[剑指offer 64]</strong> 求 1 2 … n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><ul><li>示例 1：<br>输入: n = 3 输出: 6</li><li>示例 2：<br>输入: n = 9 输出: 45</li><li>限制：<br>1 &lt;= n &lt;= 10000</li></ul><blockquote><p>题目上手，因为不能使用公式直接计算（公式中包含乘除法），所以考虑使用递归进行求解，但是递归中一般又需要使用if来指定返回条件（这里不允许使用if），所以没办法使用普通的递归思路。</p><p>首先我们了解一下 &amp;&amp; 的特性，比如有 A&amp;&amp;B<br>如果A为true，返回B的布尔值（继续往下执行）<br>如果A为false，直接返回false（相当于短路）</p><p>利用这一特性，我们将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件，递归主体转换为第二个条件语句。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">		<span class="keyword">return</span> n <span class="keyword">and</span> (n + self.sumNums(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>执行用时：48 ms, 在所有 Python 提交中击败了10.79% 的用户<br>内存消耗：20.1 MB, 在所有 Python 提交中击败了37.95% 的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了58.91% 的用户<br>内存消耗：35.8 MB, 在所有 Java 提交中击败了28.19% 的用户</p><h3 id="2-2的幂"><a href="#2-2的幂" class="headerlink" title="2.2的幂"></a>2.2的幂</h3><p><strong>[第231题]</strong> 给定一个整数，编写一个函数来判断它是否是2的幂次方。</p><ul><li>示例 1:<br>输入: 1<br>输出: true<br>解释: $2^0 $= 1</li><li>示例 2:<br>输入: 16<br>输出: true<br>解释: $2^4$ = 16</li><li>示例 3:<br>输入: 218<br>输出: false</li></ul><blockquote><p>先观察一些是2的幂的二进制数：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/29.jpg" alt><br>然后我们再观察下面这样的一组数，对应着上面的数减去1：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/30.jpg" alt><br>我们对两组数求“&amp;”运算：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/31.jpg" alt><br>可以看到，对于N为2的幂的数，都有 N&amp;(N-1)=0 ，所以这就是我们的判断条件。（这个技巧可以记忆下来，在一些别的位运算的题目中也是会用到的）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n-<span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>执行耗时:52ms,击败了17.68% 的Python3用户<br>内存消耗:13.3 MB,击败了77.73% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a % b 若b为2的整数次幂，则该式等价于a与b-1的位与</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; ((n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.6 MB, 在所有 Java 提交中击败了28.30% 的用户</p><h3 id="3-返回一个数二进制中1的个数"><a href="#3-返回一个数二进制中1的个数" class="headerlink" title="3.返回一个数二进制中1的个数"></a>3.返回一个数二进制中1的个数</h3><p><strong>[第191题]</strong> 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><ul><li>示例 1：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</li><li>示例 2：<br>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</li><li>示例 3：<br>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有31位为 ‘1’。</li></ul><p>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例3中，输入表示有符号整数-3。</p><p><strong>方法一</strong></p><blockquote><p>这道题仍然是通过位运算来进行求解的非常典型的题目。掩码是指使用一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。</p><p>我们直接把目标数转化成二进制数，然后遍历每一位看看是不是1，如果是1就记录下来。</p><p>我们可以构造一个掩码来进行，其实就是弄个1出来，1的二进制是这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/32.jpg" alt><br>我们只需要让这个掩码每次向左移动一位，然后与目标值求“&amp;”，就可以判断目标值的当前位是不是1。比如目标值为21，21的二进制是这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/33.jpg" alt><br>然后每次移动掩码，来和当前位进行计算：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/34.jpg" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mask = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> (n &amp; mask) != <span class="number">0</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了75.02% 的Python3用户<br>内存消耗:13.4 MB,击败了26.44% 的Python3用户</p><p>注意：这里判断 n&amp;mask 的时候，千万不要错写成 (n&amp;mask) == 1，因为这里你对比的是十进制数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            count += n &amp; <span class="number">1</span>;    </span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">//无符号右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.7 MB, 在所有 Java 提交中击败了5.02% 的用户</p><p><strong>方法二</strong></p><blockquote><p>位运算小技巧: 对于任意一个数，将 n 和 n-1 进行 &amp; 运算，我们都可以把 n 中最低位的 1 变成 0</p><p>我们拿 11 举个例子：（注意最后一位1变成0的过程）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/35.jpg" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>)</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了75.02% 的Python3用户<br>内存消耗:13.6 MB,击败了5.40% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);    </span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了95.92% 的用户<br>内存消耗：35.1 MB, 在所有 Java 提交中击败了94.71% 的用户</p><p><strong>方法三：利用Python内置方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了75.02% 的Python3用户<br>内存消耗:13.6 MB,击败了5.40% 的Python3用户</p><h3 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="4.只出现一次的数字"></a>4.只出现一次的数字</h3><p><strong>[第136题]</strong> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><ul><li>示例 1:<br>输入: [2,2,1]<br>输出: 1</li><li>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4</li></ul><blockquote><p>对于任意两个数a和b，我们对其使用 “异或”操作，应该有以下性质：</p><p>任意一个数和0异或仍然为自己：a⊕0 = a</p><p>任意一个数和自己异或是0：a⊕a=0</p><p>异或操作满足交换律和结合律：a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</p><p><strong>因为其余元素均出现两次，所以根据异或操作的交换律和结合律对数组进行迭代，最终留下的就是只出现一次的数字</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            res ^= nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了46.94% 的Python3用户<br>内存消耗:15.1 MB,击败了34.55% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了99.75% 的用户</p><h3 id="5-只出现一次的数字Ⅱ"><a href="#5-只出现一次的数字Ⅱ" class="headerlink" title="5.只出现一次的数字Ⅱ"></a>5.只出现一次的数字Ⅱ</h3><p><strong>[第137题]</strong> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？</p><ul><li>示例 1:<br>输入: [2,2,3,2]<br>输出: 3</li><li>示例 2:<br>输入: [0,1,0,1,0,1,99]<br>输出: 99</li></ul><p><strong>方法一：HashMap求解</strong></p><blockquote><p>很简单就能想到，说白了就是<strong>统计每个元素出现的次数，最终再返回次数为1的元素</strong>。但是使用了额外空间。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                <span class="built_in">map</span>[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">map</span>[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了89.49% 的Python3用户<br>内存消耗:14.8 MB,击败了19.68% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) map.put(num, map.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：7 ms, 在所有 Java 提交中击败了9.09% 的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了55.72% 的用户</p><p><strong>方法二：数学方式</strong></p><blockquote><p>原理：[A,A,A,B,B,B,C,C,C] 和 [A,A,A,B,B,B,C]，差了两个C。即：3×(<em>a</em> <em>b</em> <em>c</em>)−(<em>a</em> <em>a</em> <em>a</em> <em>b</em> <em>b</em> <em>b</em> <em>c</em>)=2<em>c</em></p><p>也就是说，如果把<strong>原数组去重、再乘以3得到的值，刚好就是要找的元素的2倍</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>((<span class="built_in">sum</span>(<span class="built_in">set</span>(nums)) * <span class="number">3</span> - <span class="built_in">sum</span>(nums)) / <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了96.69% 的Python3用户<br>内存消耗:14.7 MB,击败了26.89% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; key = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            key.add(num);</span><br><span class="line">            sum1 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: key) sum2 += num;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((<span class="number">3</span> * sum2 - sum1) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了37.02% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了85.08% 的用户</p><p><strong>方法三：位运算</strong></p><blockquote><p>对于“每个其余元素，均出现了二次”之所以可以使用“<strong>异或</strong>”进行求解，原因是因为“异或”操作可以让两数相同归0。那对于其余元素出现三次的，是不是只要可以让其三者相同归0，就能达到我们的目的呢？</p><p>因为各语言中都没有这样一个现成的方法可以使用，所以我们需要构造一个。（想象一下，位运算也是造出来的对不对？）</p><p><strong>异或运算是不是可以理解为，其实就是二进制的加法，然后砍掉进位呢？砍掉进位的过程，是不是又可以理解为对 2 进行取模</strong>，也就是取余。到了这里，问题已经非常非常明确了。那我们要完成一个 a ? a ? a = 0 的运算，是不是其实就是让其二进制的每一位数都相加，最后再对3进行一个取模的过程呢？（一样，如果要定义一个 a ? a ? a ? a = 0 的运算，那就最后对4进行取模就可以了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># python中int为变长的，所以定义32位的列表</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="comment"># 每一位都对对应位上的所有数做和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 判断该数是否为负数</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                    j = j &amp; <span class="number">0xffffffff</span></span><br><span class="line">                <span class="comment"># 记录该位1的个数</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                    count[i] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最终将抵消后剩余的1放到对应的位数上</span></span><br><span class="line">            <span class="keyword">if</span> count[i] % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="comment"># 判断结果正负</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(res ^ <span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure><p>执行耗时:124 ms,击败了13.36% 的Python3用户<br>内存消耗:14.7 MB,击败了28.80% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((num &gt;&gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) count[i] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[i] % <span class="number">3</span> == <span class="number">1</span>) res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了37.02% 的用户<br>内存消耗：38.5 MB, 在所有 Java 提交中击败了9.53% 的用户</p><p>在上面的代码中，<strong>我们记录每一位数出现的次数</strong>。但是缺点是，我们记录了32位。那如果我们可以同时对所有位进行计数，是不是就可以简化过程。因为我们的目的是把每一位与3取模进行运算，是不是就可以理解为其实是一个<strong>三进制</strong>。所以我们就只有3个状态，00 - 01 - 10，所以我们采用 a 和 b 来记录状态。其中的状态转移过程如下：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/36.jpg" alt></p><p>这里 a‘ 和 b’ 的意思代表着 a 和 b 下一次的状态。next 代表着下一个 bit 位对应的值。</p><p>写出关系式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = (b ^ next) &amp; ~a;</span><br><span class="line">a = (a ^ next) &amp; ~b; #注意这里的b已经变了，是上式求得的b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> nums:</span><br><span class="line">            b = (b ^ <span class="built_in">next</span>) &amp; ~a</span><br><span class="line">            a = (a ^ <span class="built_in">next</span>) &amp; ~b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了96.69% 的Python3用户<br>内存消耗:14.6 MB,击败了38.94% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next: nums)&#123;</span><br><span class="line">            b = (b ^ next) &amp; ~a;</span><br><span class="line">            a = (a ^ next) &amp; ~b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了58.04% 的用户</p><h3 id="6-缺失数字"><a href="#6-缺失数字" class="headerlink" title="6.缺失数字"></a>6.缺失数字</h3><p><strong>[第268题]</strong> 给定一个包含[0, n]中n个数的数组nums ，找出[0, n]这个范围内没有出现在数组中的那个数。进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p><ul><li>示例 1：<br>输入：nums = [3,0,1]<br>输出：2<br>解释：n = 3，因为有3个数字，所以所有的数字都在范围[0,3]内。2是丢失的数字，因为它没有出现在nums中。</li><li>示例 2：<br>输入：nums = [0,1]<br>输出：2<br>解释：n = 2，因为有2个数字，所以所有的数字都在范围[0,2]内。2是丢失的数字，因为它没有出现在nums中。</li><li>示例 3：<br>输入：nums = [9,6,4,2,3,5,7,0,1]<br>输出：8<br>解释：n = 9，因为有9个数字，所以所有的数字都在范围[0,9]内。8是丢失的数字，因为它没有出现在nums中。</li><li>示例 4：<br>输入：nums = [0]<br>输出：1<br>解释：n = 1，因为有1个数字，所以所有的数字都在范围[0,1]内。1是丢失的数字，因为它没有出现在nums中。</li></ul><p><strong>方法一：数学方式</strong></p><blockquote><p>首先求出数组的和，然后再求出前n+1项之和（从0到n），最终求差值，即为缺失的值！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)) - <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了98.84% 的Python3用户<br>内存消耗:14.3 MB,击败了81.49% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;= nums.length; i++) sum1 += i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) sum2 += num;</span><br><span class="line">        <span class="keyword">return</span> sum1 - sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了75.78% 的用户</p><p><strong>方法二：位运算</strong></p><blockquote><p>利用“<strong>两个相同的数，使用异或可以相消除</strong>”的原理</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            result ^= nums[i] ^ i</span><br><span class="line">        <span class="keyword">return</span> result ^ <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>执行耗时:60 ms,击败了40.05% 的Python3用户<br>内存消耗:14.6 MB,击败了17.63% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) res ^= nums[i] ^ i;</span><br><span class="line">        <span class="keyword">return</span> res ^= nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了91.43% 的用户</p><h2 id="二分法系列"><a href="#二分法系列" class="headerlink" title="二分法系列"></a>二分法系列</h2><h3 id="1-阿珂喜欢吃香蕉"><a href="#1-阿珂喜欢吃香蕉" class="headerlink" title="1.阿珂喜欢吃香蕉"></a>1.阿珂喜欢吃香蕉</h3><div class="table-container"><table><thead><tr><th>第875题：阿珂喜欢吃香蕉</th></tr></thead><tbody><tr><td>这里总共有 N 堆香蕉，第 i 堆中有piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 阿珂可以决定她吃香蕉的速度 K （单位：根/小时），每个小时，她将会选择一堆香蕉，从中吃掉 K 根。</td></tr></tbody></table></div><p>如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure><blockquote><p>二分查找是计算机科学中最基本、最有用的算法之一。它描述了<strong>在有序集合中搜索特定值的过程</strong>。一般二分查找由以下几个术语构成：</p><ul><li>目标 Target —— 你要查找的值</li><li>索引 Index —— 你要查找的当前位置</li><li>左、右指示符 Left，Right —— 我们用来维持查找空间的指标</li><li>中间指示符 Mid —— 我们用来应用条件来确定我们应该向左查找还是向右查找的索引</li></ul><p>在最简单的形式中，二分查找对具有指定左索引和右索引的<strong>连续序列</strong>进行操作。我们也称之为<strong>查找空间</strong>。二分查找维护查找空间的左、右和中间指示符，并比较查找目标；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。</p><p>总结一下一般实现的几个条件：</p><ul><li><strong>初始条件：left = 0, right = length-1</strong></li><li><strong>终止：left &gt; right</strong></li><li><strong>向左查找：right = mid-1</strong></li><li><strong>向右查找：left = mid +1</strong></li></ul><p>绝大部分 <strong>「在递增递减区间中搜索目标值」</strong> 的问题，都可以转化为二分查找问题。并且，二分查找的题目，基本逃不出三种：找特定值，找大于特定值的元素（上界），找小于特定值的元素（下界）。</p><p>将上面的思想代入到本题，我们要找 “<strong>阿珂在 H 小时吃掉所有香蕉的最小速度 K</strong>”。那最笨的就是阿珂吃的特别慢，每小时只吃掉 1 根香蕉，然后我们逐渐递增阿珂吃香蕉的速度到 i，刚好满足在 H 小时可以吃掉所有香蕉，此时 i 就是我们要找的最小速度。当然，我们没有这么笨，所以可以想到使用二分的思想来进行优化。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], H: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 最小速度</span></span><br><span class="line">        low = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最大的速度，当然等于吃掉最大一堆的香蕉，毕竟一小时只能吃一堆，再大也没有意义</span></span><br><span class="line">        high = <span class="built_in">max</span>(piles)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canEat</span>(<span class="params">piles, speed, H</span>):</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">                <span class="comment"># 向上取整</span></span><br><span class="line">                <span class="keyword">if</span> pile % speed &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">sum</span> += pile // speed + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">sum</span> += pile // speed</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span> &gt; H</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="comment"># 中间速度</span></span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果超时就往大的方向找，否则往小的方向找</span></span><br><span class="line">            <span class="keyword">if</span> canEat(piles, mid, H):</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><p>执行耗时:372 ms,击败了59.53% 的Python3用户<br>内存消耗:14.7 MB,击败了9.52% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile: piles) high = pile &gt; high? pile: high;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(canEat(piles, mid, h)) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canEat</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">double</span> speed, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile: piles)&#123;</span><br><span class="line">            sum += Math.ceil(pile / speed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：43 ms, 在所有 Java 提交中击败了10.82% 的用户<br>内存消耗：39.5 MB, 在所有 Java 提交中击败了80.42% 的用户</p><h3 id="2-x的平方根"><a href="#2-x的平方根" class="headerlink" title="2.x的平方根"></a>2.x的平方根</h3><div class="table-container"><table><thead><tr><th>第69题：x的平方根</th></tr></thead><tbody><tr><td>计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</td></tr></tbody></table></div><blockquote><p><strong>整数平方根</strong>一定小于等于 x/2 。即有 0 &lt; 整数平方根 &lt;= x/2。所以我们的问题转化为在 [0,x/2] 中找一个<strong>特定值</strong>，满足二分查找的条件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = x // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># +1防止陷入死循环</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> &lt;= x:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了92.37% 的Python3用户<br>内存消耗:13.6 MB,击败了5.34% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = x / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x / mid &gt; mid) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x / l &lt; l? l-<span class="number">1</span>: l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了46.99% 的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了95.82% 的用户</p><blockquote><p>牛顿迭代法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">long</span> a = x;</span><br><span class="line">        <span class="keyword">while</span>(x / a &lt; a)&#123;</span><br><span class="line">            a = (a + x / a) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了46.99% 的用户<br>内存消耗：35.6 MB, 在所有 Java 提交中击败了48.99% 的用户</p><h3 id="3-第一个错误的版本"><a href="#3-第一个错误的版本" class="headerlink" title="3.第一个错误的版本"></a>3.第一个错误的版本</h3><div class="table-container"><table><thead><tr><th>第278题：第一个错误的版本</th></tr></thead><tbody><tr><td>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</td></tr></tbody></table></div><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了5.21% 的Python3用户<br>内存消耗:13.5 MB,击败了6.31% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：18 ms, 在所有 Java 提交中击败了29.41% 的用户<br>内存消耗：35.1 MB, 在所有 Java 提交中击败了68.44% 的用户</p><h3 id="4-旋转排序数组中的最小值I"><a href="#4-旋转排序数组中的最小值I" class="headerlink" title="4.旋转排序数组中的最小值I"></a>4.旋转排序数组中的最小值I</h3><div class="table-container"><table><thead><tr><th>第153题：旋转排序数组最小值Ⅰ</th></tr></thead><tbody><tr><td>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><blockquote><p>无论怎么旋转，我们都可以得到一个结论，首元素 &gt; 尾元素</p><p>并且我们已知了首元素值总是大于尾元素，那我们只要找到将其一分为二的那个点（该点左侧的元素都大于首元素，该点右侧的元素都小于首元素），是不是就可以对应找到数组中的最小值。</p><p>然后我们通过二分来进行查找，先找到中间节点mid，如果中间元素小于尾元素，我们就把mid向左移动。</p><p>如果中间元素大于尾元素，我们就把mid向右移动。</p><p>之所以跟尾元素比，是因为测试用例:[11,13,15,17]，算他原地翻转，其结果为11，若跟首元素比，则结果为17导致出错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[-<span class="number">1</span>]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><p>执行耗时:28 ms,击败了99.24% 的Python3用户<br>内存消耗:13.7 MB,击败了8.37% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.8 MB, 在所有 Java 提交中击败了78.33% 的用户</p><h3 id="5-旋转排序数组中的最小值II"><a href="#5-旋转排序数组中的最小值II" class="headerlink" title="5.旋转排序数组中的最小值II"></a>5.旋转排序数组中的最小值II</h3><div class="table-container"><table><thead><tr><th>第154题：旋转排序数组最小值Ⅱ</th></tr></thead><tbody><tr><td>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。 注意数组中可能存在重复的元素。</td></tr></tbody></table></div><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a target="_blank" rel="noopener" href="https://www.geekxh.com/1.9.二分法系列/1.9/904.html">旋转排序数组中的最小值(153)</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><blockquote><p>相对比昨天题目而言，其实只是多了<strong>nums[mid] 等于 nums[right] 时的额外处理</strong>。</p><p>可以看到在 nums[mid] 等于 nums[right] 时的情况下，我们只多了一个 right-1 的操作。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/64.png" alt></p><p>因为 mid 和 right 相等时，最小值既可能在左边，又可能在右边，所以此时自然二分思想作废，咱们就砍掉一个右边界。说白了，就是<strong>让子弹再飞一会儿</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><p>执行耗时:48 ms,击败了23.32% 的Python3用户<br>内存消耗:13.7 MB,击败了27.84% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了27.61% 的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了73.68% 的用户</p><h3 id="6-供暖器"><a href="#6-供暖器" class="headerlink" title="6.供暖器"></a>6.供暖器</h3><div class="table-container"><table><thead><tr><th>第475题：供暖器</th></tr></thead><tbody><tr><td>冬季已经来临。你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</td></tr></tbody></table></div><p><strong>说明:</strong></p><ul><li>给出的房屋和供暖器的数目是非负数且不会超过 25000。</li><li>给出的房屋和供暖器的位置均是非负数且不会超过10^9。</li><li>只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。</li><li>所有供暖器都遵循你的半径标准，加热的半径也一样。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3],[2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4],[1,4]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><blockquote><p>我们要对任意一个房屋供暖，要么用前面的暖气，要么用后面的暖气，两者之间取最近的，这就是距离。同时，如果要覆盖到所有的房屋，我们要选择上述距离中最大的一段，这就是最小的加热半径。</p><p>第一层：遍历所有的房子，第二层：遍历加热器，找出距离该房子的最小距离。但是我们其实可以通过二分搜索来优化这个过程。</p></blockquote><p><strong>方法一：暴力法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRadius</span>(<span class="params">self, houses: <span class="type">List</span>[<span class="built_in">int</span>], heaters: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        houses.sort()</span><br><span class="line">        heaters.sort()</span><br><span class="line">        <span class="comment"># 防止供暖器只有一个的情况</span></span><br><span class="line">        heaters = [<span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)] + heaters + [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> house <span class="keyword">in</span> houses:</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(heaters) - <span class="number">1</span> <span class="keyword">and</span> house &gt; heaters[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(heaters[i] - house, house - heaters[i - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:140 ms,击败了92.39% 的Python3用户<br>内存消耗:16.1 MB,击败了85.24% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="keyword">int</span>[] nheaters = <span class="keyword">new</span> <span class="keyword">int</span>[heaters.length+<span class="number">2</span>];</span><br><span class="line">        nheaters[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        nheaters[nheaters.length-<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        System.arraycopy(heaters, <span class="number">0</span>, nheaters, <span class="number">1</span>, heaters.length);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> house: houses)&#123;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; nheaters.length - <span class="number">1</span> &amp;&amp; house &gt; nheaters[index]) index++;</span><br><span class="line">            res = Math.max(res, Math.min(nheaters[index] - house, house - nheaters[index-<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：9 ms, 在所有 Java 提交中击败了89.71% 的用户<br>内存消耗：41.2 MB, 在所有 Java 提交中击败了92.17% 的用户</p><p><strong>方法二：二分法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRadius</span>(<span class="params">self, houses: <span class="type">List</span>[<span class="built_in">int</span>], heaters: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        houses.sort()</span><br><span class="line">        <span class="comment"># 找到每个房屋位置所需要的最小半径的最大值</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 防止供暖器只有一个的情况</span></span><br><span class="line">        heaters = [-<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] + <span class="built_in">sorted</span>(heaters) + [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]</span><br><span class="line">        <span class="comment"># 每个屋子都要被覆盖到</span></span><br><span class="line">        <span class="keyword">for</span> house <span class="keyword">in</span> houses:</span><br><span class="line">            <span class="comment"># 每个屋子都要找到1个离他最近的heater，这里用二分法改进</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(heaters)-<span class="number">1</span></span><br><span class="line">            <span class="comment"># 找不小于house的第一个heater值</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            	<span class="comment"># 应该写mid=left+((right-left)&gt;&gt;1)，因为位运算的优先级不如加法运算</span></span><br><span class="line">                mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> house &gt; heaters[mid]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="comment"># house夹在heaters[left-1] heater[left]中间</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(house - heaters[left - <span class="number">1</span>], heaters[left] - house))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:252 ms,击败了86.09% 的Python3用户<br>内存消耗:15.9 MB,击败了93.07% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="keyword">int</span>[] nheaters = <span class="keyword">new</span> <span class="keyword">int</span>[heaters.length+<span class="number">2</span>];</span><br><span class="line">        nheaters[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        nheaters[nheaters.length-<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        System.arraycopy(heaters, <span class="number">0</span>, nheaters, <span class="number">1</span>, heaters.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> house: houses)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = nheaters.length;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(house &gt; nheaters[mid]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, Math.min(nheaters[left] - house, house - nheaters[left-<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：23 ms, 在所有 Java 提交中击败了39.37% 的用户<br>内存消耗：41.3 MB, 在所有 Java 提交中击败了84.79% 的用户</p><h2 id="其他补充题目"><a href="#其他补充题目" class="headerlink" title="其他补充题目"></a>其他补充题目</h2><h3 id="1-螺旋矩阵I"><a href="#1-螺旋矩阵I" class="headerlink" title="1.螺旋矩阵I"></a>1.螺旋矩阵I</h3><div class="table-container"><table><thead><tr><th>第54题：螺旋矩阵</th></tr></thead><tbody><tr><td>定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><blockquote><p>只有我们能找到边界（边界包括：1、数组的边界 2、已经访问过的元素），才可以通过“<strong>右，下，左，上</strong>”的方向来进行移动。同时，每一次<strong>碰壁</strong>，就可以调整到下一个方向。</p><p>我们首先对其设置好四个边界:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">up := 0</span><br><span class="line">down := len(matrix) - 1</span><br><span class="line">left := 0</span><br><span class="line">right := len(matrix[0]) - 1</span><br></pre></td></tr></table></figure><p>同时，我们定义x和y，来代表行和列。</p><p>然后我们从第一个元素开始行军（y=left），完成第一行的遍历，直到碰壁。（y&lt;=right）</p><p>下面关键的一步来了，<strong>因为第一行已经走过了，我们将上界下调</strong> <strong>（up++）</strong>，同时转弯向下走。</p><p>直到碰到底部时（x&lt;=down），我们将<strong>右界左调（right—）</strong>，转弯向左走。</p><p>后面向左和向上，分别完成<strong>下界上调（down—和左界右调（left++）</strong>。</p><p>最后，对剩下的矩阵重复整个过程，直到上下、左右的壁与壁碰在一起 <strong>（up &lt;= down &amp;&amp; left &lt;= right，这是避免碰壁的条件）</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">                    result.append(matrix[x][y])</span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">                    result.append(matrix[x][y])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">                    result.append(matrix[x][y])</span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(down, up-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">                    result.append(matrix[x][y])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了60.32% 的Python3用户<br>内存消耗:13.3 MB,击败了73.96% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, up = <span class="number">0</span>, down = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; up &lt;= down)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = left; y &lt;= right; y++) res.add(matrix[up][y]);</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = up; x &lt;= down; x++) res.add(matrix[x][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = right; y &gt;= left; y--) res.add(matrix[down][y]);</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = down; x &gt;= up; x--) res.add(matrix[x][left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.5 MB, 在所有 Java 提交中击败了76.13% 的用户</p><h3 id="2-只有两个键的键盘"><a href="#2-只有两个键的键盘" class="headerlink" title="2.只有两个键的键盘"></a>2.只有两个键的键盘</h3><div class="table-container"><table><thead><tr><th>第650题：只有两个键的键盘</th></tr></thead><tbody><tr><td>最初在一个记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。</td></tr></tbody></table></div><p>给定一个数字 n 。你需要使用<strong>最少的操作次数</strong>，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &#x27;A&#x27;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>n 的取值范围是 [1, 1000] 。</p><blockquote><p>本题的思路，在于<strong>想明白复制和粘贴过程中的规律，找到如何组成N个A的最小操作数。</strong></p><p>我们从最简单的开始分析，假如我们给定数字为1，那啥也不用做，因为面板上本来就有一个A。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/65.png" alt></p><p>假如我们给定数字为2，那我们需要做C-P，共计2次操作来得到。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/66.png" alt></p><p>假如我们给定数字为3，那我们需要做C-P-P，共计3次操作来得到。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/67.png" alt></p><p>假如我们给定数字为4，我们发现好像变得不一样了。因为我们有两种方法都可以得到目标。（C-P-C-P）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/68.png" alt></p><p>或者（C-P-P-P）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/69.png" alt></p><p>但是需要的步骤还是一样。</p><p>好了，到这里为止，STOP！通过上面的分析，我们至少可以观察出：<strong>如果 i 为质数，那么 i 是多少，就需要粘贴多少次</strong>。即：素数次数为本身的结论。如 两个A = 2，三个A = 3，五个A = 5。</p><p>那对于合数又该如何分析呢？（自然数中除能被1和本身整除外,还能被其他的数整除的数）这里我们直接给出答案：合数的次数为<strong>将其分解质因数的操作次数的和。</strong> 解释一下，这是个啥意思？举个例子：</p><p>比如30，可以分解为：3*2*5。什么意思呢？我们演示一遍：首先复制1，进行2次粘贴得到3。然后复制3，进行1次粘贴得到6。然后复制6，进行4次粘贴得到30。总共需要（CPPCPCPPPP）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/70.png" alt></p><blockquote><p>注意：这里由于每一次都需要进行一次复制，<strong>所以直接就等于分解质因数的操作次数的和</strong>。并且分解的顺序，不会影响到结果。</p></blockquote><p>综合上面的分析，我们得出分析结果：</p><p>1、质数次数为其本身。</p><p>2、合数次数为将其分解到<strong>所有不能再分解的质数的操作次数的和</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                res += i</span><br><span class="line">                n /= i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了91.24% 的Python3用户<br>内存消耗:13.6 MB,击败了19.97% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += i;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.4 MB, 在所有 Java 提交中击败了43.12% 的用户</p><h3 id="3-24点游戏"><a href="#3-24点游戏" class="headerlink" title="3.24点游戏"></a>3.24点游戏</h3><div class="table-container"><table><thead><tr><th>第679题：24点游戏</th></tr></thead><tbody><tr><td>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通 *，/，+，-，(，) 的运算得到 24 。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) = 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>注意:</p><p>​ 1、除法<strong>运算符 / 表示实数除法，而不是整数除法</strong>。例如 4 / (1 - 2/3) = 12 。</p><p>​ 2、每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。</p><p>​ 3、你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</p><blockquote><p>拿到题目，第一反应就可以想到<strong>暴力求解。如果我们要判断给出的4张牌是否可以通过组合得到24，那我们只需找出所有的可组合的方式进行遍历。</strong></p><p>4个数字，3个操作符，外加括号，基本目测就能想到组合数不会大到超出边界。所以，我们只要<strong>把他们统统列出来，不就可以进行求解了吗</strong>?</p><p>但是这个方法写的正确吗？其实不对！因为在计算机中，实数在计算和存储过程中会有一些微小的误差，<strong>对于一些与零作比较的语句来说，有时会因误差而导致原本是等于零但结果却小于或大于零之类的情况发生</strong>，所以常用一个很小的数 <strong>1e-6</strong> 代替 0，进行判读！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        op = [<span class="keyword">lambda</span> x, y: x + y, <span class="keyword">lambda</span> x, y: x - y, <span class="keyword">lambda</span> x, y: x * y,</span><br><span class="line">              <span class="keyword">lambda</span> x, y: x / y <span class="keyword">if</span> y != <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]</span><br><span class="line">        <span class="comment"># 返回可迭代对象的所有数学全排列方式</span></span><br><span class="line">        <span class="keyword">for</span> a, b, c, d <span class="keyword">in</span> itertools.permutations(nums):</span><br><span class="line">            <span class="comment"># product(list1, list2) 依次取出list1中的每1个元素，与list2中的每1个元素，组成元组，</span></span><br><span class="line">            <span class="comment"># 然后，将所有的元组组成一个列表，返回。</span></span><br><span class="line">            <span class="keyword">for</span> f, g, h <span class="keyword">in</span> itertools.product(op, repeat=<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> -<span class="number">1e-6</span> &lt; f(g(h(a, b), c), d) - <span class="number">24</span> &lt; <span class="number">1e-6</span> \</span><br><span class="line">                        <span class="keyword">or</span> -<span class="number">1e-6</span> &lt; f(g(a, h(b, c)), d) - <span class="number">24</span> &lt; <span class="number">1e-6</span> \</span><br><span class="line">                        <span class="keyword">or</span> -<span class="number">1e-6</span> &lt; f(g(a, b), h(c, d)) - <span class="number">24</span> &lt; <span class="number">1e-6</span> \</span><br><span class="line">                        <span class="keyword">or</span> -<span class="number">1e-6</span> &lt; f(a, g(h(b, c), d)) - <span class="number">24</span> &lt; <span class="number">1e-6</span> \</span><br><span class="line">                        <span class="keyword">or</span> -<span class="number">1e-6</span> &lt; f(a, g(b, h(c, d))) - <span class="number">24</span> &lt; <span class="number">1e-6</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>执行耗时:68 ms,击败了92.38% 的Python3用户<br>内存消耗:13.3 MB,击败了68.61% 的Python3用户</p><blockquote><p>可以通过回溯的方法遍历所有不同的可能性。具体做法是，使用一个列表存储目前的全部数字，每次从列表中选出 2 个数字，再选择一种运算操作，用计算得到的结果取代选出的 2 个数字，这样列表中的数字就减少了 1 个。重复上述步骤，直到列表中只剩下 1 个数字，这个数字就是一种可能性的结果，如果结果等于 24，则说明可以通过运算得到 24。如果所有的可能性的结果都不等于 24，则说明无法通过运算得到 24。</p><p>实现时，有一些细节需要注意。</p><ul><li><p>除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 24 时应考虑精度误差，这道题中，误差小于 10−6 可以认为是相等。</p></li><li><p>进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 0 时应考虑精度误差，这道题中，当一个数字的绝对值小于 10−6 时，可以认为该数字等于 0。</p></li></ul><p>还有一个可以优化的点。</p><ul><li>加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 2 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">//误差</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="comment">//四种运算</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//列表为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//组合的结果是否为target</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>) <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="comment">//从当前列表中选出两个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    <span class="comment">//新建列表</span></span><br><span class="line">                    List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">                    <span class="comment">//选出的两个数外的数，仍存入列表</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (k != i &amp;&amp; k != j) list2.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//选择其中一种运算</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="comment">//加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的数字不需要考虑不同的顺序</span></span><br><span class="line">                        <span class="comment">//在遇到第二种顺序时可以不进行运算，直接跳过</span></span><br><span class="line">                        <span class="keyword">if</span> (k &lt; <span class="number">2</span> &amp;&amp; i &gt; j) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将两个数的运算结果存入新数组</span></span><br><span class="line">                        <span class="keyword">if</span> (k == ADD) &#123;</span><br><span class="line">                            list2.add(list.get(i) + list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == MULTIPLY) &#123;</span><br><span class="line">                            list2.add(list.get(i) * list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == SUBTRACT) &#123;</span><br><span class="line">                            list2.add(list.get(i) - list.get(j));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == DIVIDE) &#123;</span><br><span class="line">                            <span class="comment">//排除除数为0的情况</span></span><br><span class="line">                            <span class="keyword">if</span> (Math.abs(list.get(j)) &lt; EPSILON) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                list2.add(list.get(i) / list.get(j));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//递归，从新数组中继续选取两个数</span></span><br><span class="line">                        <span class="keyword">if</span> (solve(list2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//回溯</span></span><br><span class="line">                        list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了67.43% 的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了62.84% 的用户</p><h3 id="4-飞机座位分配概率"><a href="#4-飞机座位分配概率" class="headerlink" title="4.飞机座位分配概率"></a>4.飞机座位分配概率</h3><div class="table-container"><table><thead><tr><th>第1227题：飞机座位分配概率</th></tr></thead><tbody><tr><td>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</td></tr></tbody></table></div><p>剩下的乘客将会：</p><ul><li>如果他们自己的座位还空着，就坐到自己的座位上，</li><li>当他们自己的座位被占用时，随机选择其他座位</li></ul><p>第 n 位乘客坐在自己的座位上的概率是多少？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br></pre></td></tr></table></figure><blockquote><p>一个位置一个人，一屁股蹲下，概率100%，这没啥可说的。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/71.png" alt></p><p>两个位置两个人，第一个人已经坐下，要么坐对了，要么坐错了。所以第二个人坐在自己位置上的概率是50%。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/72.png" alt></p><p>重点来了，三个位置三个人，第一个一屁股坐下，有三种坐法。<img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/73.jpeg" alt></p><p>如果恰好<strong>第一个人坐到了自己的座位</strong>上（1/3），那这种情况下，第二个人也就可以直接坐在自己的座位上，第三个人一样。所以此时第三人坐在自己座位上的可能性是 100%。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/74.png" alt></p><p>如果<strong>第一个人占掉了第二个人的位置（1/3）。</strong> 此时第二人上来之后，要么坐在第一人的位置上，要么坐在第三人的位置上。（1/2）所以，在这种情况下，第三人的座位被占的可能性是 1/3*1/2=1/6。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/75.png" alt></p><p>那假如第一人直接一屁股坐在第三人的座位上，此时第三人的座位被占的可能性就是第一人选择第三人座位的可能性。（1/3）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/76.png" alt></p><p>所以，如果三个座位三个人，第三个人坐到自己位置上的概率就是：1/3 <em>1/1 + 1/3</em> 1/2 + 1/3 * 0 = 1/2</p><p>而对于 n&gt;3 的情况，我们参照 3 个座位时进行分析：</p><ul><li>如果第1个乘客选择第1个座位，那么第n个人选择到第n个座位的可能性就是100%。(1/n)</li><li>如果第1个乘客选择了第n个座位，那么第n个人选择第n个座位的可能性就是0。(0)</li><li><strong>而对于第 1 个乘客选择除了第一个和第 n 个座位之外的座位k (1&lt;k&lt;n)，就会导致有可能出现，前 n-1 位乘客占第 n 位乘客的概率出现。</strong></li></ul><p>第一二种情况都好说，对于第三种情况。因为此时第k个座位被占用，于第 k 个乘客而言，他又会面临和第一个乘客一样的选择。<strong>相当于乘客1将问题转移到了第k个乘客身上，等同于本次选择无效！</strong>且这个过程会一直持续到没有该选项<strong>。</strong>于是乎，对于第 n 个人，他最后将只有两个选项：1、自己的 2、第一个人。<strong>所以对于n&gt;=3 的情况，等同于 n=2，全部的概率都为 1/2</strong>。</p><p>如果还是不能理解的小伙伴，可以这样想。<strong>登机时座位被占的乘客 ，其实相当于和上一位坐错的乘客交换了身份</strong>。直到完成终止条件（坐对位置 或者 坐到最后一个位置），否则该交换将一直进行下去。所以第n位乘客，坐到第n个位置，自然还是 1/2。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了46.71% 的Python3用户<br>内存消耗:13.5 MB,击败了37.32% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了96.75% 的用户</p><h3 id="5-水分子的产生"><a href="#5-水分子的产生" class="headerlink" title="5.水分子的产生"></a>5.水分子的产生</h3><div class="table-container"><table><thead><tr><th>第1117题：水分子的产生</th></tr></thead><tbody><tr><td>现在有两种线程，氢 oxygen 和氧 hydrogen，你的目标是组织这两种线程来产生水分子。</td></tr></tbody></table></div><p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p><p>氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。</p><p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p><p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p><p>换句话说:</p><p>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</p><p>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</p><p>书写满足这些限制条件的氢、氧线程同步代码。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;HOH&quot;</span><br><span class="line">输出: &quot;HHO&quot;</span><br><span class="line">解释: &quot;HOH&quot; 和 &quot;OHH&quot; 依然都是有效解。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;OOHHHH&quot;</span><br><span class="line">输出: &quot;HHOHHO&quot;</span><br><span class="line">解释: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; 和 &quot;OHHOHH&quot; 依然都是有效解。</span><br></pre></td></tr></table></figure><p>限制条件:</p><ul><li>输入字符串的总长将会是 3n, 1 ≤ n ≤ 50；</li><li>输入字符串中的 “H” 总数将会是 2n；</li><li>输入字符串中的 “O” 总数将会是 n。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.h = Semaphore(<span class="number">2</span>)</span><br><span class="line">        self.o = Semaphore(<span class="number">0</span>)</span><br><span class="line">        self.h_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hydrogen</span>(<span class="params">self, releaseHydrogen: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.h.acquire(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen()</span><br><span class="line">        self.h_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.h_num == <span class="number">2</span>:</span><br><span class="line">            self.h_num = <span class="number">0</span></span><br><span class="line">            self.o.release(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oxygen</span>(<span class="params">self, releaseOxygen: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.o.acquire(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span></span><br><span class="line">        releaseOxygen()</span><br><span class="line">        self.h.release(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>执行用时：40 ms, 在所有 Python3 提交中击败了92.16% 的用户<br>内存消耗：15.4 MB, 在所有 Python3 提交中击败了81.37% 的用户</p><blockquote><p>Semaphore是 synchronized 的加强版，作用是<strong>控制线程的并发数量</strong>。可以通过 acquire 和 release 来进行类似 lock 和 unlock 的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求一个信号量，这时候信号量个数-1，当减少到0的时候，下一次acquire不会再执行，只有当执行一个release()的时候，信号量不为0的时候才可以继续执行acquire</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放一个信号量，这时候信号量个数+1，</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>h每获取一次释放一个o许可，o每次获取两个许可（即2次h后执行一次o）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore h = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore o = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		h.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// releaseHydrogen.run() outputs &quot;H&quot;. Do not change or remove this line.</span></span><br><span class="line">        releaseHydrogen.run();</span><br><span class="line">        o.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        o.acquire(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// releaseOxygen.run() outputs &quot;O&quot;. Do not change or remove this line.</span></span><br><span class="line">		releaseOxygen.run();</span><br><span class="line">        h.release(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：19 ms, 在所有 Java 提交中击败了78.17% 的用户<br>内存消耗：39.9 MB, 在所有 Java 提交中击败了87.10% 的用户</p><h3 id="6-救生艇"><a href="#6-救生艇" class="headerlink" title="6.救生艇"></a>6.救生艇</h3><div class="table-container"><table><thead><tr><th>第881题：救生艇</th></tr></thead><tbody><tr><td>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</td></tr></tbody></table></div><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [3,2,2,1], limit = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 艘船分别载 (1, 2), (2) 和 (3)</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [3,5,3,4], limit = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：4 艘船分别载 (3), (3), (4), (5)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ul><blockquote><p>这不是一道算法题，这是一个脑筋急转弯。</p><p>一个船最多可以装两个人，并且不能把船压垮。同时要求把这些人可以统统装下的最小船数。用脚趾头也可以想到，我们需要<strong>尽最大努力的去维持一个床上得有两个人</strong>。。哦，不，船上。这是什么思想？Bingo，贪心。</p><p>思路很简单：</p><ol><li>我们首先需要让这些人<strong>根据体重进行排序。</strong></li><li>同时<strong>维护两个指针，每次让最重的一名上船，同时让最轻的也上船</strong>。（因为最重的要么和最轻的一起上船。要么就无法配对，只能自己占用一艘船的资源）</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        people.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(people) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> people[i] + people[j] &lt;= limit:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>执行耗时:504 ms,击败了97.01% 的Python3用户<br>内存消耗:20.3 MB,击败了29.93% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="keyword">int</span>[] people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(people);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = people.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(people[l] + people[r] &lt;= limit) l++;</span><br><span class="line">            r--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：17 ms, 在所有 Java 提交中击败了96.78% 的用户<br>内存消耗：47.2 MB, 在所有 Java 提交中击败了77.37% 的用户</p><h3 id="7-25匹马的经典问题"><a href="#7-25匹马的经典问题" class="headerlink" title="7.25匹马的经典问题"></a>7.25匹马的经典问题</h3><div class="table-container"><table><thead><tr><th>25匹马的问题</th></tr></thead><tbody><tr><td>有一个赛场上共有25匹马，赛场有5个跑道，不使用计时器进行比赛（也就是每次比赛只能得到本次的比赛的顺序）</td></tr></tbody></table></div><p>试问最少比多少场才能选出最快的三匹马？并给出分析过程！</p><blockquote><p>分析过程：</p><ul><li><p>5次：首先我们把25匹马分成5组（A、B、C、D、E），跑上五次，得到每组的第一名。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/77.png" alt></p></li><li><p>1次：然后我们让这5个第一名跑上一次，得到其中的前三名。<strong>注意：这里就可以得到所有马中跑的最快的第一名A1了。并且，D1和E1所在的组可以直接淘汰。第二名和第三名一定不会在其中产生！</strong></p></li></ul><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/78.png" alt></p><ul><li><p>1次：因为我们已经跑出了第一名，所以A1不需要再参加比赛，同时，D1和E1所在的组已经淘汰。C1作为第三组的第一名，C组不会有跑的比C1快的。而B2有可能是比C1跑的快的第三名。同理，A2和A3也有可能是比B1和B2跑的快的。所以第7次比赛，我们让<strong>A2，A3，B1，B2，C1</strong>来一起完成。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/79.png" alt></p></li></ul><p>最终，我们<strong>通过7次比赛</strong>，得到25匹马中的前三名。</p></blockquote><p><strong>升级版本</strong></p><p>还是25匹马，如果我们要找到其中跑的最快的<strong>前五名</strong>，最少需要比赛几次呢？（这里我想说一下，我看到<strong>网上有不少地方把这个题讲错了</strong>，所以不会的同学建议还是认真看一看）</p><blockquote><p>在上面的的分析中，我们已经明确了第一名。<strong>但是第二名和第三名，是可以在A2-A3-B1-B2-C1中产生的</strong>，我们需要分别进行讨论。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/80.png" alt></p><ul><li>假若二三名分别为：A2，A3</li></ul><p>对于这种情况，<strong>第四名可能是A4</strong>，此时第五名是A5或者B1。<strong>第四名也可能是B1</strong>，此时第五名是B2或者C1。所以我们只需要让［A4，B1，A5，B2，C1］参加一次比赛，就可以得到前五名。</p><ul><li>假若二三名分别为：A2，B1</li></ul><p>对于这种情况，第四名可能是A3、B2、C1。<strong>假设第4名为A3</strong>，第5名可能为A4、B2、C1。<strong>假设第4名为B2</strong>，第5名可能为A3、B3、C1。<strong>假设第4名为C1</strong>，第5名可能为A3、B2、C2、D1。此时我们需要至少两次比赛，才能在［A3，A4，B2，B3，C1，C2，D1］中找到第四名和第五名，所以就需要9次。</p><p>其他的可能性还有：</p><ul><li>假若二三名分别为：B1，A2</li><li>假若二三名分别为：B1，B2</li><li>假若二三名分别为：B1，C1</li></ul><p>上面这三种情况分析的方法一致，就不一一说明了，大概的思路就是，我们需要<strong>根据第三名，分析出可能的第四名</strong>。<strong>再根据第四名，分析出对应情况下的第五名</strong>。最终再在这些马匹里，抉择出真正的第四名和第五名。</p><p>因为题中问的是<strong>最少比多少场可以跑出前五名</strong>。所以根据分析，假如<strong>第二名和第三名是A2和A3的话，只需要8次就可以跑出前五名</strong>。最少次数是8。（这个题目其实是不严谨的，所以如果有面试官问到这个题，最好是给出所有可能性的推导过程）</p></blockquote><h3 id="8-灯泡开关"><a href="#8-灯泡开关" class="headerlink" title="8.灯泡开关"></a>8.灯泡开关</h3><div class="table-container"><table><thead><tr><th>第319题：开关灯泡</th></tr></thead><tbody><tr><td>初始时有 n 个灯泡关闭。第 1 轮，你打开所有的灯泡。第 2 轮，每两个灯泡关闭一次。第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。对于第 n 轮，你只切换最后一个灯泡的开关。找出 n 轮后有多少个亮着的灯泡。</td></tr></tbody></table></div><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 1 </span><br><span class="line">解释: </span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 1，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure><blockquote><p>这是一道难度评定为<strong>困难</strong>的题目。但是，其实这并不是一道算法题，而是一个脑筋急转弯。只要我们模拟一下开关灯泡的过程，大家就会瞬间get，一起来分析一下：</p><p>我们模拟一下n从1到12的过程。在第一轮，你打开了12个灯泡：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/81.png" alt></p><p>因为对于大于n的灯泡你是不care的，所以我们用黑框框表示：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/82.png" alt></p><p>然后我们列出n从1-12的过程中所有的灯泡示意图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/83.png" alt></p><p>可以得到如下表格：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/84.png" alt></p><p>观察一下，这是什么？观察不出来，咱们看看这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">1</span>; n &lt;= <span class="number">12</span>; n++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;n=&quot;</span>, n, <span class="string">&quot;\t灯泡数\t&quot;</span>, math.Sqrt(<span class="keyword">float64</span>(n)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">n= <span class="number">1</span>     灯泡数  <span class="number">1</span></span><br><span class="line">n= <span class="number">2</span>     灯泡数  <span class="number">1.4142135623730951</span></span><br><span class="line">n= <span class="number">3</span>     灯泡数  <span class="number">1.7320508075688772</span></span><br><span class="line">n= <span class="number">4</span>     灯泡数  <span class="number">2</span></span><br><span class="line">n= <span class="number">5</span>     灯泡数  <span class="number">2.23606797749979</span></span><br><span class="line">n= <span class="number">6</span>     灯泡数  <span class="number">2.449489742783178</span></span><br><span class="line">n= <span class="number">7</span>     灯泡数  <span class="number">2.6457513110645907</span></span><br><span class="line">n= <span class="number">8</span>     灯泡数  <span class="number">2.8284271247461903</span></span><br><span class="line">n= <span class="number">9</span>     灯泡数  <span class="number">3</span></span><br><span class="line">n= <span class="number">10</span>     灯泡数  <span class="number">3.1622776601683795</span></span><br><span class="line">n= <span class="number">11</span>     灯泡数  <span class="number">3.3166247903554</span></span><br><span class="line">n= <span class="number">12</span>     灯泡数  <span class="number">3.4641016151377544</span></span><br></pre></td></tr></table></figure><p>没错，只要我们对n进行开方，就可以得到最终的灯泡数。根据分析，得出代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulbSwitch</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(sqrt(n))</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了60.08% 的Python3用户<br>内存消耗:13.6 MB,击败了7.43% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.1 MB, 在所有 Java 提交中击败了71.93% 的用户</p><blockquote><p>证明如下：</p><p>约数，又称因数。整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。</p><p>从我们观察可以发现，如果一个灯泡有奇数个约数，那么最后这个灯泡一定会亮着。</p><p>什么，你问我奇数是什么？奇数（odd）指不能被2整除的整数 ，数学表达形式为：2k+1， 奇数可以分为正奇数和负奇数。</p><p>所以其实我们是求，<strong>从1-n有多少个数的约数有奇数个</strong>。而<strong>有奇数个约数的数一定是完全平方数。</strong> 这是因为，对于数n，如果m是它的约数，则n/m也是它的约数，若m≠n/m，则它的约数是以m、n/m的形式成对出现的。而m＝n/m成立且n/m是正整数时，n是完全平方数，而它有奇数个约数。</p><p>我们再次转化问题，<strong>求1-n有多少个数是完全平方数</strong>。</p><p>什么，你又不知道什么是完全平方数了？完全平方指用一个整数乘以自己例如1×1，2×2，3×3等，依此类推。若一个数能表示成某个整数的平方的形式，<strong>则称这个数为完全平方数</strong>。</p><p>到这里，基本就很明朗了。剩下的，我想不需要再说了吧！</p></blockquote><h3 id="9-三门问题"><a href="#9-三门问题" class="headerlink" title="9.三门问题"></a>9.三门问题</h3><div class="table-container"><table><thead><tr><th>三门问题</th></tr></thead><tbody><tr><td>参赛者的面前有三扇关闭着的门，其中一扇的后面是天使，选中后天使会达成你的一个愿望，而另外两扇门后面则是恶魔，选中就会死亡。</td></tr></tbody></table></div><p>当你选定了一扇门，但未去开启它的时候，上帝会开启剩下两扇门中的一扇，露出其中一只恶魔。（上帝是全能的，必会打开恶魔门）随后上帝会问你要不要更换选择，选另一扇仍然关着的门。</p><blockquote><p>按照常理，参赛者在做出最开始的决定时，对三扇门后面的事情一无所知，因此他选择正确的概率是1/3，这个应该大家都可以想到。</p><p>接下来，主持人排除掉了一个错误答案（有恶魔的门），于是剩下的两扇门必然是一扇是天使，一扇是恶魔，那么此时无论选择哪一扇门，胜率都是1/2，依然合乎直觉。</p><p>所以你作为参赛者，你会认为换不换都无必要，获胜概率均为1/2。但是，真的是这样吗？</p><p>正确的答案是，<strong>如果你选择了换，碰见天使的概率会高达2/3，而不不换的话，碰见天使的概率只有1/3。</strong> 怎么来的？</p><p>我们用一个很通俗的方法，能让你一听就懂。首先刚开始选择的一扇门的概率为1/3，而另外两扇门的总概率为2/3。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/85.png" alt><br>现在上帝打开了其中一扇为恶魔的门，我们知道这个门后面不会再有天使，所以相当于这部分概率被第三个门持有。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/86.png" alt><br>剩下的那扇门的概率（2/3）相当于刚开始选择的门（1/3）的二倍。所以我们得换。</p><p>如果还没有听懂。我们可以假设有一百扇门，里边有99只都是恶魔。现在你随机选择一扇门，选择到天使的概率是1/100。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/87.jpeg" alt><br>这时，上帝打开其中的98扇，里边都是恶魔。这时候就相当于99/100的概率都集中在了另一扇门里。自然，我们需要选择换</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/88.jpeg" alt></p></blockquote><p><strong>代码证明</strong><br>为了验证结果，我用代码跑了一百万次。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//换门遇见天使的次数和不换门遇见天使的次数     changeAngelCount, unchangeAngelCount := 0, 0     for i := 0; i &lt; 1000000; i++ &#123; </span></span><br><span class="line">        <span class="comment">//门的总数 </span></span><br><span class="line">        doors := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; </span><br><span class="line">        <span class="comment">//天使门和选中的门         angelDoor, selectedDoor := rand.Intn(3), rand.Intn(3) </span></span><br><span class="line">        <span class="comment">//上帝移除一扇恶魔门</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(doors); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> doors[j] != selectedDoor &amp;&amp; doors[j] != angelDoor &#123;</span><br><span class="line">                doors = <span class="built_in">append</span>(doors[:j], doors[j+<span class="number">1</span>:]...)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计        </span></span><br><span class="line">        <span class="keyword">if</span> selectedDoor == angelDoor &#123;</span><br><span class="line">            unchangeAngelCount++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            changeAngelCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不换门遇见天使次数:&quot;</span>, unchangeAngelCount, <span class="string">&quot;比例：&quot;</span>, (<span class="keyword">float32</span>(unchangeAngelCount) / <span class="number">1000000</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;换门遇见天使次数:&quot;</span>, changeAngelCount, <span class="string">&quot;比例：&quot;</span>, (<span class="keyword">float32</span>(changeAngelCount) / <span class="number">1000000</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果为：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/89.png" alt></p><h3 id="10-猜数字游戏"><a href="#10-猜数字游戏" class="headerlink" title="10.猜数字游戏"></a>10.猜数字游戏</h3><div class="table-container"><table><thead><tr><th>第299题：猜数字（Bulls and Cows）游戏</th></tr></thead><tbody><tr><td>你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</td></tr></tbody></table></div><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p><p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line">输出: &quot;1A3B&quot;</span><br><span class="line">解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line">输出: &quot;1A1B&quot;</span><br><span class="line">解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p><blockquote><p>基本拿到题目，我们就能想到可以使用hashmap进行求解，一起来分析一下。</p><ul><li>因为secret数字和guess数字长度相等，所以我们遍历secret数字。</li><li>如果当前索引两个数字相同，就将公牛数加1。</li><li><strong>如果不相同，我们将secret和guess当前索引位置处的数字通过map记录下来，统计他们出现的次数。当然，之前我们讲过。有限的map，比如数字 0-10，字母 a-z，都可以通过数组</strong>来进行替换，用以压缩空间。</li><li>最后，如果记录的两个map中，<strong>数字出现重叠</strong>（可以通过最小值来判断），则意味着该数字在两边都出现过，就将母牛数加一</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span>(<span class="params">self, secret: <span class="built_in">str</span>, guess: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        mapS, mapG = &#123;&#125;, &#123;&#125;</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(secret)):</span><br><span class="line">            <span class="keyword">if</span> secret[i] == guess[i]:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> secret[i] <span class="keyword">not</span> <span class="keyword">in</span> mapS:</span><br><span class="line">                    mapS[secret[i]] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mapS[secret[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> guess[i] <span class="keyword">not</span> <span class="keyword">in</span> mapG:</span><br><span class="line">                    mapG[guess[i]] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mapG[guess[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> mapS.keys():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> mapG:</span><br><span class="line">                b += <span class="built_in">min</span>(mapS[key], mapG[key])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(a)+<span class="string">&#x27;A&#x27;</span>+<span class="built_in">str</span>(b)+<span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了88.82% 的Python3用户<br>内存消耗:13.5 MB,击败了16.77% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mapS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mapG = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(secret.charAt(i) == guess.charAt(i)) a++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mapS[secret.charAt(i) - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">                mapG[guess.charAt(i) - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            b += Math.min(mapS[i], mapG[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="string">&quot;A&quot;</span> + b + <span class="string">&quot;B&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：8 ms, 在所有 Java 提交中击败了34.92% 的用户<br>内存消耗：38.5 MB, 在所有 Java 提交中击败了41.70% 的用户</p><h3 id="11-LRU缓存机制"><a href="#11-LRU缓存机制" class="headerlink" title="11.LRU缓存机制"></a>11.LRU缓存机制</h3><blockquote><p>LRU 是 Least Recently Used 的缩写，译为最近最少使用。它的理论基础为“<strong>最近使用的数据会在未来一段时期内仍然被使用，已经很久没有使用的数据大概率在未来很长一段时间仍然不会被使用</strong>”由于该思想非常契合业务场景 ，并且可以解决很多实际开发中的问题，所以我们经常通过 LRU 的思想来作缓存，一般也将其称为<strong>LRU缓存机制</strong>。</p></blockquote><div class="table-container"><table><thead><tr><th>第146题：LRU缓存机制</th></tr></thead><tbody><tr><td>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作：获取数据 get 和 写入数据 put 。</td></tr></tbody></table></div><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1 。</p><p>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // 返回  1</span><br><span class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       // 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       // 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       // 返回  3</span><br><span class="line">cache.get(4);       // 返回  4</span><br></pre></td></tr></table></figure><p><strong>方法一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 搜索不到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 取出缓存中的key并赋值,使最近被使用的排在最后面</span></span><br><span class="line">        self.cache[key] = self.cache.pop(key)</span><br><span class="line">        <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 如存在就先删除key</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.cache.pop(key)</span><br><span class="line">        <span class="comment"># 先放「密钥/数据值」，之后再判断是否达到上限</span></span><br><span class="line">        self.cache[key] = value</span><br><span class="line">        <span class="comment">#  若超出容量则取最前面的删除，即最近最少使用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            x = <span class="built_in">list</span>(self.cache)[<span class="number">0</span>]</span><br><span class="line">            self.cache.pop(x)</span><br></pre></td></tr></table></figure><p>执行耗时:232 ms,击败了54.22% 的Python3用户<br>内存消耗:21.8 MB,击败了65.84% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> value = map.remove(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) map.remove(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span>(map.size() &gt; capacity) map.remove(map.keySet().iterator().next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：21 ms, 在所有 Java 提交中击败了45.53% 的用户<br>内存消耗：46.7 MB, 在所有 Java 提交中击败了29.06% 的用户</p><p><strong>方法二：优化</strong></p><blockquote><p>py的原生<code>dict</code>自带链表，已经实现了<code>collections.OrderedDict</code>的绝大部分功能，继承就好。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.c = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self[key] = self.pop(key)</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        key <span class="keyword">in</span> self <span class="keyword">and</span> self.pop(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="built_in">len</span>(self) &gt; self.c <span class="keyword">and</span> self.pop(<span class="built_in">next</span>(<span class="built_in">iter</span>(self)))</span><br></pre></td></tr></table></figure><p>执行耗时:164 ms,击败了99.39% 的Python3用户<br>内存消耗:21.8 MB,击败了67.73% 的Python3用户</p><blockquote><p>Java的<code>LinkedHashMap</code>已实现<strong>removeEldestEntry()方法</strong>用于检查是否删除最旧的条目，只需重写即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载因子，一般是 0.75f</span></span><br><span class="line">        <span class="comment">// true: 是访问的顺序，也就是谁最先访问，就排在第一位  </span></span><br><span class="line">        <span class="comment">// false:存放顺序，就是你put 元素的时候的顺序  </span></span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：20 ms, 在所有 Java 提交中击败了56.47% 的用户<br>内存消耗：46.6 MB, 在所有 Java 提交中击败了46.56% 的用户</p><h3 id="12-最小的k个数"><a href="#12-最小的k个数" class="headerlink" title="12.最小的k个数"></a>12.最小的k个数</h3><div class="table-container"><table><thead><tr><th>剑指offer第40题：最小的k个数</th></tr></thead><tbody><tr><td>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</td></tr></tbody></table></div><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= k &lt;= arr.length &lt;= 10000</span><br><span class="line">0 &lt;= arr[i] &lt;= 10000</span><br></pre></td></tr></table></figure><blockquote><p>堆的特性是<strong>父节点的值总是比其两个子节点的值大或小</strong>。如果父节点比它的两个子节点的值都要大，我们叫做<strong>大顶堆</strong>。如果父节点比它的两个子节点的值都要小，我们叫做<strong>小顶堆</strong>。</p><p>我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/90.png" alt><br>大顶堆，满足以下公式: arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p><p>小顶堆也一样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/91.png" alt><br>小顶堆，满足以下公式: arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p><p>上面我们学习了大顶堆，现在考虑如何用大根堆进行求解。</p><p>首先，我们创建一个大小为k的大顶堆。假如数组为[4,5,1,6,2,7,3,8]，k=4。大概是下面这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/92.png" alt><br>我想肯定这里有不知道如何建堆的同学。记住：<strong>对于一个没有维护过的堆（完全二叉树），我们可以从其最后一个节点的父节点开始进行调整</strong>。这个不需要死记硬背，其实就是一个层层调节的过程。</p><p>从最后一个节点的父节点调整</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/93.png" alt><br>继续向上调整<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/94.png" alt><br>继续向上调整<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/95.png" alt><br>然后我们从下标 k 继续开始依次遍历数组的剩余元素。如果元素小于堆顶元素，那么取出堆顶元素，将当前元素入堆。在上面的示例中 ，因为2小于堆顶元素6，所以将2入堆。我们发现现在的完全二叉树不满足大顶堆，所以对其进行调整。<br>调整前<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/96.png" alt><br>调整后<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/97.png" alt><br>继续重复上述步骤，依次将7,3,8入堆。这里因为7和8都大于堆顶元素5，所以只有3会入堆。<br>调整前<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/98.png" alt><br>调整后<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/99.png" alt><br>最后得到的堆，就是我们想要的结果。由于堆的大小是 K，所以这里空间复杂度是O(K)，时间复杂度是O(NlogK)。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 最小的k个数 最大堆</span></span><br><span class="line">        <span class="comment"># 最大堆 顶点最大</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHeapfy</span>(<span class="params">maxHeap, i, n</span>):</span></span><br><span class="line">            <span class="comment"># 左右子节点</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            <span class="comment"># 假定当前节点最大</span></span><br><span class="line">            maxPoint = i</span><br><span class="line">            <span class="comment"># 和当前节点的左右节点比较，如果节点中有更大的数，那么交换，并继续对交换后的节点进行维护</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> maxHeap[left] &gt; maxHeap[maxPoint]:</span><br><span class="line">                maxPoint = left</span><br><span class="line">            <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> maxHeap[right] &gt; maxHeap[maxPoint]:</span><br><span class="line">                maxPoint = right</span><br><span class="line">            <span class="comment"># 如果最大的数不是节点i的话，那么交换后，调整节点i的子树。</span></span><br><span class="line">            <span class="keyword">if</span> maxPoint != i:</span><br><span class="line">                maxHeap[i], maxHeap[maxPoint] = maxHeap[maxPoint], maxHeap[i]</span><br><span class="line">                maxHeapfy(maxHeap, maxPoint, n)</span><br><span class="line">        <span class="comment"># 初始化 取前k个树，组成最大堆</span></span><br><span class="line">        maxHeap = arr[:k]</span><br><span class="line">        <span class="comment"># 对于一个还没维护过的堆，从他的最后一个节点的父节点开始进行调整。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            maxHeapfy(maxHeap, i, k)</span><br><span class="line">        <span class="comment"># 继续调整后面节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># 如果元素小于堆顶元素，那么取出堆顶元素，将当前元素入堆</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; maxHeap[<span class="number">0</span>]:</span><br><span class="line">                maxHeap[<span class="number">0</span>] = arr[i]</span><br><span class="line">                maxHeapfy(maxHeap, <span class="number">0</span>, k)</span><br><span class="line">        <span class="comment"># 最后得到的堆，就是我们想要的结果</span></span><br><span class="line">        <span class="keyword">return</span> maxHeap</span><br></pre></td></tr></table></figure><p>执行耗时:136 ms,击败了26.01% 的Python3用户<br>内存消耗:14.5 MB,击败了57.67% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, res, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：7 ms, 在所有 Java 提交中击败了72.61% 的用户<br>内存消耗：39.8 MB, 在所有 Java 提交中击败了58.60% 的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：14 ms, 在所有 Java 提交中击败了41.61% 的用户<br>内存消耗：39.8 MB, 在所有 Java 提交中击败了57.97% 的用户</p><h3 id="13-不同路径"><a href="#13-不同路径" class="headerlink" title="13.不同路径"></a>13.不同路径</h3><div class="table-container"><table><thead><tr><th>第62题：不同路径</th></tr></thead><tbody><tr><td>一个机器人位于一个 m x n 网格的左上角，起始点在下图中标记为“Start”。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，在下图中标记为“Finish”。 问：总共有多少条不同的路径？</td></tr></tbody></table></div><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/100.png" alt></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>说明：</strong>m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">\1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">\2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">\3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><blockquote><p>这道题属于相当标准的动态规划，虽然还有一些公式法等其他解法，但是如果面试官问到，基本就是想考察你的动态规划。</p><p>因为有横纵坐标，明显属于二维DP。我们定义<strong>DP[i][j]表示到达i行j列的最多路径</strong>。同时，因为第0行和第0列都只有一条路径，所以需要初始化为1。</p><p>状态转移方程一目了然，dp[i][j] = dp[i-1][j] +dp[i][j-1]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 初始化为1，因为第0行和第0列为1</span></span><br><span class="line">        dp = [[ <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了41.96% 的Python3用户<br>内存消耗:13.7 MB,击败了5.03% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.6 MB, 在所有 Java 提交中击败了5.30% 的用户</p><p><strong>优化</strong></p><blockquote><p>上面的答案，如果在面试时给出，可以给到7分，后面3分怎么拿，我们真的需要用一个二维数组来存储吗？一起看下！</p><p>我们使用<strong>二维数组</strong>记录状态。但是这里观察一下，每一个格子可能的路径，<strong>都是由左边的格子和上面的格子的总路径计算而来， 对于之前更早的数据，其实已经用不到了</strong>。如计算第三行时，已经用不到第一行的数据了。</p><p>那我们只要能定义一个状态，同时可以表示左边的格子和上面的格子，是不是就可以解决问题？所以我们定义状态dp[j]，用来表示<strong>当前行到达第j列的最多路径</strong>。这个“当前行”三个字很重要，比如我们要计算dp[3]，因为还没有计算出，所以这时dp[3]保存的其实是4（上一行的数据），而dp[2]由于已经计算出了，所以保存的是6（当前行的数据）。理解了这个，就理解如何压缩状态。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/101.png" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了67.50% 的Python3用户<br>内存消耗:13.6 MB,击败了8.16% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-不同路径-障碍物"><a href="#14-不同路径-障碍物" class="headerlink" title="14.不同路径-障碍物"></a>14.不同路径-障碍物</h3><div class="table-container"><table><thead><tr><th>第63题：不同路径 - 障碍物</th></tr></thead><tbody><tr><td>一个机器人位于一个 m x n 网格的左上角，起始点在下图中标记为“Start”。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，在下图中标记为“Finish”。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 问总共有多少条不同的路径？</td></tr></tbody></table></div><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/102.png" alt></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><strong>说明：</strong> m 和 n 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">\1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">\2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><blockquote><p>首先我们还是定义状态，<strong>用DP[i][j]表示到达i行j列的最多路径</strong>。同时，因为第0行和第0列都只有一条路径，所以需要初始化为1。但有一点不一样的就是：<strong>如果在0行0列中遇到障碍物，后面的就都是0，意为此路不通</strong>。</p><p>完成了初始化，下面就是状态转移方程。和没有障碍物的相比没什么特别的，仍然是dp[i][j] = dp[i-1][j]+dp[i][j-1]。唯一需要处理的是：<strong>如果恰好[i][j]位置上有障碍物，则dp[i][j]为0</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(obstacleGrid))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">0</span>][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(obstacleGrid)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span> <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(obstacleGrid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])):</span><br><span class="line">                dp[i][j] = <span class="number">0</span> <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> <span class="keyword">else</span> dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了73.20% 的Python3用户<br>内存消耗:13.7 MB,击败了5.03% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) dp[row][col] = obstacleGrid[row][col] == <span class="number">1</span>? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(row == <span class="number">0</span>) dp[row][col] = obstacleGrid[row][col] == <span class="number">1</span>? <span class="number">0</span>: dp[row][col-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">0</span>) dp[row][col] = obstacleGrid[row][col] == <span class="number">1</span>? <span class="number">0</span>: dp[row-<span class="number">1</span>][col];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[row][col] = obstacleGrid[row][col] == <span class="number">1</span>? <span class="number">0</span>: dp[row-<span class="number">1</span>][col]+dp[row][col-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.7 MB, 在所有 Java 提交中击败了60.14% 的用户</p><p><strong>优化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>]),</span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * (n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j] + dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了89.96% 的Python3用户<br>内存消耗:13.4 MB,击败了54.45% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[row][col] == <span class="number">1</span>) dp[col] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(col &gt; <span class="number">0</span>) dp[col] = dp[col-<span class="number">1</span>] + dp[col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.8 MB, 在所有 Java 提交中击败了52.90% 的用户</p><h3 id="15-盛最多水的容器"><a href="#15-盛最多水的容器" class="headerlink" title="15.盛最多水的容器"></a>15.盛最多水的容器</h3><div class="table-container"><table><thead><tr><th>第11题：盛最多水的容器</th></tr></thead><tbody><tr><td>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</td></tr></tbody></table></div><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/103.jpg" alt></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7] </span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><blockquote><p>观察可得，垂直的两条线段将会与坐标轴构成一个矩形区域，较短线段的长度将会作为矩形区域的宽度，两线间距将会作为矩形区域的长度，我们求解容纳水的最大值，实为找到该矩形最大化的区域面积。</p><p>首先，本题自然可以暴力求解，只要<strong>找到每对可能出现的线段组合，然后找出这些情况下的最大面积</strong>。这种解法直接略过，大家有兴趣可以下去自己尝试。这道题比较经典是是使用双指针进行求解，已经会的朋友不妨复习复习。</p><p>我们初始化两个指针，分别指向两边，构成我们的第一个矩形区域。</p><p>根据木桶原理，水的高度取决于短的一侧。我们总是<strong>选择将短的一侧向长的一侧移动</strong>。并且在每一次的移动中，我们记录下来当前面积大小。</p><p>一直到两个棒子撞在一起。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                maxArea = <span class="built_in">max</span>(maxArea, height[left] * (right - left))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxArea = <span class="built_in">max</span>(maxArea, height[right] * (right - left))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure><p>执行耗时:64 ms,击败了90.74% 的Python3用户<br>内存消耗:14.9 MB,击败了38.00% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                maxArea = Math.max(maxArea, height[left]*(right - left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                maxArea = Math.max(maxArea, height[right]*(right - left));</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了94.88% 的用户<br>内存消耗：51.7 MB, 在所有 Java 提交中击败了53.67% 的用户</p><h3 id="16-扑克牌中的顺子容器"><a href="#16-扑克牌中的顺子容器" class="headerlink" title="16.扑克牌中的顺子容器"></a>16.扑克牌中的顺子容器</h3><div class="table-container"><table><thead><tr><th>剑指offer第61题：扑克牌中的顺子</th></tr></thead><tbody><tr><td>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组长度为 5 </span><br><span class="line">数组的数取值为 [0, 13] </span><br></pre></td></tr></table></figure><blockquote><p>数组长度限制了是5，非常省事，意味着我们不需要一些额外的处理。拿到牌，第一个想法排序！<strong>因为是5连，无论接没接到大小王，最小值和最大值之间，一定小于5</strong>。</p><p>排序后，我们通过累积每两张牌之间的差值，来计算最小值和最大值中间的总差值。</p><p>拿到了王，就相当于拿到了通行证，直接跳过。因为是排序的牌，如果接到对子，也就意味着不是五连，直接返回false。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        sub = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            sub += nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">        <span class="keyword">return</span> sub &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了40.35% 的Python3用户<br>内存消耗:13.5 MB,击败了16.56% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sub += (nums[i+<span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sub &lt; <span class="number">5</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了91.62% 的用户<br>内存消耗：35.7 MB, 在所有 Java 提交中击败了86.90% 的用户</p><h3 id="17-整数拆分"><a href="#17-整数拆分" class="headerlink" title="17.整数拆分"></a>17.整数拆分</h3><div class="table-container"><table><thead><tr><th>第343题：整数拆分</th></tr></thead><tbody><tr><td>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。返回你可以获得的最大乘积。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 n 不小于 2 且不大于 58。</p><blockquote><p>要对一个整数进行拆分，并且要使这些拆分完后的因子的乘积最大。我们可以先尝试拆分几个数值，测试一下。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/104.png" alt></p><p>通过观察，首先肯定可以明确，<strong>2 和 3 是没办法进行拆分的最小因子</strong>。同时，我们好像能看出来：</p><ul><li>只要把 n 尽可能的拆分成包含3的组合，就可以得到最大值。</li><li>如果没办法拆成 3 的组合，就退一步拆成 2 的组合。</li><li>对于 3 和 2 ，没办法再进行拆分。</li></ul><p>根据分析，我们尝试使用<strong>贪心</strong>进行求解。因为一个数（假设为n）除以另一个数，总是包括整数部分（x）和余数部分（y）。那刚才也得到了，<strong>最优因子是3</strong>，所以我们需要让 n/3，这样的话，余数可能是 1,2 两种可能性。</p><ul><li>如果余数是 1 ，刚才我们也分析过，对于 1 的拆分是没有意义的，所以我们退一步，将最后一次的 3 和 1 的拆分，用 2 和 2 代替。</li><li>如果余数是 2 ，那不消多说，直接乘以最后的 2 即可。</li></ul></blockquote><p><strong>方法一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 恰好整除，直接为3^x</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> ** (n // <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 余数为1，退一步 3^(x-1)*2*2</span></span><br><span class="line">        <span class="keyword">elif</span> n % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> ** (n // <span class="number">3</span> - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">        <span class="comment"># 余数为2，直接乘以2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> ** (n // <span class="number">3</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了96.37% 的Python3用户<br>内存消耗:13.5 MB,击败了31.43% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, n/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, n/<span class="number">3</span>-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, n/<span class="number">3</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了31.03% 的用户</p><p><strong>方法二：动态规划</strong></p><blockquote><p>dp[i]代表 i 拆分之后得到的乘积的最大的元素，比如dp[4]就保存将4拆分后得到的最大的乘积。状态转移方程式为 dp[i]=max(dp[i], (i-j)*max(dp[j],j))</p><p>整体思路就是这样，将一个大的问题，分解成一个一个的小问题，然后完成一个<strong>自底向上</strong>的过程。举一个例子，比如计算 10 ，可以拆分 6 和 4 ，因为 6 的最大值 3x3，以及 4 的最大值 2x2 都已经得到，所以就替换成 9 和 4 ，也就是 10=3x3x4。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[j], j) * (i - j))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了57.61% 的Python3用户<br>内存消耗:13.5 MB,击败了31.43% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(dp[j], j)*(i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了12.89% 的用户<br>内存消耗：35.1 MB, 在所有 Java 提交中击败了80.09% 的用户</p><h3 id="18-移动石子直到连续"><a href="#18-移动石子直到连续" class="headerlink" title="18.移动石子直到连续"></a>18.移动石子直到连续</h3><div class="table-container"><table><thead><tr><th>第1033题：移动石子直到连续</th></tr></thead><tbody><tr><td>三枚石子放置在数轴上，位置分别为 a，b，c。每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。要使游戏结束，你可以执行的最小和最大移动次数分别是多少？以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]</td></tr></tbody></table></div><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = 2, c = 5</span><br><span class="line">输出：[1, 2]</span><br><span class="line">解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 4, b = 3, c = 2</span><br><span class="line">输出：[0, 0]</span><br><span class="line">解释：我们无法进行任何移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= a &lt;= 100</span><br><span class="line">1 &lt;= b &lt;= 100</span><br><span class="line">1 &lt;= c &lt;= 100</span><br><span class="line">a != b, b != c, c != a</span><br></pre></td></tr></table></figure><blockquote><p>读懂了题意，开始进行分析。首先可以明确，每一次我们其实<strong>是从边上来挑选石子，然后往中间进行移动</strong>。所以，我们首先得找到min（左），max（右）以及mid（中）三个值。我们设，min和mid中的距离为x，max和min中的距离为y。大概就是下面这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/105.png" alt></p><p>然后只需要计算x和y的和，就是我们要找的最大值。而最小值，就很容易了，只有0,1,2三种可能性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMovesStones</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    	<span class="comment"># 将石子从小到大排序</span></span><br><span class="line">        arr = <span class="built_in">sorted</span>([a, b, c])</span><br><span class="line">        x = arr[<span class="number">1</span>] - arr[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">        y = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">        <span class="built_in">max</span> = x + y</span><br><span class="line">        <span class="built_in">min</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span> <span class="keyword">or</span> y != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">1</span> <span class="keyword">and</span> y &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">min</span> = <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">min</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">min</span>, <span class="built_in">max</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:28 ms,击败了99.36% 的Python3用户<br>内存消耗:13.5 MB,击败了33.33% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b ,c&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> x = arr[<span class="number">1</span>] - arr[<span class="number">0</span>] -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_move = x + y;</span><br><span class="line">        <span class="keyword">int</span> min_move = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; <span class="number">1</span> &amp;&amp; y &gt; <span class="number">1</span>) min_move = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> min_move = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;min_move, max_move&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了49.13% 的用户<br>内存消耗：36.1 MB, 在所有 Java 提交中击败了93.93% 的用户</p><h3 id="19-Nim游戏"><a href="#19-Nim游戏" class="headerlink" title="19.Nim游戏"></a>19.Nim游戏</h3><div class="table-container"><table><thead><tr><th>第292题：Nim 游戏</th></tr></thead><tbody><tr><td>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</td></tr></tbody></table></div><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: false </span><br><span class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure><blockquote><p>首先如果石头数小于4个，那么因为你是先手，一把拿走，肯定会赢。</p><p>而如果石头是4个，那不管你是拿了1,2,3个，最后一个都可以被你的对手拿走，所以怎么样都赢不了。</p><p>再继续分析到8个石头：对于5,6,7而言，你只需要对应的拿走1,2,3，然后留下4个，则对方必输。但是如果你要面对的是8，不管先拿（1,2,3）个，另一个人都可以通过 8-(1,2,3) ，使得你面对4个石头，则你必输无疑。通过观察，我们发现，好像是<strong>只要N是4的倍数，我们就必输无疑</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了55.90% 的Python3用户<br>内存消耗:13.5 MB,击败了11.08% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：35.4 MB, 在所有 Java 提交中击败了16.27% 的用户</p><h3 id="20-寻找两个正序数组的中位数"><a href="#20-寻找两个正序数组的中位数" class="headerlink" title="20.寻找两个正序数组的中位数"></a>20.寻找两个正序数组的中位数</h3><div class="table-container"><table><thead><tr><th>第4题：寻找两个正序数组的中位数</th></tr></thead><tbody><tr><td>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0], nums2 = [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure></p><p><strong>示例 4：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [], nums2 = [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure></p><p><strong>示例 5：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2], nums2 = []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>一般如果题目要求时间复杂度在O(log(n))，大部分都是可以使用二分的思想来进行求解</strong>。</p><p>如果只有一个有序数组，我们需要找中位数，那肯定需要判断元素是奇数个还是偶数个，如果是奇数个那最中间的就是中位数，如果是偶数个的话，那就是最中间两个数的和除以2。</p><p>那如果是两个数组，也是一样的，我们先求出两个数组长度之和。如果为奇数，就找中间的那个数，也就是 <strong>(长度之和 + 1)/2</strong> 。如果为偶数，那就找 <strong>长度之和/2</strong>。比如下面的 (9 + 5)/2 = 7，那我们最终就是<strong>找到排列第7位的值</strong>。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/106.jpg" alt></p><p>现在的问题是，我们如何用二分的思想来找到中间排列第7位的数。这里有一种不太好想到的方式，<strong>是用删的方式</strong>，因为<strong>如果我们可以把多余的数排除掉，最终剩下的那个数，是不是就是我们要找的数？</strong> 对于上面的数组，我们可以先删掉 7/2=3 个数。那这里，可以选择删上面的，也可以选择删下面的。那这里因为 i&lt;j，所以我们选择删除上面的3个数。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/107.jpg" alt></p><p>（删除前）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/108.png" alt></p><p>（删除后）</p><p>由于我们已经排除掉了 3 个数字，现在对于两个数组，我们需要找到7-3=4的数字，来进行下一步运算。我们可以继续删掉4/2=2个数。我们比较i和j的值，删除小的一边。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/109.png" alt></p><p>（删除前）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/110.jpg" alt></p><p>（删除后）</p><p>继续上面的步骤，我们删除 2/2=1 个数。<strong>同理，比较7和6的大小，删除小的一边</strong>。删完后是下面这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/111.png" alt></p><p>（7和6，删除6）</p><p>不要忘记我们的目的，我们是为了找第7小的数。此时，<strong>两个数组的第一个元素，哪个小，就是我们要找的那个数</strong>。因为7&lt;8，所以7就是我们要找的第7小的数。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/112.jpg" alt></p><p>这里有一点比较特殊的，如果在删除过程中，我们<strong>要删除的K/2个数，大于其中一边的数组长度</strong>，那我们就将小的一侧数组元素都删除。比如下面这个，此时7/2=3，但是下面的数组只有2个元素，我们就将它全部删除。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/113.jpg" alt></p><p>删完之后，此时因为只删除了2个元素，所以k变成了5。那我们只需要返回其中一边的第5个元素就ok。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/114.jpg" alt></p><p>整个上面的过程，完成了本题的算法架构！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">nums1, i, nums2, j, k</span>):</span></span><br><span class="line">            <span class="comment"># 特殊情况：要删除的个数大于其中一边的数组长度</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= len1:</span><br><span class="line">                <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 特殊情况：要删除的个数大于其中一边的数组长度</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= len2:</span><br><span class="line">                <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 正常情况</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j])</span><br><span class="line">            <span class="comment"># 计算出每次要比较的两个数的值，来决定&quot;删除&quot;哪边的元素</span></span><br><span class="line">            mid1 = nums1[i + k // <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> (i + k // <span class="number">2</span> - <span class="number">1</span>) &lt; len1 <span class="keyword">else</span> inf</span><br><span class="line">            mid2 = nums2[j + k // <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> (j + k // <span class="number">2</span> - <span class="number">1</span>) &lt; len2 <span class="keyword">else</span> inf</span><br><span class="line">            <span class="comment">#　通过递归的方式，来模拟删除掉前K//2个元素</span></span><br><span class="line">            <span class="keyword">if</span> mid1 &lt; mid2:</span><br><span class="line">                <span class="keyword">return</span> findK(nums1, i + k // <span class="number">2</span>, nums2, j, k - k // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> findK(nums1, i, nums2, j + k // <span class="number">2</span>, k - k // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        len1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        len2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        total = len1 + len2</span><br><span class="line">        <span class="comment"># 比如总数为偶数14，就要找第7个和第8个</span></span><br><span class="line">        <span class="comment"># 比如总数为奇数5，就要找第3个</span></span><br><span class="line">        left = (total + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        right = (total + <span class="number">2</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (findK(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findK(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了77.16% 的Python3用户<br>内存消耗:13.8 MB,击败了5.17% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = length1 + length2;</span><br><span class="line">        <span class="keyword">int</span> left = (totalLength + <span class="number">1</span>) / <span class="number">2</span>, right = (totalLength + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> median = (getKthElement(nums1, nums2, left) + getKthElement(nums1, nums2, right)) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kthElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> half = k / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了82.06% 的用户<br>内存消耗：39.2 MB, 在所有 Java 提交中击败了99.34% 的用户</p><h3 id="21-第k个最大元素"><a href="#21-第k个最大元素" class="headerlink" title="21.第k个最大元素"></a>21.第k个最大元素</h3><div class="table-container"><table><thead><tr><th>第215题：第K个最大元素</th></tr></thead><tbody><tr><td>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><blockquote><p>这种题目，从个人来讲，我一般是比较偏好使用堆来做的。毕竟大小顶堆，刚好有着与本类题型契合的特性。我们对其构造一个小顶堆（每个结点的值均不大于其左右孩子结点的值，堆顶元素为整个堆的最小值），整个过程是这样：</p><p>构造一个小顶堆，依次将元素放入堆中，并保证堆中元素为k。</p><p>如果当前元素小于堆顶元素，那基本就不用看了（因为我们要找的是 排序后的第 k 个最大的元素）</p><p>自然，如果我们遇到比堆顶元素大的元素，就把它放入到堆中。</p><p>重复上面的步骤。</p></blockquote><p><strong>方法一：小顶堆</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 最大的k个数 最小堆</span></span><br><span class="line">        <span class="comment"># 最小堆 顶点最小</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">minHeapfy</span>(<span class="params">minHeap, i, k</span>):</span></span><br><span class="line">            <span class="comment"># 左右子节点</span></span><br><span class="line">            left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            <span class="comment"># 假定当前节点最小</span></span><br><span class="line">            minPoint = i</span><br><span class="line">            <span class="comment"># 和当前节点的左右节点比较，如果节点中有更小的数，那么交换，并继续对交换后的节点进行维护</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; k <span class="keyword">and</span> minHeap[left] &lt; minHeap[minPoint]:</span><br><span class="line">                minPoint = left</span><br><span class="line">            <span class="keyword">if</span> right &lt; k <span class="keyword">and</span> minHeap[right] &lt; minHeap[minPoint]:</span><br><span class="line">                minPoint = right</span><br><span class="line">            <span class="comment"># 如果最小的数不是节点i的话，那么交换后，调整节点i的子树。</span></span><br><span class="line">            <span class="keyword">if</span> minPoint != i:</span><br><span class="line">                minHeap[i], minHeap[minPoint] = minHeap[minPoint], minHeap[i]</span><br><span class="line">                minHeapfy(minHeap, minPoint, k)</span><br><span class="line">        <span class="comment"># 初始化 取前k个树，组成最小堆</span></span><br><span class="line">        minHeap = nums[:k]</span><br><span class="line">        <span class="comment"># 对于一个还没维护过的堆，从他的最后一个节点的父节点开始进行调整。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            minHeapfy(minHeap, i, k)</span><br><span class="line">        <span class="comment"># 继续调整后面节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果元素大于堆顶元素，那么取出堆顶元素，将当前元素入堆</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; minHeap[<span class="number">0</span>]:</span><br><span class="line">                minHeap[<span class="number">0</span>] = nums[i]</span><br><span class="line">                minHeapfy(minHeap, <span class="number">0</span>, k)</span><br><span class="line">        <span class="comment"># 最后得到的堆顶，就是我们想要的结果</span></span><br><span class="line">        <span class="keyword">return</span> minHeap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>执行耗时:64 ms,击败了44.82% 的Python3用户<br>内存消耗:15.3 MB,击败了14.45% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] minHeap = Arrays.copyOf(nums, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) minHeap(minHeap, i, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; minHeap[<span class="number">0</span>])&#123;</span><br><span class="line">                minHeap[<span class="number">0</span>] = nums[i];</span><br><span class="line">                minHeap(minHeap, <span class="number">0</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> minPoint = i;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; k &amp;&amp; nums[left] &lt; nums[minPoint]) minPoint = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; k &amp;&amp; nums[right] &lt; nums[minPoint]) minPoint = right;</span><br><span class="line">        <span class="keyword">if</span>(minPoint != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[minPoint];</span><br><span class="line">            nums[minPoint] = tmp;</span><br><span class="line">            minHeap(nums, minPoint, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了99.35% 的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了51.50% 的用户</p><p><strong>方法二：调用内置函数</strong></p><blockquote><p>python可以使用heapq.nlargest 或 heapq.nsmallest，来找出某个集合中找出最大或最小的N个元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[-<span class="number">1</span>]  <span class="comment"># [6,5]</span></span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了91.38% 的Python3用户<br>内存消耗:15.3 MB,击败了14.45% 的Python3用户</p><div class="table-container"><table><thead><tr><th>第347题：前 K 个高频元素</th></tr></thead><tbody><tr><td>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</td></tr></tbody></table></div><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,2,2,3] 和 k = 2</span><br><span class="line">输出: [1, 2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1] 和 k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><blockquote><p>这题也是同样的道理，只是需要先统计各元素出现的次数，然后按照次数的大小为基准加入小顶堆，这里提供Java内置小顶堆函数的用法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; map.get(v1) - map.get(v2));    </span><br><span class="line">        map.forEach((num, cnt) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &lt; k) &#123;</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(minHeap.peek()) &lt; cnt) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) res[i] = minHeap.poll();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：18 ms, 在所有 Java 提交中击败了26.53% 的用户<br>内存消耗：41 MB, 在所有 Java 提交中击败了70.04% 的用户</p><h3 id="22-镜面反射"><a href="#22-镜面反射" class="headerlink" title="22.镜面反射"></a>22.镜面反射</h3><div class="table-container"><table><thead><tr><th>第858题：镜面反射</th></tr></thead><tbody><tr><td>有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为 0，1，以及 2。正方形房间的墙壁长度为 p，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 0 的距离为 q 。返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。</td></tr></tbody></table></div><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： p = 2, q = 1</span><br><span class="line">输出： 2</span><br><span class="line">解释： 这条光线在第一次被反射回左边的墙时就遇到了接收器 2 </span><br></pre></td></tr></table></figure><p>上面的题目绕得很，大概就是这么个意思：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/115.png" alt></p><blockquote><p>我们知道光是由西南角发出的，也就是左下角。发出之后可能会出现多种情况（注意，下图略过了部分光线反射的情况）。看起来是十分复杂，无迹可寻。</p><p>但是如果我们把光线的运动轨迹拆开来看，就可以观测到，<strong>光线每经过一次折反，都会在纵向距离上移动 q</strong>（首次与东墙相距的距离）。同时，<strong>一旦其向上行走的距离为 p 的整数倍，就一定会碰到某个接收点</strong>（<strong>注意：这里我们不需要考虑北面墙是否存在，根据光的反射定律可得</strong>）可以参考一下下面这张图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/116.png" alt></p><p>问题变得简单了，<strong>光线最终向上走的距离，其实就是 p 和 q 的最小公倍数</strong>。我们设最小公倍数为 L，会发现如果 L 是 p 的<strong>奇数倍</strong>，光线则到达<strong>北墙</strong>（可以参考上面的图）当 L 是 p 的 <strong>偶数倍</strong>，光线将会射到<strong>南墙</strong>。</p><p>问题来了，如果光线是射向南墙，因为只有一个接收器了，必定只能遇到接收器 0。但是如果射到了北墙，如何区分是 1 和 2。这回到了一个初中数学题，我们可以通过<strong>光线与东西墙的接触次数，来判断最终的落点是 1 还是 2。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = p, q</span><br><span class="line">        <span class="comment"># 最大公约数</span></span><br><span class="line">        <span class="comment"># 假设x和y的最大公约数是m,最小公倍数是n,则xy=mn</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            r = m % n</span><br><span class="line">            m = n</span><br><span class="line">            n = r</span><br><span class="line">        <span class="comment"># 假设x和y的最大公约数是m,最小公倍数是n,则xy=mn</span></span><br><span class="line">        <span class="comment"># 所以最小公倍数为pq/m</span></span><br><span class="line">        <span class="comment"># 若q/m为偶数则最小公倍数为p的偶数倍，射向南墙</span></span><br><span class="line">        <span class="keyword">if</span> (q / m) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 否则为奇数倍，判断与东西墙的接触次数</span></span><br><span class="line">        <span class="comment"># 若p/m为偶数则最小公倍数为q的偶数倍，落点为2</span></span><br><span class="line">        <span class="keyword">elif</span> (p / m) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="comment"># 否则落点为1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了83.16% 的Python3用户<br>内存消耗:14.9 MB,击败了5.43% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mirrorReflection</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = p, n = q;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q / m % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p / m % <span class="number">2</span> == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：34.9 MB, 在所有 Java 提交中击败了92.59% 的用户</p><h3 id="23-整数转罗马数字"><a href="#23-整数转罗马数字" class="headerlink" title="23.整数转罗马数字"></a>23.整数转罗马数字</h3><div class="table-container"><table><thead><tr><th>第12题：整数转罗马数字</th></tr></thead><tbody><tr><td>罗马数字包含以下七种字符：I， V， X，L，C，D 和 M。</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。27 写做 XXVII， 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p><p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</p><p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><blockquote><p>我们把题目中所有的字符列出来，一些特殊的规则也得列出来。假设我们要找的数为2834，大概的流程如下（其实是一种类似贪心的思想）：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/117.png" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        nums = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        romas = [<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>]</span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= nums[index]:</span><br><span class="line">                result += romas[index]</span><br><span class="line">                num -= nums[index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了88.55% 的Python3用户<br>内存消耗:14.8 MB,击败了5.03% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuffer roman = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：6 ms, 在所有 Java 提交中击败了47.30% 的用户<br>内存消耗：37.8 MB, 在所有 Java 提交中击败了72.05% 的用户</p><h3 id="24-荷兰国旗问题"><a href="#24-荷兰国旗问题" class="headerlink" title="24.荷兰国旗问题"></a>24.荷兰国旗问题</h3><div class="table-container"><table><thead><tr><th>第75题：荷兰国旗问题：现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。</th></tr></thead><tbody><tr><td>这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。</td></tr></tbody></table></div><p>大概就是这么个意思：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/118.png" alt></p><blockquote><p>改成这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/119.png" alt><br>那总共就三个颜色，我们要区分开来，是不是最少需要两条分隔线？A线的左侧为0，右侧为1。B线的左侧为1，右侧为2。</p><p>剩下的是不是只需要把 A线 和 B线 间的数据维护成满足 AB 线的规则就可以了？那要维护 AB 线间的数据，是不是至少你得遍历下 AB 线间的数据？我们从 C 位置处开始。</p><ul><li>1）若遍历到的位置为0，则说明它一定位于A的左侧。于是就和A处的元素交换，同时向右移动A和C。</li><li>2）若遍历到的位置为1，则说明它一定位于AB之间，满足规则，不需要动弹。只需向右移动C。</li><li>3）若遍历到的位置为2，则说明它一定位于B的右侧。于是就和B处的元素交换，交换后只把B向左移动，C仍然指向原位置。（因为交换后的C可能是属于A之前的，所以C仍然指向原位置）</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a = c = <span class="number">0</span></span><br><span class="line">        b = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> c &lt;= b:</span><br><span class="line">            <span class="keyword">if</span> nums[c] == <span class="number">0</span>:</span><br><span class="line">                nums[a], nums[c] = nums[c], nums[a]</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[c] == <span class="number">2</span>:</span><br><span class="line">                nums[c], nums[b] = nums[b], nums[c]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了86.24% 的Python3用户<br>内存消耗:14.9 MB,击败了5.10% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur] &lt; <span class="number">1</span>) swap(nums, ++l, cur++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur] &gt; <span class="number">1</span>) swap(nums, --r, cur);</span><br><span class="line">            <span class="keyword">else</span> cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.8 MB, 在所有 Java 提交中击败了84.85% 的用户</p><h3 id="25-六九问题"><a href="#25-六九问题" class="headerlink" title="25.六九问题"></a>25.六九问题</h3><div class="table-container"><table><thead><tr><th>第1323题：6 和 9 组成的最大数字</th></tr></thead><tbody><tr><td>给你一个仅由数字 6 和 9 组成的正整数 <code>num</code>。</td></tr></tbody></table></div><p>大概就是这么个意思：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/120.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 9669</span><br><span class="line">输出：9969</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">改变第一位数字可以得到 6669 。</span><br><span class="line">改变第二位数字可以得到 9969 。</span><br><span class="line">改变第三位数字可以得到 9699 。</span><br><span class="line">改变第四位数字可以得到 9666 。</span><br><span class="line">其中最大的数字是 9969 。</span><br></pre></td></tr></table></figure><blockquote><p>我们只要找到 num 中最高位的 6，将其翻转成 9，就可以找到答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum69Number</span> (<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(num).replace(<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>执行耗时:60 ms,击败了5.65% 的Python3用户<br>内存消耗:14.7 MB,击败了5.20% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum69Number</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String res = Integer.toString(num);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(res.replaceFirst(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;9&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了37.53% 的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了64.39% 的用户</p><h3 id="26-有效的数独"><a href="#26-有效的数独" class="headerlink" title="26.有效的数独"></a>26.有效的数独</h3><div class="table-container"><table><thead><tr><th>第36题：有效的数独</th></tr></thead><tbody><tr><td>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</td></tr></tbody></table></div><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line"></span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line"></span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">数独部分空格内已填入了数字，空白格用 &#x27;.&#x27; 表示。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p><strong>一个有效的数独（部分已被填充）不一定是可解的。</strong></p><p>只需要根据以上规则，验证已经填入的数字是否有效即可。</p><p>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</p><p>给定数独永远是 9x9 形式的。</p><p>画出来就是下面这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/121.png" alt></p><blockquote><p>我们要做的就是<strong>用程序来完成这个验证的过程</strong>，如何验证？那其实就两步：</p><ul><li>第一步：遍历数独中的每一个元素</li><li>第二步：验证该元素是否满足上述条件</li></ul><p>遍历这个没什么好说的，<strong>从左到右，从上到下进行遍历即可</strong>。就一个两层循环。因为题目本身就是常数级的规模，所以时间复杂度就是 O(1)。</p><p>问题来了：如何验证元素在 行 / 列 / 子数独中没有重复项？</p><p>其实很简单，我们建立三个数组分别记录每行，每列，每个子数独（子数独就是上面各种颜色的小框框）中出现的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span>[][] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span>[][] sbox = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br></pre></td></tr></table></figure><p>当然，刚开始的时候他们都是空的。然后<strong>每遍历到一个元素，我们就看看这个元素在里边存不存在，不存在就放进去，存在那说明数独不合法。</strong></p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/122.png" alt></p><p>比如这个数独。第6行5列为2，那我们就对 rows 和 col 进行设置：（1表示元素存在)<br> rows[当前行-1][当前元素值-1] = rows[6-1][2-1] = 1<br> col[当前列-1][当前元素值-1] = col[5-1][2-1] = 1</p><p>现在的题是，对于 sbox 该如何设置呢？我们用下面的公式来计算得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxIndex = (row / 3) * 3 + columns / 3</span><br></pre></td></tr></table></figure><p>其实很容易理解：我们把上面的第6行5列代入到这个公式里，(5 / 3) * 3 + 4 / 3 = 3 + 1 = 4。这个 4 也就代表最终落到 4 的这个小区域中。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/123.png" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        rows = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        cols = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        sbox = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    num = <span class="built_in">int</span>(board[i][j]) - <span class="number">1</span></span><br><span class="line">                    boxIndex = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                    <span class="keyword">if</span> rows[i][num] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    rows[i][num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> cols[j][num] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    cols[j][num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> sbox[boxIndex][num] == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    sbox[boxIndex][num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>执行耗时:56 ms,击败了46.19% 的Python3用户<br>内存消耗:14.9 MB,击败了5.10% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] sbox = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> boxIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span>(rows[i][num] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    rows[i][num] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(col[j][num] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    col[j][num] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(sbox[boxIndex][num] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    sbox[boxIndex][num] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了94.35% 的用户<br>内存消耗：38.5 MB, 在所有 Java 提交中击败了55.46% 的用户</p><h3 id="27-费米估算"><a href="#27-费米估算" class="headerlink" title="27.费米估算"></a>27.费米估算</h3><div class="table-container"><table><thead><tr><th>问题：北京有多少加油站？</th></tr></thead><tbody><tr><td>对的，你没看错，这就是原题。。。</td></tr></tbody></table></div><blockquote><p>截止到2019年，北京共有1063个加油站</p><p>这道题目主要考察人的估算能力。而估算界，有一个估算大牛叫做费米。</p><p>费米估算，其实说白了就是将<strong>正确答案，转化为一系列估算变量的乘法</strong>。首先要把变量选的准确，其次要把变量估的准确。回到本题，我们要分析的问题是：北京有多少加油站？</p><p>那我们至少得有多少辆车吧？但是并不是所有的车，每天都会上路。所以准确的说我们需要知道每天上路的车有多少。</p><p>但是是所有上路的车都需要加油吗？当然不是，所以我们还得改改：每天上路需要加油的车有多少？</p><p>知道了每天上路需要加油的车辆数，我们得知道每个加油站可以满足多少辆车吧？</p><p>那加油站用什么满足车？自然是油咯。</p><p>问题来了，那我们如何知道每天上路需要加油的车辆数？是不是我们可以转化为 北京车辆总数 / 加油频次。</p><p>这个加油频次，相信大家就很容易估算出来了。跑滴滴的一天一次油，正常开的话一周一次，开的少一点的话差不多半个月一次。</p><p>① 每天上路需要加油的车辆数 ② 每个加油站的容量</p><p>所以我们只要回答出上面两个参数，再给出计算公式。就可以很完美的解答本题了！</p></blockquote><h3 id="28-分发饼干"><a href="#28-分发饼干" class="headerlink" title="28.分发饼干"></a>28.分发饼干</h3><div class="table-container"><table><thead><tr><th>题目455：分发饼干</th></tr></thead><tbody><tr><td>假设你是一位很棒（多棒？？？）的家长，想要给你的孩子们一些小饼干（不能给大饼干吗？？？）但是，每个孩子最多只能给一块饼干（有毒吧。。。）</td></tr></tbody></table></div><p>对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>注意：你可以假设胃口值为正（特么不正难道往外吐吗？？？）。一个小朋友最多只能拥有一块饼干。</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3], [1,1] </span><br><span class="line">输出: 1 </span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。 </span><br></pre></td></tr></table></figure><blockquote><p>其实策略就很简单了：<strong>我们只需要在满足孩子胃口的前提下，尽可能分配小的饼干给到他</strong>。</p><p>具体怎么做呢，我们把饼干和小朋友都按照<strong>从大到小</strong>排列。</p><ul><li>如果最大的饼干可以满足肚子最大的孩子，那就给他吃，同时比较下一个。</li><li>如果最大的饼干不能满足肚子最大的孩子，<strong>那就让他饿着</strong>，然后看看能不能满足第二个孩子。（有点黑暗系，<strong>放弃小朋友</strong>）</li></ul><p>但是这里有个问题。凭什么就要先满足肚子最大的孩子。按道理讲，肚子越大应该越扛饿才对吧。所以我们换种思路，从<strong>肚子最小的孩子</strong>开始。</p><ul><li>如果最小的饼干可以满足肚子最小的孩子，那就给他吃，同时比较下一个。</li><li>如果最小的饼干不能满足肚子最小的孩子，<strong>那就扔掉饼干</strong>，看看下一个饼干能不能给他吃。（<strong>放弃的是饼干</strong>）</li></ul><p>那这两种其实都算是贪心：</p><ul><li>一种是胃口太大轮到下一个孩子</li><li>一种是饼干太小轮到下一个饼干</li></ul><p>因为要同时控制饼干和小孩，所以我们采用双指针。这里给出先满足小肚子孩子的代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        gi, si = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> gi &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> si &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> g[gi] &lt;= s[si]:</span><br><span class="line">                gi+=<span class="number">1</span></span><br><span class="line">            si+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> gi</span><br></pre></td></tr></table></figure><p>执行耗时:60 ms,击败了92.10% 的Python3用户<br>内存消耗:16.1 MB,击败了5.14% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> ch = <span class="number">0</span>, bis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch &lt; g.length &amp;&amp; bis &lt; s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[ch] &lt;= s[bis]) ch++;</span><br><span class="line">            bis++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：9 ms, 在所有 Java 提交中击败了21.24% 的用户<br>内存消耗：39.2 MB, 在所有 Java 提交中击败了50.44% 的用户</p><h3 id="29-生命游戏"><a href="#29-生命游戏" class="headerlink" title="29.生命游戏"></a>29.生命游戏</h3><div class="table-container"><table><thead><tr><th>第289题：生命游戏</th></tr></thead><tbody><tr><td>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。</td></tr></tbody></table></div><p>每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ul><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ul><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>题目有点复杂，举例说明：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/124.png" alt></p><p>注意：<strong>面板上所有格子需要同时被更新</strong>：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</p><blockquote><p>最自然的想法是：一个个的更新细胞状态。</p><p><strong>已更新细胞的状态会影响到周围其他还未更新细胞状态的计算</strong>。这明显不是我们想要的！</p><p>那我们最简单的思路：是不是只要我们能一直获取原始数组的数据，不就可以保证更新一直正确了吗！至于在哪里，其实不管是copy一个数组，还是说用hashmap存一下数值其实都ok。</p></blockquote><p><strong>方法一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 每个细胞统周围八个相邻位置的偏移量</span></span><br><span class="line">        neighbors = [<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 创建复制数组 copyBoard</span></span><br><span class="line">        <span class="comment"># 注意直接用切片的方式或者list()方式是浅复制，被坑了好久。。。</span></span><br><span class="line">        copyBoard = [[<span class="number">0</span>] * <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                copyBoard[i][j] = board[i][j]</span><br><span class="line">        <span class="comment"># 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                liveNeighbors = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">if</span> neighbors[i] != <span class="number">0</span> <span class="keyword">or</span> neighbors[j] != <span class="number">0</span>:</span><br><span class="line">                            r = row + neighbors[i]</span><br><span class="line">                            c = col + neighbors[j]</span><br><span class="line">                            <span class="comment"># 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> r &lt; <span class="built_in">len</span>(board) <span class="keyword">and</span> r &gt;= <span class="number">0</span> <span class="keyword">and</span> c &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">and</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> copyBoard[r][c] == <span class="number">1</span>:</span><br><span class="line">                                liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 规则 1 或规则 3</span></span><br><span class="line">                <span class="keyword">if</span> copyBoard[row][col] == <span class="number">1</span> <span class="keyword">and</span> (liveNeighbors &lt; <span class="number">2</span> <span class="keyword">or</span> liveNeighbors &gt; <span class="number">3</span>):</span><br><span class="line">                    board[row][col] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> copyBoard[row][col] == <span class="number">0</span> <span class="keyword">and</span> liveNeighbors == <span class="number">3</span>:</span><br><span class="line">                    board[row][col] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了71.15% 的Python3用户<br>内存消耗:14.8 MB,击败了7.69% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] neighbors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] copyBoard = <span class="keyword">new</span> <span class="keyword">int</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                copyBoard[i][j] = board[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].length; col++)&#123;</span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(neighbors[i] != <span class="number">0</span> || neighbors[j] != <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">int</span> r = row + neighbors[i];</span><br><span class="line">                            <span class="keyword">int</span> c = col + neighbors[j];</span><br><span class="line">                            <span class="keyword">if</span>(r &lt; board.length &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; board[<span class="number">0</span>].length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; copyBoard[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                                liveNeighbors++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(copyBoard[row][col] == <span class="number">1</span> &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) board[row][col] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(copyBoard[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) board[row][col] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.8 MB, 在所有 Java 提交中击败了53.60% 的用户</p><p><strong>方法二</strong></p><blockquote><p><strong>你不就想既可以保存原数组的状态，还可以更新新的状态吗？这些统统都可以在原有数组上搞</strong>。具体怎么搞呢？</p><ul><li>原来的 0 和 1 不就是代表死和生吗？但是你要更新新的状态，无非就是从生-&gt;死，从死-&gt;生。那我们加个状态 2，代表 生-&gt;死，加个状态 3 表示从 死&gt;生。</li><li>对于一个节点来说，如果它周边的点是 1 或者 2，就说明该点上一轮是活的。</li><li>整体策略是完成 原始状态-&gt;过渡状态-&gt;真实状态 的过程。</li><li>过渡状态 到 真实状态，代码就是把 0 和 2 变回 0，1 和 3 变回1的过程。用模只是代码技巧。</li><li>策略实现的第一步是先找到当前节点周围的存活节点数。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment">#  原始状态 -&gt; 过渡状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                liveNeighbors = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 判断上边</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i - <span class="number">1</span>][j] == <span class="number">1</span> <span class="keyword">or</span> board[i - <span class="number">1</span>][j] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断左边</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i][j - <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i][j - <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断下边</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(board) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i + <span class="number">1</span>][j] == <span class="number">1</span> <span class="keyword">or</span> board[i + <span class="number">1</span>][j] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断右边</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i][j + <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i][j + <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断左上角</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断右下角</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(board) - <span class="number">1</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i + <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i + <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断右上角</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i - <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i - <span class="number">1</span>][j + <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断左下角</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(board) - <span class="number">1</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> board[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">2</span>:</span><br><span class="line">                        liveNeighbors += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 根据周边存活数量更新当前点，结果是 0 和 1 的情况不用更新</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> liveNeighbors == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">3</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> (liveNeighbors &lt; <span class="number">2</span> <span class="keyword">or</span> liveNeighbors &gt; <span class="number">3</span>):</span><br><span class="line">                    board[i][j] = <span class="number">2</span></span><br><span class="line">        <span class="comment"># 过渡状态 -&gt; 真实状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                board[i][j] = board[i][j] % <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行耗时:52 ms,击败了15.25% 的Python3用户<br>内存消耗:14.7 MB,击败了7.69% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (board[i-<span class="number">1</span>][j] == <span class="number">1</span> || board[i-<span class="number">1</span>][j] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; (board[i][j-<span class="number">1</span>] == <span class="number">1</span> || board[i][j-<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; board.length-<span class="number">1</span> &amp;&amp; (board[i+<span class="number">1</span>][j] == <span class="number">1</span> || board[i+<span class="number">1</span>][j] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; (board[i][j+<span class="number">1</span>] == <span class="number">1</span> || board[i][j+<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; (board[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span> || board[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; board.length-<span class="number">1</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; (board[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="number">1</span> || board[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; (board[i-<span class="number">1</span>][j+<span class="number">1</span>] == <span class="number">1</span> || board[i-<span class="number">1</span>][j+<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; board.length-<span class="number">1</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; (board[i+<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">1</span> || board[i+<span class="number">1</span>][j-<span class="number">1</span>] == <span class="number">2</span>)) liveNeighbors++;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) board[i][j] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) board[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) board[i][j] %= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.5 MB, 在所有 Java 提交中击败了93.77% 的用户</p><h3 id="30-搜索二维矩阵"><a href="#30-搜索二维矩阵" class="headerlink" title="30.搜索二维矩阵"></a>30.搜索二维矩阵</h3><div class="table-container"><table><thead><tr><th>第74题：搜索二维矩阵</th></tr></thead><tbody><tr><td>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。</td></tr></tbody></table></div><p>该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><blockquote><p>第一个条件意味着可以通过二分搜索确定哪行；</p><p>第二个条件意味着可以在行里进行二分搜索确定哪个元素；</p></blockquote><p><strong>方法一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> <span class="keyword">or</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> target &gt; matrix[-<span class="number">1</span>][-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 二分法找到target所在的行</span></span><br><span class="line">        top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> top &lt; bottom:</span><br><span class="line">            mid = top + (bottom - top) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][-<span class="number">1</span>] &lt; target:</span><br><span class="line">                top = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bottom = mid</span><br><span class="line">        <span class="comment"># 在行里进行二分搜索确定哪个元素</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(matrix[top]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[top][mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[top][mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了87.44% 的Python3用户<br>内存消耗:15 MB,击败了5.38% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> || col == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[row-<span class="number">1</span>][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = row;</span><br><span class="line">        <span class="keyword">while</span>(top &lt; bottom)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (bottom + top) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][col-<span class="number">1</span>] &lt; target) top = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> bottom = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = col;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[top][mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[top][left] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.6 MB, 在所有 Java 提交中击败了94.20% 的用户</p><p><strong>方法二</strong></p><blockquote><p>根据题目特性直接将数组拉平，当作一个一维数组的二分查找</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> <span class="keyword">or</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> target &gt; matrix[-<span class="number">1</span>][-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 根据题目特性直接将数组拉平，当作一个一维数组的二分查找</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = m * n</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            i = mid // n</span><br><span class="line">            j = mid % n</span><br><span class="line">            <span class="keyword">if</span> target == matrix[i][j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; matrix[i][j]:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了96.26% 的Python3用户<br>内存消耗:15.1 MB,击败了5.38% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> || col == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[row-<span class="number">1</span>][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = row * col;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / col][mid % col] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[l / col][l % col] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：37.5 MB, 在所有 Java 提交中击败了95.90% 的用户</p><h3 id="31-子集"><a href="#31-子集" class="headerlink" title="31.子集"></a>31.子集</h3><div class="table-container"><table><thead><tr><th>第78题：子集</th></tr></thead><tbody><tr><td>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</td></tr></tbody></table></div><p><strong>说明：</strong> 解集不能包含重复的子集</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3] </span><br><span class="line"></span><br><span class="line">输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] </span><br></pre></td></tr></table></figure><blockquote><p>首先我们可以证明一下 N 个元素的子集个数有 2^N 个</p><p>可以类比为 N 个不同的小球，一次拿出若干个小球（可以不拿），对于每一个球都可以选择拿或者不拿，共有 N 个球，总共判断 N 次，产生了 2^N 个子集。</p><p><strong>我们其实可以用二进制来模拟每个元素是否选中的状态。</strong> 又因为我们已知了对于 N 个元素共有 2^N 个子集，所以我们直接遍历 2^N 个元素。</p><p>但是我们并不知道具体的子集元素。那如何找到对应的子集元素呢？<strong>对于 2^N 个 N 位的二进制数，我们可以通过从后往前的第 j 个二进制位的 0 和 1 来表示是否放入子集集合。</strong></p></blockquote><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        k = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="comment"># 子集总数共有 2^N 个</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; k):</span><br><span class="line">            <span class="comment"># 找到对应的子集元素</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="comment"># 对于 2^N 个 N 位的二进制数，我们可以通过从后往前的第 j 个二进制位的 0 和 1 来表示是否放入子集集合。</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                <span class="keyword">if</span> i &gt;&gt; j &amp; <span class="number">1</span>:</span><br><span class="line">                    temp.append(nums[j])</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:40 ms,击败了66.14% 的Python3用户<br>内存消耗:14.9 MB,击败了5.37% 的Python3用户</p><p>为帮助大家理解，假设 nums 为 [1,2,3]，res 的存储过程为：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/125.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) != <span class="number">0</span>) tmp.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了87.14% 的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了75.78% 的用户</p><p><strong>方法二：</strong></p><blockquote><p>直接遍历，遇到一个数就把所有子集加上该数组成新的子集</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> subres <span class="keyword">in</span> res[:]: res.append(subres + [nums[i]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了40.73% 的Python3用户<br>内存消耗:14.9 MB,击败了5.37% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> all = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; all; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                res.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了87.14% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了63.70% 的用户</p><p><strong>方法三：</strong></p><blockquote><p>集合中所有元素的选/不选，其实构成了一个满二叉树。左子树选，右子树不选。自然，那从根节点到所有叶子节点的路径，就构成了所有的子集。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/126.png" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, tmp</span>):</span></span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                dfs(j + <span class="number">1</span>, tmp + [nums[j]])</span><br><span class="line">        dfs(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了40.73% 的Python3用户<br>内存消耗:14.9 MB,击败了5.37% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, nums, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; new_tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(tmp);</span><br><span class="line">            new_tmp.add(nums[i]);</span><br><span class="line">            dfs(i + <span class="number">1</span>, nums, new_tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了87.14% 的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了73.80% 的用户</p><h3 id="32-量出4升水"><a href="#32-量出4升水" class="headerlink" title="32.量出4升水"></a>32.量出4升水</h3><div class="table-container"><table><thead><tr><th>题目：量出4升水</th></tr></thead><tbody><tr><td>怎么用3升和5升的桶量出4升的水？</td></tr></tbody></table></div><p>题目没什么补充的，直接分析，一个3升和5升的水桶：</p><p>首先用三升水桶装满水，倒入五升水桶：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/127.png" alt></p><p>再次倒满三升水桶，填满后继续倒入五升水桶，直到五升水桶倒满。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/128.png" alt></p><p>清空五升水桶，将三升水桶的一升水倒入：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/129.png" alt></p><p>再次填满三升水桶，倒入五升水桶中：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/130.png" alt></p><h3 id="33-最大的钻石"><a href="#33-最大的钻石" class="headerlink" title="33.最大的钻石"></a>33.最大的钻石</h3><div class="table-container"><table><thead><tr><th>题目：最大的钻石</th></tr></thead><tbody><tr><td>1 楼到 n 楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从 1 楼到 n 楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到「最大」的一颗？</td></tr></tbody></table></div><blockquote><p>面试时如果被问到这种题目，其实大多数面试官心中并没有一个标准答案。（不排除有面试官深究的）事实是作为面试者，我们只要流畅的给出答案，大概率都是可以顺利过关。</p><p>回到题目。其实题中包含一个隐藏条件：<strong>随机放置</strong>。所有的分析都是基于随机放置给出的。<strong>换句话说，如果放置钻石是人为干预大小，那么本题的所以分析则全部不成立</strong>。</p><p>其实这个问题的原型叫做秘书问题，该类问题全部属于<strong>最佳停止问题</strong>。</p><p>这类问题都有着统一的解法：</p><p><strong>我们要选择先放弃前 37%（就是1/e）的钻石，此后选择比前 37% 都大的第一颗钻石。</strong></p><p>其实该法则还有很多运用，比如一些常见的推文《谈恋爱拒绝掉前面37%的人》，其实就是一样的原因。</p><p>改题目还有一些变种，比如：</p><p>一个活动，n个女生手里拿着长短不一的玫瑰花，无序的排成一排，一个男生从头走到尾，试图拿更长的玫瑰花，一旦拿了一朵就不能再拿其他的，错过了就不能回头，问最好的策略?</p><p>现在要聘请 1 名秘书，共有 n 个应聘者，每面试 1 人后，就知道了应聘者的好坏程度，且必须立刻决定是否聘用，不可重复面试。策略是拒绝前 k 个应聘者，而从第 k+1 个应聘者开始，一旦有比前 k 个都好的，就立刻聘用。如何决定 k 的值，使得聘用到最佳应聘者的概率最大？等等。</p><p>这里再给出一个严谨的推导过程：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/131.png" alt></p></blockquote><h3 id="34-思维定势"><a href="#34-思维定势" class="headerlink" title="34.思维定势"></a>34.思维定势</h3><blockquote><p>下面这道题也是一道常见的智力题，但是这道题绝对不会出现在面试中了。拿出来分享给大家的原因，是期望不要被思维定势局限。</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/132.png" alt></p><p>这道题中有六个停车位，每个车位上都有一个数字，然而有一个车位上的数字被汽车挡住了，要求学生们在20秒内答出这个被挡住的车位上的数字。这是中国香港小学一道给6岁儿童设计的“停车场智力题”。</p><blockquote><p>答案：L8，即87</p></blockquote><h3 id="35-图的基础知识"><a href="#35-图的基础知识" class="headerlink" title="35.图的基础知识"></a>35.图的基础知识</h3><blockquote><p>图（Graph）是表示物件与物件之间的关系的数学对象，是图论的基本研究对象。</p></blockquote><p>图是一个比树形关系复杂一点点，比线性关系复杂两点点的东东。</p><ul><li>线性关系是一对一：一个前驱一个后继。</li><li>树形结构是一对多：一个父多个子</li><li>图形结构是多对多：任意两个顶点（图中的节点叫做顶点）都有可能相关，是一种多对多的关系。</li></ul><p>图我们一般表示为 G = (V，E)</p><ul><li>V：代表点</li><li>E：代表边</li></ul><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/133.png" alt></p><p>啥意思嘞，比如就上面那个绿油油的图，就可以表示为:</p><ul><li>V={1,2,3,4,5,6}</li><li>E={(1,2),(1,5),(2,3),(2,5),(3,4),(4,5),(4,6)}</li></ul><p>图里最基本的单元是顶点（vertex），相当于树中的节点。顶点之间的关联关系，被称为边（edge）。而边可以分配一个数值（正负都ok），这个数值就叫做权重。</p><p><strong>无向图和有向图</strong></p><p>有方向的图就是有向图，无方向的图就是无向图。</p><p><strong>完全图</strong></p><p>所有的顶点互相连接在一起，那就是完全图。</p><p>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图。大概就是这样：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/134.png" alt></p><p>而在有向图中，若每对顶点之间都有二条有向边相互连接，也算是完全图。</p><p><strong>循环图和DAG</strong></p><p>循环图中的循环二字，指的是<strong>起点和终点是同一节点时</strong>产生的路径。所以，<strong>循环图和有向图或无向图并没有什么关系，因为都有可能产生循环</strong>。有向图，那就遵循边的方向。无向图，那只要成环就行。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/135.png" alt></p><p>这三个：</p><ul><li>第一个就是无向循环图</li><li>第二个就是有向非循环图</li><li>第三个就是有向循环图</li></ul><p>第二个更多的是被称为有向无环图DAG（Directed Acyclic Graph）。下面这个也是 ：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/136.png" alt></p><p>那上面这个像不像一棵树。。。。。所以计算机结构中的树（大多都是有向的），其实就是一个DAG。</p><p><strong>加权图</strong></p><blockquote><p> 用数学语言讲，设G为图，对图的每一条边e来说，都对应于一个实数W(e)（可以通俗的理解为边的“长度”，只是在数学定义中图的权可以为负数），我们把W(e)称为e的“权”。把这样的图G称为“加权图”。</p></blockquote><p>但是这里如果细分的话，又分为<strong>顶点加权图和边加权图。</strong> 说白了，就是有人发现如果只给边加上权值（就是长度）并不够用，有时候也需要给顶点加上权值。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/137.jpg" alt></p><p><strong>连通图</strong></p><blockquote><p>在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。</p></blockquote><p>连通的图，就是连通图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/138.png" alt></p><p>如果不通了，就是非连通图：（这是一个图）</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/139.png" alt></p><p>那没有连通在一起的这两坨（或者说移动的这两坨），我们叫作<strong>岛</strong>。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/140.png" alt></p><p>所以，如果我们的图里包含岛，那就是非连通图。</p><p><strong>稠密图和稀疏图</strong></p><p>如何定义稠密和稀疏？<strong>梵蒂冈也有人觉得他们的圣彼得大教堂拥挤</strong>，所以稠密稀疏本身就是一个主观定义。</p><p>我们可以简单的认为，稀疏图的边数远远少于完全图，反之，稠密图的边数接近于或等于完全图。</p><h3 id="36-旋转图像"><a href="#36-旋转图像" class="headerlink" title="36.旋转图像"></a>36.旋转图像</h3><div class="table-container"><table><thead><tr><th>第48题：旋转图像</th></tr></thead><tbody><tr><td>给定一个 n × n 的二维矩阵表示一个图像。</td></tr></tbody></table></div><p><strong>说明：</strong></p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>方法一</strong></p><blockquote><p>一般容易想到的是，一层层的从外到内旋转每一圈（至于为什么不从内到外，如果你觉得方便，也ok），也就是俗称的找框框。</p><p>对每个框框，其实都有 4 个顶点：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/141.png" alt><br>交换完毕之后，再继续交换移动后的四个顶点：<br><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/142.png" alt><br>那代码实现其实就很简单了：</p><ul><li>我们通过 x 和 y 就可以定义这个框框的边界</li><li>找到框框后，我们再通过框框边界来定义出4个顶点</li><li>然后完成交换</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从最外圈开始到最内圈</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; y:</span><br><span class="line">            s = x</span><br><span class="line">            e = y</span><br><span class="line">            <span class="comment"># 每一圈每轮换4个顶点</span></span><br><span class="line">            <span class="keyword">while</span> s &lt; y:</span><br><span class="line">                matrix[x][s], matrix[e][x], matrix[y][e], matrix[s][y] \</span><br><span class="line">                    = matrix[e][x], matrix[y][e], matrix[s][y], matrix[x][s]</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                e -= <span class="number">1</span></span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><p>执行耗时:36 ms,击败了81.13% 的Python3用户<br>内存消耗:14.8 MB,击败了38.77% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = x, e = y;</span><br><span class="line">            <span class="keyword">while</span>(s &lt; y)&#123;</span><br><span class="line">                swap(matrix, x, s, e, x);</span><br><span class="line">                swap(matrix, e, x, y, e);</span><br><span class="line">                swap(matrix, y, e, s, y);</span><br><span class="line">                s++;</span><br><span class="line">                e--;</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = matrix[x1][y1];</span><br><span class="line">        matrix[x1][y1] = matrix[x2][y2];</span><br><span class="line">        matrix[x2][y2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了26.87% 的用户</p><p><strong>方法二</strong></p><blockquote><p>我们观察这个矩阵，向右旋转90°，是不是可以理解为<strong>先上下翻转，再沿对角线翻转</strong>：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/143.png" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 上下翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)//<span class="number">2</span>):</span><br><span class="line">            matrix[i], matrix[<span class="built_in">len</span>(matrix)-i-<span class="number">1</span>] = matrix[<span class="built_in">len</span>(matrix)-i-<span class="number">1</span>], matrix[i]</span><br><span class="line">        <span class="comment"># 对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><p>执行耗时:32 ms,击败了93.70% 的Python3用户<br>内存消耗:14.8 MB,击败了34.93% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp = matrix[i];</span><br><span class="line">            matrix[i] = matrix[matrix.length - i - <span class="number">1</span>];</span><br><span class="line">            matrix[matrix.length - i - <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了22.51% 的用户</p><h3 id="37-螺旋矩阵II"><a href="#37-螺旋矩阵II" class="headerlink" title="37.螺旋矩阵II"></a>37.螺旋矩阵II</h3><div class="table-container"><table><thead><tr><th>第59题：螺旋矩阵Ⅱ</th></tr></thead><tbody><tr><td>给定一个正整数 n，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</td></tr></tbody></table></div><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</span><br></pre></td></tr></table></figure><p>题目理解较为容易，给定 n = 3，那就生成一个 3^2 = 9 的矩阵。大家看下面的图可能更加直观一些：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/144.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        x, y = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从外圈到里圈</span></span><br><span class="line">        <span class="keyword">while</span> x &lt;= y:</span><br><span class="line">            <span class="comment"># 向右取</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(x, y + <span class="number">1</span>):</span><br><span class="line">                res[x][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 向下取</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x + <span class="number">1</span>, y + <span class="number">1</span>):</span><br><span class="line">                res[i][y] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 向左取</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y - <span class="number">1</span>, x - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[y][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 向上取</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y - <span class="number">1</span>, x, -<span class="number">1</span>):</span><br><span class="line">                res[i][x] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>执行耗时:44 ms,击败了33.33% 的Python3用户<br>内存消耗:14.7 MB,击败了22.80% 的Python3用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= y)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = x; j &lt;= y; j++) res[x][j] = count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= y; i++) res[i][y] = count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = y - <span class="number">1</span>; j &gt;= x; j--) res[y][j] = count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = y - <span class="number">1</span>; i &gt; x; i--) res[i][x] = count++;</span><br><span class="line">            x++;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户<br>内存消耗：36.6 MB, 在所有 Java 提交中击败了32.38% 的用户</p><h2 id="排序系列-1"><a href="#排序系列-1" class="headerlink" title="排序系列"></a>排序系列</h2><h3 id="1-排序专栏"><a href="#1-排序专栏" class="headerlink" title="1.排序专栏"></a>1.排序专栏</h3><p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。是《数据结构与算法》中最基本的算法之一。</p><blockquote><p>我们常说的十大排序算法为：冒泡、选择、插入、希尔、归并、快速、堆、计数、桶、基数</p></blockquote><p><strong>基本分类</strong><br>我们常根据是否可以在线性时间内比较对其分类：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/145.png" alt></p><p><strong>时间复杂度</strong></p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/146.png" alt></p><p><strong>如何记忆时间复杂度呢？</strong></p><ol><li>平方阶 (O(n2)) 插入、选择、冒泡</li><li>线性对数阶 (O(nlog2n)) 快速、归并、堆</li><li>特殊的希尔 O(n^(1.3—2))</li><li>牛皮的线性 基数、桶、箱、计数</li></ol><p><strong>啥是稳定：</strong></p><p>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。<br>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>哪些稳定：</strong></p><p>稳定：冒泡、插入、归并和基数。 不稳定：选择、快速、希尔、堆。</p><h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h3><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p><blockquote><p>算法步骤</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>最慢和最快</li></ol></blockquote><p>正序时最快，反序时最慢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">    	flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag: <span class="keyword">break</span> </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; arr.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3.基数排序"></a>3.基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><blockquote><p>基数排序 vs 计数排序 vs 桶排序</p></blockquote><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><blockquote><p> LSD 基数排序动图演示</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/147.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix</span>(<span class="params">arr</span>):</span></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    max_digit = <span class="number">1</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment"># 找出列表中最大的位数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span>**max_digit &lt; max_value:</span><br><span class="line">        max_digit = max_digit + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">while</span> digit &lt; max_digit:</span><br><span class="line">        <span class="comment"># 创建桶</span></span><br><span class="line">        temp = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment"># 求出每一个元素的个、十、百位直到最高位的值</span></span><br><span class="line">            t = <span class="built_in">int</span>((i/<span class="number">10</span>**digit)%<span class="number">10</span>)</span><br><span class="line">            <span class="comment"># 添加进相应的桶中</span></span><br><span class="line">            temp[t].append(i)</span><br><span class="line">        <span class="comment"># 将桶中的数据依次取出</span></span><br><span class="line">        coll = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">                coll.append(i)</span><br><span class="line">        <span class="comment"># 作为下次装桶的数据        </span></span><br><span class="line">        arr = coll</span><br><span class="line">        <span class="comment"># 直到遍历完所有位</span></span><br><span class="line">        digit = digit + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            List&lt;Integer&gt;[] counter = <span class="keyword">new</span> List[mod * <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 求每位的余数，并加10，使得负数映射到0-9，正数映射到10-19</span></span><br><span class="line">                <span class="keyword">int</span> bucket = (arr[j] / dev % mod) + mod;</span><br><span class="line">                <span class="keyword">if</span>(counter[bucket] == <span class="keyword">null</span>) counter[bucket] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                counter[bucket].add(arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将桶中的数按顺序取出，进行下一位的排序</span></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">if</span>(bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                        arr[pos++] = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">5</span>, -<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(radixSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><blockquote><p>算法步骤</p></blockquote><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 记录最小数的索引</span></span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        <span class="comment"># i 不是最小数时，将 i 和最小数进行交换</span></span><br><span class="line">        <span class="keyword">if</span> i != minIndex:</span><br><span class="line">            arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minPos = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                minPos = arr[j] &lt; arr[minPos]? j: minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[minPos];</span><br><span class="line">            arr[minPos] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5.插入排序"></a>5.插入排序</h3><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><blockquote><p>算法步骤</p></blockquote><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        preIndex = i-<span class="number">1</span></span><br><span class="line">        current = arr[i]</span><br><span class="line">        <span class="keyword">while</span> preIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[preIndex] &gt; current:</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex]</span><br><span class="line">            preIndex-=<span class="number">1</span></span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp =  arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i) arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        insertionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h3><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>希尔排序过程</strong><br>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。<br> 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p> 然后我们对每列进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p> 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p> 排序之后变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><br> 最后以1步长进行排序（此时就是简单的插入排序了）</p><p> <strong>希尔排序的分析</strong></p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/148.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(gap &lt; <span class="built_in">len</span>(arr)/<span class="number">3</span>):</span><br><span class="line">        gap = gap*<span class="number">3</span>+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 按步长进行划分</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 对每列进行插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j - gap] &gt; arr[j]:</span><br><span class="line">                arr[j - gap], arr[j] = arr[j], arr[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &lt; arr.length/<span class="number">3</span>) &#123;</span><br><span class="line">            gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=gap; i &lt; arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - gap;</span><br><span class="line">                <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp)&#123;</span><br><span class="line">                    arr[j+gap] = arr[j];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+gap] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p><blockquote><p>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.</p><p>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p></blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><blockquote><p>算法步骤</p></blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><blockquote><p>动图演示</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/149.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    num = <span class="built_in">len</span>(alist)//<span class="number">2</span></span><br><span class="line">    left = mergeSort(alist[:num])</span><br><span class="line">    right = mergeSort(alist[num:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> r&lt;<span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = arr.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = mergeSort(Arrays.copyOfRange(arr, <span class="number">0</span>, middle));</span><br><span class="line">        <span class="keyword">int</span>[] right = mergeSort(Arrays.copyOfRange(arr, middle, arr.length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; left.length &amp;&amp; r &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[l] &lt;= right[r]) result[i++] = left[l++];</span><br><span class="line">            <span class="keyword">else</span> result[i++] = right[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; left.length) result[i++] = left[l++];</span><br><span class="line">        <span class="keyword">while</span> (r &lt; right.length) result[i++] = right[r++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(mergeSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h3><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p><p>算法步骤</p></blockquote><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><blockquote><p>动图演示</p></blockquote><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/150.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">alist, start, end</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 递归的退出条件</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line">    <span class="comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line">    <span class="comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line">        <span class="comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    <span class="comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, end)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//设定基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> low = start;</span><br><span class="line">        <span class="keyword">int</span> high = end;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        quickSort(arr, start, low - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, low + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span> ,<span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> QuickSort().quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sout: [1, 2, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h3 id="9-堆排序"><a href="#9-堆排序" class="headerlink" title="9.堆排序"></a>9.堆排序</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><blockquote><p>算法步骤</p></blockquote><ol><li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/151.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="comment">#大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">arr, i, length</span>):</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    maxIndex = i</span><br><span class="line">    <span class="keyword">if</span> left &lt; length <span class="keyword">and</span> arr[left] &gt; arr[maxIndex]:</span><br><span class="line">        maxIndex = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; length <span class="keyword">and</span> arr[right] &gt; arr[maxIndex]:</span><br><span class="line">        maxIndex = right</span><br><span class="line">    <span class="keyword">if</span> maxIndex != i:</span><br><span class="line">        arr[i], arr[maxIndex] = arr[maxIndex], arr[i]</span><br><span class="line">        heapify(arr, maxIndex, length)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 初始化大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) // <span class="number">2</span> - <span class="number">1</span> , -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, i, n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 根节点为最大</span></span><br><span class="line">        arr[<span class="number">0</span>], arr[i] =  arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 换出根节点后 再对剩下的排序 最后形成升序</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: arr) heap.offer(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = heap.poll();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(heapSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-计数排序"><a href="#10-计数排序" class="headerlink" title="10.计数排序"></a>10.计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><blockquote><p>算法步骤</p></blockquote><ol><li>找出原数组中元素值最大的，记为max。</li><li>创建一个新数组count，其长度是max加1，其元素默认值都为0。</li><li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li><li>创建结果数组result，起始索引index。</li><li>遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。</li><li>返回结果数组result。</li></ol><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/152.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    maxLen = <span class="built_in">max</span>(arr) + <span class="number">1</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxLen)]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxLen):</span><br><span class="line">        <span class="keyword">while</span> count[i] &gt; <span class="number">0</span>:</span><br><span class="line">            result.append(i)</span><br><span class="line">            count[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) maxValue=i &gt; maxValue?i: maxValue;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) count[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;=maxValue; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i]-- &gt; <span class="number">0</span>) res[j++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(countSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个问题：上述写法并不是稳定排序，因此这里做改进，稳定的计数排序如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) maxValue = i &gt; maxValue?i: maxValue;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) count[i]++;</span><br><span class="line">        <span class="comment">//做累加，使桶中记录的为每个数的最后一个索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=maxValue; i++) count[i] = count[i] + count[i-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//逆序遍历，直接往相应索引填数，使得算法稳定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res[--count[arr[i]]] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(countSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-桶排序"><a href="#11-桶排序" class="headerlink" title="11.桶排序"></a>11.桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><blockquote><p>什么时候最快</p></blockquote><p>当输入的数据可以均匀的分配到每一个桶中。</p><blockquote><p>什么时候最慢</p></blockquote><p>当输入的数据被分配到了同一个桶中。</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/153.gif" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">array, bucketSize=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="comment"># bucketSize设置每个桶的容量</span></span><br><span class="line">    maxValue = <span class="built_in">max</span>(array)</span><br><span class="line">    minValue = <span class="built_in">min</span>(array)</span><br><span class="line">    <span class="comment"># 1.创建空桶</span></span><br><span class="line">    bucketCount = (maxValue - minValue) // bucketSize + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucketCount)]</span><br><span class="line">    <span class="comment"># 2.利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> array:</span><br><span class="line">        index = (<span class="built_in">int</span>)(data - minValue) // bucketSize</span><br><span class="line">        buckets[index].append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.桶内排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketCount):</span><br><span class="line">        buckets[i].sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.产生新的排序后的列表</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketCount):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets[i])):</span><br><span class="line">            array[index] = buckets[i][j]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bucketSize用于设置每个桶的容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="comment">//得到数组中的最大，最小值</span></span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多少个桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//创建空桶</span></span><br><span class="line">        List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[bucketCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="comment">//映射函数，存放到相应桶中</span></span><br><span class="line">            <span class="keyword">int</span> index = (value - minValue) / bucketSize;</span><br><span class="line">            <span class="keyword">if</span>(buckets[index] == <span class="keyword">null</span>) buckets[index] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            buckets[index].add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对每个桶排序</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="comment">//桶不为空</span></span><br><span class="line">            <span class="keyword">if</span>(bucket != <span class="keyword">null</span>) Collections.sort(bucket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//产生排序后的新列表</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets)&#123;</span><br><span class="line">            <span class="comment">//桶不为空</span></span><br><span class="line">            <span class="keyword">if</span>(bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : bucket) &#123;</span><br><span class="line">                    res[index] = integer;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span> ,<span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> BucketSort().bucketSort(arr, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Qiyuan-Z</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qiyuan-z.github.io/2021/03/09/Leetcode%E5%88%B7%E9%A2%98/">https://qiyuan-z.github.io/2021/03/09/Leetcode%E5%88%B7%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Qiyuan-Z.github.io" target="_blank">Yuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/leetcode_python/src=http _pic4.zhimg.com_v2-c6e719d4cf7f2e31a6656295f3da40ba_1440w.jpg source=172ae18b&amp;refer=http _pic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/25/keras%E8%BD%AConnx/"><img class="prev-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/20210925163337.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">keras/tensorflow转onnx</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/11/EndNote%E6%A0%B7%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"><img class="next-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/endnote.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">EndNote样式使用教程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">数组系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%A4%E9%9B%86"><span class="toc-number">1.1.</span> <span class="toc-text">1.交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">1.2.</span> <span class="toc-text">2.最长公共前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">3.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">4.旋转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8E%9F%E5%9C%B0%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.</span> <span class="toc-text">5.原地删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8A%A0%E4%B8%80"><span class="toc-number">1.6.</span> <span class="toc-text">6.加一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.7.</span> <span class="toc-text">7.两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.8.</span> <span class="toc-text">8.三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">1.9.</span> <span class="toc-text">9.Z字形变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">链表系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">1.删除链表倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3.环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.4.</span> <span class="toc-text">4.两数相加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">动态规划系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">3.1.</span> <span class="toc-text">1.爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">3.2.</span> <span class="toc-text">2.最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">3.最长上升子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.4.</span> <span class="toc-text">4.三角形最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.5.</span> <span class="toc-text">5.最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">3.6.</span> <span class="toc-text">6.打家劫舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">字符串系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.</span> <span class="toc-text">1.反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">2.字符串中的第一个唯一字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0Sunday%E5%8C%B9%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text">3.实现Sunday匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E6%95%B0%E6%89%93%E5%8D%B0"><span class="toc-number">4.4.</span> <span class="toc-text">4.大数打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">4.5.</span> <span class="toc-text">5.验证回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-KMP"><span class="toc-number">4.6.</span> <span class="toc-text">6.KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.7.</span> <span class="toc-text">7.旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">4.8.</span> <span class="toc-text">8.最后一个单词的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">二叉树系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E4%B8%8EDFS"><span class="toc-number">5.1.</span> <span class="toc-text">1.最大深度与DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%8EBFS"><span class="toc-number">5.2.</span> <span class="toc-text">2.层次遍历与BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BST%E4%B8%8E%E5%85%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">5.3.</span> <span class="toc-text">3.BST与其验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BST%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">5.4.</span> <span class="toc-text">4.BST的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BST%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.</span> <span class="toc-text">5.BST的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.6.</span> <span class="toc-text">6.平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.7.</span> <span class="toc-text">7.完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%AA%E6%9E%9D"><span class="toc-number">5.8.</span> <span class="toc-text">8.二叉树的剪枝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%B3%BB%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">回溯系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">1.全排列算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B3%BB%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">滑动窗口系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">1.滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">7.2.</span> <span class="toc-text">2.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">7.3.</span> <span class="toc-text">3.找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">7.4.</span> <span class="toc-text">4.和为S的连续正数序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%B3%BB%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">博弈论系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83"><span class="toc-number">8.1.</span> <span class="toc-text">1.囚徒困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA"><span class="toc-number">8.2.</span> <span class="toc-text">2.辛普森悖论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A2%E7%9C%BC%E7%9D%9B%E5%92%8C%E8%93%9D%E7%9C%BC%E7%9D%9B"><span class="toc-number">8.3.</span> <span class="toc-text">3.红眼睛和蓝眼睛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%B7%E7%9B%97%E5%88%86%E9%87%91%E5%B8%81"><span class="toc-number">8.4.</span> <span class="toc-text">4.海盗分金币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%99%BA%E7%8C%AA%E5%8D%9A%E5%BC%88"><span class="toc-number">8.5.</span> <span class="toc-text">5.智猪博弈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%94%9F%E7%94%B7%E7%94%9F%E5%A5%B3%E9%97%AE%E9%A2%98"><span class="toc-number">8.6.</span> <span class="toc-text">6.生男生女问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">7.硬币问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%94%BB%E5%9C%88%E5%9C%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.8.</span> <span class="toc-text">8.画圈圈的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%97%AE%E9%A2%98"><span class="toc-number">8.9.</span> <span class="toc-text">9.巧克力问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%A7%E9%B1%BC%E5%92%8C%E5%B0%8F%E9%B1%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.10.</span> <span class="toc-text">10.大鱼和小鱼的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">排序系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">9.1.</span> <span class="toc-text">1.按奇偶排序数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%B3%BB%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">位运算系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E5%92%8C"><span class="toc-number">10.1.</span> <span class="toc-text">1.使用位运算求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%9A%84%E5%B9%82"><span class="toc-number">10.2.</span> <span class="toc-text">2.2的幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">3.返回一个数二进制中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">10.4.</span> <span class="toc-text">4.只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A1"><span class="toc-number">10.5.</span> <span class="toc-text">5.只出现一次的数字Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97"><span class="toc-number">10.6.</span> <span class="toc-text">6.缺失数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%B3%BB%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">二分法系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BF%E7%8F%82%E5%96%9C%E6%AC%A2%E5%90%83%E9%A6%99%E8%95%89"><span class="toc-number">11.1.</span> <span class="toc-text">1.阿珂喜欢吃香蕉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">11.2.</span> <span class="toc-text">2.x的平方根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">11.3.</span> <span class="toc-text">3.第一个错误的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCI"><span class="toc-number">11.4.</span> <span class="toc-text">4.旋转排序数组中的最小值I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII"><span class="toc-number">11.5.</span> <span class="toc-text">5.旋转排序数组中的最小值II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BE%9B%E6%9A%96%E5%99%A8"><span class="toc-number">11.6.</span> <span class="toc-text">6.供暖器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85%E9%A2%98%E7%9B%AE"><span class="toc-number">12.</span> <span class="toc-text">其他补充题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5I"><span class="toc-number">12.1.</span> <span class="toc-text">1.螺旋矩阵I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98"><span class="toc-number">12.2.</span> <span class="toc-text">2.只有两个键的键盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-24%E7%82%B9%E6%B8%B8%E6%88%8F"><span class="toc-number">12.3.</span> <span class="toc-text">3.24点游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87"><span class="toc-number">12.4.</span> <span class="toc-text">4.飞机座位分配概率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B0%B4%E5%88%86%E5%AD%90%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">12.5.</span> <span class="toc-text">5.水分子的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%91%E7%94%9F%E8%89%87"><span class="toc-number">12.6.</span> <span class="toc-text">6.救生艇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-25%E5%8C%B9%E9%A9%AC%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">12.7.</span> <span class="toc-text">7.25匹马的经典问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3"><span class="toc-number">12.8.</span> <span class="toc-text">8.灯泡开关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98"><span class="toc-number">12.9.</span> <span class="toc-text">9.三门问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">12.10.</span> <span class="toc-text">10.猜数字游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">12.11.</span> <span class="toc-text">11.LRU缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">12.12.</span> <span class="toc-text">12.最小的k个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">12.13.</span> <span class="toc-text">13.不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E9%9A%9C%E7%A2%8D%E7%89%A9"><span class="toc-number">12.14.</span> <span class="toc-text">14.不同路径-障碍物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">12.15.</span> <span class="toc-text">15.盛最多水的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%E5%AE%B9%E5%99%A8"><span class="toc-number">12.16.</span> <span class="toc-text">16.扑克牌中的顺子容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">12.17.</span> <span class="toc-text">17.整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD"><span class="toc-number">12.18.</span> <span class="toc-text">18.移动石子直到连续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Nim%E6%B8%B8%E6%88%8F"><span class="toc-number">12.19.</span> <span class="toc-text">19.Nim游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">12.20.</span> <span class="toc-text">20.寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">12.21.</span> <span class="toc-text">21.第k个最大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="toc-number">12.22.</span> <span class="toc-text">22.镜面反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">12.23.</span> <span class="toc-text">23.整数转罗马数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98"><span class="toc-number">12.24.</span> <span class="toc-text">24.荷兰国旗问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%85%AD%E4%B9%9D%E9%97%AE%E9%A2%98"><span class="toc-number">12.25.</span> <span class="toc-text">25.六九问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-number">12.26.</span> <span class="toc-text">26.有效的数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%B4%B9%E7%B1%B3%E4%BC%B0%E7%AE%97"><span class="toc-number">12.27.</span> <span class="toc-text">27.费米估算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">12.28.</span> <span class="toc-text">28.分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F"><span class="toc-number">12.29.</span> <span class="toc-text">29.生命游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">12.30.</span> <span class="toc-text">30.搜索二维矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%AD%90%E9%9B%86"><span class="toc-number">12.31.</span> <span class="toc-text">31.子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E9%87%8F%E5%87%BA4%E5%8D%87%E6%B0%B4"><span class="toc-number">12.32.</span> <span class="toc-text">32.量出4升水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%9C%80%E5%A4%A7%E7%9A%84%E9%92%BB%E7%9F%B3"><span class="toc-number">12.33.</span> <span class="toc-text">33.最大的钻石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%80%9D%E7%BB%B4%E5%AE%9A%E5%8A%BF"><span class="toc-number">12.34.</span> <span class="toc-text">34.思维定势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">12.35.</span> <span class="toc-text">35.图的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">12.36.</span> <span class="toc-text">36.旋转图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-number">12.37.</span> <span class="toc-text">37.螺旋矩阵II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97-1"><span class="toc-number">13.</span> <span class="toc-text">排序系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E4%B8%93%E6%A0%8F"><span class="toc-number">13.1.</span> <span class="toc-text">1.排序专栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">13.2.</span> <span class="toc-text">2.冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">13.3.</span> <span class="toc-text">3.基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">13.4.</span> <span class="toc-text">4.选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">13.5.</span> <span class="toc-text">5.插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">13.6.</span> <span class="toc-text">6.希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.7.</span> <span class="toc-text">7.归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">13.8.</span> <span class="toc-text">8.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">13.9.</span> <span class="toc-text">9.堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">13.10.</span> <span class="toc-text">10.计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.11.</span> <span class="toc-text">11.桶排序</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022<i id="heartbeat" class="fa fas fa-heartbeat"></i> Qiyuan-Z</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br>昨日までの私は、もうどこにもいない</br></p></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '2d10cfb27783db577e70',
      clientSecret: '154292876bb14966f6ae57304b67859617b08c94',
      repo: 'gitalk',
      owner: 'Qiyuan-Z',
      admin: ['Qiyuan-Z'],
      id: '973bfd84959c27f19cec9090cf0e8d80',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer src="https://cdn.jsdelivr.net/gh/Qiyuan-Z/live2d-widget/autoload.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>