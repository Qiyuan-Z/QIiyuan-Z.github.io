<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>蓝桥杯试题及答案分享(Python版) | Yuan</title><meta name="keywords" content="Python"><meta name="author" content="Qiyuan-Z"><meta name="copyright" content="Qiyuan-Z"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="比赛介绍蓝桥杯大赛的举办得到了教育部、工业和信息化部有关领导的高度重视，相关司局的大力支持，也得到了各省教育厅和各有关院校的积极响应，更得到了参赛师生的广泛好评，参赛学校超过 1200 余所，参赛规模已达四十万人次，取得了良好的社会效果。 省级在我们学校为B类，国家级则为A类，省级中获一等奖的可参加国家级，因此比赛含金量高，建议大家好好把握😊 其中个人赛软件类分：  C&#x2F;C++程序设计（研究生组"><meta property="og:type" content="article"><meta property="og:title" content="蓝桥杯试题及答案分享(Python版)"><meta property="og:url" content="https://qiyuan-z.github.io/2022/03/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E5%88%86%E4%BA%AB(Python%E7%89%88)/index.html"><meta property="og:site_name" content="Yuan"><meta property="og:description" content="比赛介绍蓝桥杯大赛的举办得到了教育部、工业和信息化部有关领导的高度重视，相关司局的大力支持，也得到了各省教育厅和各有关院校的积极响应，更得到了参赛师生的广泛好评，参赛学校超过 1200 余所，参赛规模已达四十万人次，取得了良好的社会效果。 省级在我们学校为B类，国家级则为A类，省级中获一等奖的可参加国家级，因此比赛含金量高，建议大家好好把握😊 其中个人赛软件类分：  C&#x2F;C++程序设计（研究生组"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao.jpg"><meta property="article:published_time" content="2022-03-02T11:08:00.000Z"><meta property="article:modified_time" content="2022-05-09T09:15:03.682Z"><meta property="article:author" content="Qiyuan-Z"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qiyuan-z.github.io/2022/03/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E5%88%86%E4%BA%AB(Python%E7%89%88)/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-05-09 17:15:03"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">蓝桥杯试题及答案分享(Python版)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-02T11:08:00.000Z" title="发表于 2022-03-02 19:08:00">2022-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-09T09:15:03.682Z" title="更新于 2022-05-09 17:15:03">2022-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B5%84%E6%BA%90/">资源</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="比赛介绍"><a href="#比赛介绍" class="headerlink" title="比赛介绍"></a>比赛介绍</h2><p>蓝桥杯大赛的举办得到了教育部、工业和信息化部有关领导的高度重视，相关司局的大力支持，也得到了各省教育厅和各有关院校的积极响应，更得到了参赛师生的广泛好评，参赛学校超过 1200 余所，参赛规模已达四十万人次，取得了良好的社会效果。</p><p>省级在我们学校为B类，国家级则为A类，省级中获一等奖的可参加国家级，因此比赛含金量高，建议大家好好把握😊</p><p>其中个人赛软件类分：</p><ul><li>C/C++程序设计（研究生组、大学A组、B组、C组）</li><li>Java软件开发（研究生组、大学A组、B组、C组）</li><li>Python程序设计（大学组）</li></ul><h2 id="Python组竞赛规则及说明"><a href="#Python组竞赛规则及说明" class="headerlink" title="Python组竞赛规则及说明"></a>Python组竞赛规则及说明</h2><h3 id="组别"><a href="#组别" class="headerlink" title="组别"></a>组别</h3><p>本次竞赛不分组别。所有研究生、重点本科、普通本科和高职高专院校均可报名该组，统一评奖。</p><h3 id="竞赛赛程"><a href="#竞赛赛程" class="headerlink" title="竞赛赛程"></a>竞赛赛程</h3><p>全国选拔赛时长：4 小时。<br>总决赛时长：4 小时。<br>详细赛程安排以组委会公布信息为准。</p><h3 id="竞赛形式"><a href="#竞赛形式" class="headerlink" title="竞赛形式"></a>竞赛形式</h3><p>个人赛，一人一机，全程机考。选手机器通过局域网连接到赛场的竞赛服务器。选手答题过程中无法访问互联网，也不允许使用本机以外的资源（如USB 连接）。竞赛系统以“服务器-浏览器”方式发放试题、回收选手答案。</p><h3 id="参赛选手机器环境"><a href="#参赛选手机器环境" class="headerlink" title="参赛选手机器环境"></a>参赛选手机器环境</h3><p><strong>选手机器配置：</strong></p><p>X86兼容机器，内存不小于 4G ，硬盘不小于 60G<br>操作系统：Windows7 及以上</p><p><strong>编程环境：</strong></p><p>编译器：Python 3.8.6<br>编辑器：IDLE Python 自带编辑器</p><h3 id="试题形式"><a href="#试题形式" class="headerlink" title="试题形式"></a>试题形式</h3><p>竞赛题目完全为客观题型。根据选手所提交答案的测评结果为评分依据。共有两种题型。</p><p><strong>结果填空题</strong></p><p>题目描述一个具有确定解的问题。要求选手对问题的解填空。<br>不要求解题过程，不限制解题手段（可以使用任何开发语言或工具，甚至是手工计算），只要求填写最终的结果。最终的解是一个整数或者是一个字符串，最终的解可以使用ASCII 字符表达。</p><p><strong>编程大题</strong></p><p>题目包含明确的问题描述、输入和输出格式，以及用于解释问题的样例数据。</p><p>编程大题所涉及的问题一定是有明确客观的标准来判断结果是否正确，并可以通过程序对结果进行评判。果进行评判。</p><p>选手应当根据问题描述，编写程序（使用 Python 编写）来解决问题，在评测时选手的程序应当从标准输入读入数据，并将最终的结果输出到标准输出中。</p><p>在问题描述中会明确说明给定的条件和限制，明确问题的任务，选手的程序应当能解决在给定条件和限制下的所有可能的情况。在给定条件和限制下的所有可能的情况。</p><p>选手的程序应当具有普遍性，不能只适用于题目的样例数据。</p><p>为了测试选手给出解法的性能，评分时用的测试用例可能包含大数据量的压力测试用例，选手选择算法时要尽可能考虑可行性和效率问题。</p><h3 id="试题考查范围试题考查范围"><a href="#试题考查范围试题考查范围" class="headerlink" title="试题考查范围试题考查范围"></a>试题考查范围试题考查范围</h3><p>Python程序设计基础：包含使用 Python编写程序的能力。该部分不考查选手对某一语法的理解程度，选手可以使用自己喜欢的语句编写程序。</p><p>计算机算法：枚举、排序、搜索、计数、贪心、动态规划、图论、数论、博弈论、概率论、计算几何、字符串算法等。</p><p>数据结构：数组、对象/结构、字符串、队列、栈、树、图、堆、平衡树结构、字符串、队列、栈、树、图、堆、平衡树/线段树、复杂数据线段树、复杂数据结构、嵌套数据结构等。</p><h3 id="答案提交"><a href="#答案提交" class="headerlink" title="答案提交"></a>答案提交</h3><p>选手只有在比赛时间内提交的答案内容是可以用来评测的，比赛之后的任何提交均无效。</p><p>选手应使用考试指定的网页来提交代码，任何其他方式的提交（如邮件、U盘）都不作为评测依据。</p><p>选手可在比赛中的任何时间查看自己之前提交的代码，也可以重新提交任何题目的答案，对于每个试题，仅有最后的一次提交被保存并作为评测的依据。在比赛中，评测结果不会显示给选手，选手应当在没有反馈的情况下自行设计数据调试自己的程序。</p><p>对于每个试题，选手应将试题的答案内容拷贝粘贴到网页上进行提交。</p><p>Python程序仅可以使用Python自带的库，评测时不会安装其他的扩展库。</p><p>程序中应只包含计算模块，不要包含任何其他的模块，比如图形、系统接口调用、系统中断等。对于系统接口的调用都应通过标准库来进行。</p><p>程序中引用的库应该在程序中以源代码的方式写出，在提交时也应当和程序的其他部分一起提交。</p><h3 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h3><p>全部使用机器自动评分。对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格式错误或有多余内容时不得分。</p><p>对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程序的输出与正确答案是匹配的，则选手获得该评测数据的分数。</p><p>评测使用的评测数据一般与试题中给定的样例输入输出不一样。因此建议选手在提交程序前使用不同的数据测试自己的程序。</p><p>提交的程序应严格按照输出格式的要求来输出，包括输出空格和换行的要求。如果程序没有遵循输出格式的要求将被判定为答案错误。请注意，程序在输出的时候多输出了内容也属于没有遵循输出格式要求的一种，所以在输出的时候请不要输出任何多余的内容，比如调试输出。</p><h2 id="试题及答案"><a href="#试题及答案" class="headerlink" title="试题及答案"></a>试题及答案</h2><p>试题由本人从历年搜集并附了程序解答，由于本人编程能力有限，可能有错或并非最优解，欢迎指正！</p><p>当初本人刷完题，将解答过程分享给老魏，最终老魏获得了省二（成为我心中的阴影😢），说明刷题还是有一定帮助，希望大家能认真做好每一题。</p><h3 id="成绩统计"><a href="#成绩统计" class="headerlink" title="成绩统计"></a>成绩统计</h3><p><strong>题目描述</strong></p><blockquote><p>小蓝给学生们组织了一场考试，卷面总分为100分，每个学生的得分都是一个0到100的整数。如果得分至少是60分，则称为及格。如果得分至少为85分，则称为优秀。请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含一个整数 n (1≤n≤$10^4$)，表示考试人数。接下来n行，每行包含一个0至100的整数，表示一个学生的得分。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 及格的数量</span></span><br><span class="line">passNum = <span class="number">0</span></span><br><span class="line"><span class="comment"># 优秀的数量</span></span><br><span class="line">goodNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    score = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">        passNum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">85</span>:</span><br><span class="line">        goodNum += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">round</span>(passNum/n*<span class="number">100</span>))+<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">round</span>(goodNum/n*<span class="number">100</span>))+<span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="FJ字符串"><a href="#FJ字符串" class="headerlink" title="FJ字符串"></a>FJ字符串</h3><p><strong>题目描述</strong></p><blockquote><p>FJ在沙盘上写了这样一些字符串：</p><p>A1 = “A”</p><p>A2 = “ABA”</p><p>A3 = “ABACABA”</p><p>A4 = “ABACABADABACABA”</p><p>… …</p><p>你能找出其中的规律并写所有的数列AN吗？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>仅有一个数：N ≤ 26。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>ABACABA</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    result = result + <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + i) + result</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="K好数"><a href="#K好数" class="headerlink" title="K好数"></a>K好数</h3><p><strong>题目描述</strong></p><blockquote><p>如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入包含两个正整数，K和L。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数，表示答案对1000000007取模后的值。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4 2</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>7</p></blockquote><p>对于30%的数据，KL &lt;= 106；</p><p>对于50%的数据，K &lt;= 16, L &lt;= 10；</p><p>对于100%的数据，1 &lt;= K, L &lt;= 100。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">K, L = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># dp[i][j]表示i + 1位上存放j的方法个数。</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"><span class="comment"># 当只有一位时不管这位放哪个数字都只有一种方法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, K):</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 当位数大等2位时</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">    <span class="comment"># 以2为数为例，j为十位，m为个位</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            <span class="comment"># 不相邻才能存放</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(j - m) != <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 当前位数的放j情况的总个数 = 当前位置放j的个数 + 上一位置放[0,k)的总个数</span></span><br><span class="line">                dp[i][j] = dp[i][j]+dp[i-<span class="number">1</span>][m]</span><br><span class="line">                dp[i][j] %= <span class="number">1000000007</span></span><br><span class="line">    <span class="comment"># 不断递归下去，如三位数放k进制的个数 = 三位数的最高位（看成十位）放k进制的个数+两位数（看成一个整体为个位）放k进制的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># L位数K好数的总个数</span></span><br><span class="line"><span class="comment"># i从1开始排除L位为最高位放0的情况</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">    count += dp[L-<span class="number">1</span>][i]</span><br><span class="line">    count %= <span class="number">1000000007</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><strong>题目描述</strong></p><blockquote><p>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入N。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数，表示总共有多少种放法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归回溯思想解决n皇后问题，cur代表当前行，从0开始一行行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queen</span>(<span class="params">A, cur=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="comment"># 判断上行放置的棋子是否有问题，如果有则回退</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(cur-<span class="number">1</span>): </span><br><span class="line">        <span class="comment"># 由于是一行行遍历肯定不存在同行，只需检测是否同列和同对角线</span></span><br><span class="line">        <span class="comment"># 若在该列或对角线上存在其他皇后</span></span><br><span class="line">        <span class="keyword">if</span> A[row] - A[cur-<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">abs</span>(A[row] - A[cur-<span class="number">1</span>]) == cur - <span class="number">1</span> - row: </span><br><span class="line">            <span class="comment"># 该位置不能放</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 所有的皇后都正确放置完毕，输出每个皇后所在的位置</span></span><br><span class="line">    <span class="keyword">if</span> cur == <span class="built_in">len</span>(A): </span><br><span class="line">        <span class="built_in">print</span>(A)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 行数=列数，遍历每列</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        <span class="comment"># 当前行存储皇后所在的列数</span></span><br><span class="line">        A[cur] = col</span><br><span class="line">        <span class="comment"># 继续放下一个皇后</span></span><br><span class="line">        queen(A, cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># n为8，就是著名的八皇后问题啦</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>()) </span><br><span class="line"><span class="comment"># 初始传入8行的数组</span></span><br><span class="line">queen([<span class="literal">None</span>] * n)</span><br></pre></td></tr></table></figure><h3 id="2N皇后"><a href="#2N皇后" class="headerlink" title="2N皇后"></a>2N皇后</h3><p><strong>题目描述</strong></p><blockquote><p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行为一个整数n，表示棋盘的大小。<br>接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数，表示总共有多少种放法。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>2</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4<br>1 0 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>0</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先放置白皇后, cur代表当前行，从0开始一行行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w_queen</span>(<span class="params">cur=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="comment"># 判断上行放置的棋子是否有问题，如果有则回退</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(cur-<span class="number">1</span>): </span><br><span class="line">        <span class="comment"># 由于是一行行遍历肯定不存在同行，只需检测是否同列和同对角线</span></span><br><span class="line">        <span class="comment"># 若在该列或对角线上存在其他皇后</span></span><br><span class="line">        <span class="keyword">if</span> w_pos[row] - w_pos[cur-<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">abs</span>(w_pos[row] - w_pos[cur-<span class="number">1</span>]) == cur - <span class="number">1</span> - row: </span><br><span class="line">            <span class="comment"># 该位置不能放</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 当前颜色皇后都正确放置完毕</span></span><br><span class="line">    <span class="keyword">if</span> cur == n: </span><br><span class="line">        <span class="comment"># 放置另一种颜色的皇后</span></span><br><span class="line">        b_queen(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 遍历每列</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 如果该位置为1，则可以放置其子</span></span><br><span class="line">        <span class="keyword">if</span> chessboard[cur][col] == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 记录该棋子存放位置</span></span><br><span class="line">            w_pos[cur] = col</span><br><span class="line">            <span class="comment"># 继续放下一个皇后</span></span><br><span class="line">            w_queen(cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再放置黑皇后，与白皇后同理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_queen</span>(<span class="params">cur=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(cur-<span class="number">1</span>): </span><br><span class="line">        <span class="keyword">if</span> b_pos[row] - b_pos[cur-<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">abs</span>(b_pos[row] - b_pos[cur-<span class="number">1</span>]) == cur - <span class="number">1</span> - row: </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> cur == n: </span><br><span class="line">        <span class="comment"># 两种颜色皇后放置完毕，记录次数</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 如果该位置为1且没有放白皇后，则可以放置其子</span></span><br><span class="line">        <span class="keyword">if</span> chessboard[cur][col] == <span class="number">1</span> <span class="keyword">and</span> w_pos[cur] != col:</span><br><span class="line">            b_pos[cur] = col</span><br><span class="line">            b_queen(cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>()) </span><br><span class="line"><span class="comment"># 初始化棋盘</span></span><br><span class="line">chessboard = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    arr = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        chessboard[i].append(<span class="built_in">int</span>(arr[j]))</span><br><span class="line"><span class="comment"># 用于记录白皇后位置</span></span><br><span class="line">w_pos = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 用于记录黑皇后位置</span></span><br><span class="line">b_pos = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 初始化多少种放法</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 开始放置皇后</span></span><br><span class="line">w_queen(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出多少种放法</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="sin之舞"><a href="#sin之舞" class="headerlink" title="sin之舞"></a>sin之舞</h3><p><strong>题目描述</strong></p><blockquote><p>最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。<br>不妨设<br>An=sin(1–sin(2+sin(3–sin(4+…sin(n))…)<br>Sn=(…(A1+n)A2+n-1)A3+…+2)An+1<br>FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>仅有一个数：N&lt;201。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">k, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k == n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sin(%d&#x27;</span> % (k + <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 若后边还有式子，判断是输出+号还是-号</span></span><br><span class="line">    <span class="keyword">if</span> k + <span class="number">1</span> != n:  </span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 若到底了，则输出n个&#x27;)&#x27;结束</span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;)&#x27;</span>*n, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line">    A(k, n)  <span class="comment"># 递归调用自身</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="comment"># 第一项n-1个括号开始</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;(&#x27;</span>*(n-<span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 后续An+n-i)</span></span><br><span class="line">    A(<span class="number">0</span>, i+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+%d&#x27;</span> % (n-i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 最后一项加完整数之和不必再输出右括号</span></span><br><span class="line">    <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;)&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="不同子串"><a href="#不同子串" class="headerlink" title="不同子串"></a>不同子串</h3><p><strong>题目描述</strong></p><blockquote><p>一个字符串的非空子串是指字符串中长度至少为1的连续的一段字符组成的串。例如，字符串aaab有非空子串a, b, aa, ab, aaa, aab, aaab，一共7个。 注意在计算时，只算本质不同的串的个数。请问，字符串0100110001010001有多少个不同的非空子串？</p></blockquote><p>答案</p><blockquote><p>100</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;0100110001010001&#x27;</span></span><br><span class="line">var = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(str1)+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1) - i + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> str1[j:j+i] <span class="keyword">not</span> <span class="keyword">in</span> var:</span><br><span class="line">            var.append(str1[j:j+i])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(var))</span><br></pre></td></tr></table></figure><h3 id="成绩排名"><a href="#成绩排名" class="headerlink" title="成绩排名"></a>成绩排名</h3><p><strong>题目描述</strong></p><blockquote><p>小明刚经过了一次数学考试，老师由于忙碌忘记排名了，于是老师把这个光荣的任务交给了小明，小明则找到了聪明的你，希望你能帮他解决这个问题。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行包含一个正整数N，表示有个人参加了考试。接下来N行，每行有一个字符串和一个正整数，分别表示人名和对应的成绩，用一个空格分隔。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一共有N行，每行一个字符串，第i行的字符串表示成绩从高到低排在第i位的人的名字，若分数一样则按人名的字典序顺序从小到大。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3<br>aaa 47<br>bbb 90<br>ccc 70</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>bbb<br>ccc<br>aaa</p></blockquote><p>人数&lt;=100,分数&lt;=100,人名仅包含小写字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">inf = [<span class="built_in">list</span>(<span class="built_in">input</span>().split()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">information.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># 先排姓名，按字母顺序</span></span><br><span class="line">information.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x[<span class="number">1</span>]), reverse=<span class="literal">True</span>)  <span class="comment"># 后排成绩，从大到小</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">print</span>(information[i][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="承压计算"><a href="#承压计算" class="headerlink" title="承压计算"></a>承压计算</h3><p><strong>题目描述</strong></p><blockquote><p>X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。</p><p>每块金属原料的外形、尺寸完全一致，但重量不同。<br>金属材料被严格地堆放成金字塔形。</p><p>其中的数字代表金属块的重量（计量单位较大）。<br>最下一层的X代表30台极高精度的电子秤。</p><p>假设每块原料的重量都十分精确地平均落在下方的两个金属块上，<br>最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。<br>电子秤的计量单位很小，所以显示的数字很大。</p><p>工作人员发现，其中读数最小的电子秤的示数为：2086458231</p><p>请你推算出：读数最大的电子秤的示数为多少？</p><p>注意：需要提交的是一个<strong>整数</strong>，不要填写任何多余的内容。</p></blockquote><p><code>pyramid.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                             7 </span><br><span class="line">                            5 8 </span><br><span class="line">                           7 8 8 </span><br><span class="line">                          9 2 7 2 </span><br><span class="line">                         8 1 4 9 1 </span><br><span class="line">                        8 1 8 8 4 1 </span><br><span class="line">                       7 9 6 1 4 5 4 </span><br><span class="line">                      5 6 5 5 6 9 5 6 </span><br><span class="line">                     5 5 4 7 9 3 5 5 1 </span><br><span class="line">                    7 5 7 9 7 4 7 3 3 1 </span><br><span class="line">                   4 6 4 5 5 8 8 3 2 4 3 </span><br><span class="line">                  1 1 3 3 1 6 6 5 5 4 4 2 </span><br><span class="line">                 9 9 9 2 1 9 1 9 2 9 5 7 9 </span><br><span class="line">                4 3 3 7 7 9 3 6 1 3 8 8 3 7 </span><br><span class="line">               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 </span><br><span class="line">              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 </span><br><span class="line">             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 </span><br><span class="line">            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 </span><br><span class="line">           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 </span><br><span class="line">          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 </span><br><span class="line">         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 </span><br><span class="line">        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 </span><br><span class="line">       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 </span><br><span class="line">      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 </span><br><span class="line">     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 </span><br><span class="line">    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 </span><br><span class="line">   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 </span><br><span class="line">  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 </span><br><span class="line"> 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 </span><br><span class="line">X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;pyramid.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    arr.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split())))</span><br><span class="line">arr.append([<span class="number">0</span>]*<span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        arr[i][j] += arr[i - <span class="number">1</span>][j] / <span class="number">2</span></span><br><span class="line">        arr[i][j + <span class="number">1</span>] += arr[i - <span class="number">1</span>][j] / <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2086458231</span> / <span class="built_in">min</span>(arr[-<span class="number">1</span>]) * <span class="built_in">max</span>(arr[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><h3 id="乘积尾零"><a href="#乘积尾零" class="headerlink" title="乘积尾零"></a>乘积尾零</h3><p><strong>题目描述</strong></p><blockquote><p>如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。</p></blockquote><p><code>num.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5650 4542 3554 473 946 4114 3871 9073 90 4329</span><br><span class="line">2758 7949 6113 5659 5245 7432 3051 4434 6704 3594</span><br><span class="line">9937 1173 6866 3397 4759 7557 3070 2287 1453 9899</span><br><span class="line">1486 5722 3135 1170 4014 5510 5120 729 2880 9019</span><br><span class="line">2049 698 4582 4346 4427 646 9742 7340 1230 7683</span><br><span class="line">5693 7015 6887 7381 4172 4341 2909 2027 7355 5649</span><br><span class="line">6701 6645 1671 5978 2704 9926 295 3125 3878 6785</span><br><span class="line">2066 4247 4800 1578 6652 4616 1113 6205 3264 2915</span><br><span class="line">3966 5291 2904 1285 2193 1428 2265 8730 9436 7074</span><br><span class="line">689 5510 8243 6114 337 4096 8199 7313 3685 211</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;num.txt&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">file.close</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> line.split():</span><br><span class="line">        <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">int</span>(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res *= <span class="built_in">int</span>(num)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(res)[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> i != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="单词分析"><a href="#单词分析" class="headerlink" title="单词分析"></a>单词分析</h3><p><strong>题目描述</strong></p><blockquote><p>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写字母组成，<br>有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，<br>他准备不再完全记忆这些单词，而是根据单词中哪个字母出现的最多来分辨单词。<br>请你帮助小蓝，给了一些单词后，帮助他找到出现最多的字母和这个字母出现的次数。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行包含一个单词，单词只有小写英文字母组成。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出两行，第一行包含一个英文字母，表示单词中出现最多的字母是哪个。 如果有多个字母出现的次数相等，输出字典序最小的那个。 第二行包含一个整数，表示出现的最多的那个字母在单词中出现的次数。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>lanqiao</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>a<br>2</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>longlonglongistoolong</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>o<br>6</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="built_in">input</span>()</span><br><span class="line">mapNum = &#123;&#125;</span><br><span class="line"><span class="comment"># 次数最多的字母</span></span><br><span class="line">maxV = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 最多次数</span></span><br><span class="line">maxNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> word:</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> mapNum:</span><br><span class="line">        mapNum[v] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mapNum[v] += <span class="number">1</span></span><br><span class="line">keys = <span class="built_in">sorted</span>(mapNum.keys())</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> mapNum[key] &gt; maxNum:</span><br><span class="line">        maxV = key</span><br><span class="line">        maxNum = mapNum[key]</span><br><span class="line"><span class="built_in">print</span>(maxV)</span><br><span class="line"><span class="built_in">print</span>(maxNum)</span><br></pre></td></tr></table></figure><h3 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h3><p><strong>题目描述</strong></p><blockquote><p>数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中N个整数。<br>现在给出这N个整数，小明想知道包含这N个整数的最短的等差数列有几项？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含一个整数N。<br>第二行包含N个整数A1，A2，···，AN。（注意A1~AN并不一定是按等差数列中的顺序给出）</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数表示答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5<br>2 6 4 10 20</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>10</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>包含2、6、4、10、20的最短的等差数列是2、4、6、8、10、12、14、16、18、20。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">min_gap = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"><span class="comment"># 先排序</span></span><br><span class="line">arr.sort()</span><br><span class="line"><span class="comment"># 找出等差数列的步长（各相邻数差值最小的）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">if</span> arr[i] - arr[i-<span class="number">1</span>] &lt; min_gap:</span><br><span class="line">        min_gap = arr[i] - arr[i-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 等差数列长度为(某项-首项)/步长+1</span></span><br><span class="line">res = (arr[-<span class="number">1</span>] - arr[<span class="number">0</span>]) // min_gap + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="等差素数列"><a href="#等差素数列" class="headerlink" title="等差素数列"></a>等差素数列</h3><p><strong>题目描述</strong></p><blockquote><p>2,3,5,7,11,13,…是素数序列。</p><p>类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。<br>上边的数列公差为30，长度为6。</p><p>2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。<br>这是数论领域一项惊人的成果！</p><p>有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：</p><p>长度为10的等差素数列，其公差最小值是多少？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断是否为素数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isprimy</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(<span class="built_in">float</span>(n)**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 在一个范围里查找起点</span></span><br><span class="line"><span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">4000</span>):</span><br><span class="line">    <span class="comment"># 不是素数则跳过</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isprimy(start):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 查找公差</span></span><br><span class="line">    <span class="keyword">for</span> diff <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">400</span>):</span><br><span class="line">        <span class="comment"># 记录数列长度</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 下一个数值</span></span><br><span class="line">        <span class="built_in">next</span> = start + diff</span><br><span class="line">        <span class="comment"># 若仍为素数</span></span><br><span class="line">        <span class="keyword">while</span>(isprimy(<span class="built_in">next</span>)):</span><br><span class="line">            <span class="comment"># 长度加1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 继续判断下一个数</span></span><br><span class="line">            <span class="built_in">next</span> += diff</span><br><span class="line">            <span class="comment"># 若长度大等10，则找到</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= <span class="number">10</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;起点:&#x27;</span>, start,<span class="string">&#x27;公差:&#x27;</span>, diff)</span><br><span class="line">                exit()</span><br></pre></td></tr></table></figure><h3 id="递归倒置字符数组"><a href="#递归倒置字符数组" class="headerlink" title="递归倒置字符数组"></a>递归倒置字符数组</h3><p><strong>题目描述</strong></p><blockquote><p>完成一个递归程序，倒置字符数组，并打印实现过程。<br>递归逻辑为：<br>当字符长度等于1时，直接返回<br>否则，调换首尾两个字符，再递归地倒置字符数组的剩下部分</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>字符数组长度及该数组</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>在求解过程中，打印字符数组的变化情况。<br>最后空一行，在程序结尾处打印倒置后该数组的各个元素。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5 abcde</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>ebcda<br>edcba<br>edcba</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>1 a</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>a</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n, string = <span class="built_in">input</span>().split()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(n) &gt; <span class="number">1</span>:</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">int</span>(n) - <span class="number">1</span></span><br><span class="line">    string = <span class="built_in">list</span>(string)</span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        string[l], string[r] = string[r], string[l]</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(string))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure><h3 id="递增三元组"><a href="#递增三元组" class="headerlink" title="递增三元组"></a>递增三元组</h3><p><strong>题目描述</strong></p><blockquote><p>在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含一个整数 n。<br>第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行包含一个整数，表示答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5<br>1 2 5 3 5</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>2</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>a[2]和a[4]可能是三元组的中心。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录该中心是否用过</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[j] &lt; arr[k]:</span><br><span class="line">                <span class="keyword">if</span> arr[j] <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">                    data.append(arr[j])</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="第几个幸运数"><a href="#第几个幸运数" class="headerlink" title="第几个幸运数"></a>第几个幸运数</h3><p><strong>题目描述</strong></p><blockquote><p>到x星球旅行的游客都被发给一个整数，作为游客编号。<br>x星的国王有个怪癖，他只喜欢数字3,5和7。<br>国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。<br>前10个幸运数字是：3 5 7 9 15 21 25 27 35 45，因而第11个幸运数字是：49<br>小明领到了一个幸运数字 59084709587505。<br>去领奖的时候，人家要求他准确说出这是第几个幸运数字，否则领不到奖品。<br>请你帮小明计算一下，59084709587505是第几个幸运数字。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数表示答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MAX = <span class="number">59084709587505</span></span><br><span class="line"><span class="comment"># MAX = 49</span></span><br><span class="line">a = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">tou = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">       t = tou * i</span><br><span class="line">       <span class="keyword">if</span> t &lt;= MAX:</span><br><span class="line">        s.add(t)</span><br><span class="line">    lst = <span class="built_in">sorted</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">        <span class="keyword">if</span> i &gt; tou:</span><br><span class="line">            tou = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> tou &gt;= MAX:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 1905</span></span><br></pre></td></tr></table></figure><h3 id="调手表"><a href="#调手表" class="headerlink" title="调手表"></a>调手表</h3><p><strong>题目描述</strong></p><blockquote><p>小明买了块高端大气上档次的电子手表，他正准备调时间呢。在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 n 分钟。大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 0 ，那么按一下按钮就会变成 1，再按一次变成 2 。如果当前的数是 n - 1，按一次后会变成 0 。作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多1，则要按 n - 1 次加一按钮才能调回正确时间。</p><p>小明想，如果手表可以再添加一个按钮，表示把当前的数加 k 该多好啊……<br>他想知道，如果有了这个 +k 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。</p><p>注意，按 +k 按钮时，如果加k后数字超过n-1,则会对n取模。比如，n=10, k=6 的时候，假设当前时间是0，连按2次 +k 按钮，则调为2。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>一行两个整数 n, k，意义如题。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一行一个整数。表示：按照最优策略按键，从一个时间调到另一个时间最多要按多少次。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5 3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>2</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>如果时间正确则按0次。否则要按的次数和操作系列之间的关系如下：<br>1：+1<br>2：+1, +1<br>3：+3<br>4：+3, +1</p></blockquote><p>对于 30% 的数据 0 &lt; k &lt; n &lt;= 5<br>对于 60% 的数据 0 &lt; k &lt; n &lt;= 100<br>对于 100% 的数据 0 &lt; k &lt; n &lt;= 100000<br>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗 &lt; 1000ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= k:</span><br><span class="line">        tmp += i // k</span><br><span class="line">        i %= k</span><br><span class="line">    tmp += i</span><br><span class="line">    <span class="keyword">if</span> tmp &gt; res:</span><br><span class="line">        res = tmp</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><p><strong>题目描述</strong></p><blockquote><p>队列操作题。根据输入的操作命令，操作队列（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行一个数字N。<br>下面N行，每行第一个数字为操作命令：（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>若干行每行显示一个2或3命令的输出结果。注意：2.出队命令可能会出现空队出队（下溢），请输出“no”，并退出。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>7<br>1 19<br>1 56<br>2<br>3<br>2<br>3<br>2</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>19<br>1<br>56<br>0<br>no</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">command = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">queue = []</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> command:</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">        queue.append(i[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">0</span>] == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="built_in">print</span>(queue.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">0</span>] == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">len</span>(queue))</span><br></pre></td></tr></table></figure><h3 id="方格分割"><a href="#方格分割" class="headerlink" title="方格分割"></a>方格分割</h3><p><strong>题目描述</strong></p><blockquote><p>6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如图，就是可行的分割法。</p><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/image-20220302142250156.png" alt></p><p>试计算： 包括这3种分法在内，一共有多少种不同的分割方法。</p><p>注意：旋转对称的属于同一种分割法。</p><p>请提交该整数，不要填写任何多余的内容或说明文字。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">因为两部分形状相同，则必定经过中间点</span></span><br><span class="line"><span class="string">从中间点（3，3）出发，向两边按格点走，行走的方式有向上、向下、向左、向右</span></span><br><span class="line"><span class="string">当其中一边达到边界，根据对称性，另一边也到达边界，则所有走过点的连线为一种分割方式</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    <span class="comment"># 到达边界，分割完成</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> x == <span class="number">6</span> <span class="keyword">or</span> y == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">6</span>:</span><br><span class="line">        ans += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 4个出行可能性</span></span><br><span class="line">    <span class="keyword">for</span> xy <span class="keyword">in</span> dirs:</span><br><span class="line">        <span class="comment"># 出发后的新索引</span></span><br><span class="line">        tx = x + xy[<span class="number">0</span>]</span><br><span class="line">        ty = y + xy[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 当前位置未走过</span></span><br><span class="line">        <span class="keyword">if</span> arr_map[tx][ty] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 标记为走过</span></span><br><span class="line">            arr_map[tx][ty] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 两边出发，根据对称性，另一边也标记为走过</span></span><br><span class="line">            arr_map[<span class="number">6</span>-tx][<span class="number">6</span>-ty] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 到达新位置后, 继续搜寻下一步可能</span></span><br><span class="line">            dfs(tx, ty)</span><br><span class="line">            <span class="comment"># 当进行到这步，则代表一种分割可能已经搜寻完，因此跳出了递归</span></span><br><span class="line">            <span class="comment"># 则要将方格还原，进行下一种可能的搜寻</span></span><br><span class="line">            arr_map[tx][ty] = <span class="number">0</span></span><br><span class="line">            arr_map[<span class="number">6</span>-tx][<span class="number">6</span>-ty] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 初始化方格代表(0,0)到(6,6)的位置</span></span><br><span class="line">arr_map = [[<span class="number">0</span>] * <span class="number">7</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)]</span><br><span class="line"><span class="comment"># 4个方向</span></span><br><span class="line">dirs = [(<span class="number">1</span>,<span class="number">0</span>), (-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 中间点置1 代表走过</span></span><br><span class="line">arr_map[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 分割方法</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="comment"># 从中间点索引往两边走</span></span><br><span class="line">dfs(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 由于旋转对称的属于同一种分割方法,故最终结果要除以4</span></span><br><span class="line"><span class="built_in">print</span>(ans//<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p><strong>题目描述</strong></p><blockquote><p>求出区间[a,b]中所有整数的质因数分解。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入两个整数a，b。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>每行输出一个数的分解，形如k=a1*a2*a3…(a1&lt;=a2&lt;=a3…，k也是从小到大的)</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3 10</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3=3<br>4=2*2<br>5=5<br>6=2*3<br>7=7<br>8=2*2*2<br>9=3*3<br>10=2*5</p></blockquote><p>2&lt;=a&lt;=b&lt;=10000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="comment"># 遍历该数的可能因子</span></span><br><span class="line">    <span class="comment"># 最大因子只到该数的开方</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(<span class="built_in">float</span>(num)**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 若能找到因子</span></span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 输出该因子</span></span><br><span class="line">            <span class="built_in">print</span>((<span class="string">&#x27;%d*&#x27;</span>) % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="comment"># 继续分解</span></span><br><span class="line">            factor(num // i)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 若找不到，返回本身</span></span><br><span class="line">    <span class="built_in">print</span>(num, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 遍历该区间的数</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(a, b+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%d=&#x27;</span>%num, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    factor(num)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p><strong>题目描述</strong></p><blockquote><p>1/1 + 1/2 + 1/4 + 1/8 + 1/16 + …<br>每项是前一项的一半，如果一共有20项,<br>求这个和是多少，结果用分数表示出来。<br>类似：<br>3/2<br>当然，这只是加了前2项而已。分子分母要求互质。</p><p>注意：<br>需要提交的是已经约分过的分数，中间任何位置不能含有空格。<br>请不要填写任何多余的文字或符号</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        c = a % b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="comment"># 分子</span></span><br><span class="line">molecule = <span class="number">0</span></span><br><span class="line"><span class="comment"># 因为1/1 + 1/2 + ... + 1/2^19通分后</span></span><br><span class="line"><span class="comment"># = 2^19/2^19 + 2^18/2^19 + ... + 1/2^19</span></span><br><span class="line"><span class="comment"># 则分子和为2^19 + 2^18 + ... + 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    molecule += <span class="number">2</span> ** i</span><br><span class="line"><span class="comment"># 分母为2^19</span></span><br><span class="line">gc = gcd(molecule, <span class="number">2</span> ** <span class="number">19</span>)</span><br><span class="line"><span class="comment"># 输出约分后的结果</span></span><br><span class="line"><span class="built_in">print</span>(molecule // gc , <span class="string">&#x27;/&#x27;</span>, <span class="number">2</span> ** <span class="number">19</span> // gc, sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="复数求和"><a href="#复数求和" class="headerlink" title="复数求和"></a>复数求和</h3><p><strong>题目描述</strong></p><blockquote><p>从键盘读入n个复数（实部和虚部都为整数）用链表存储，遍历链表求出n个复数的和并输出。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3<br>3 4<br>5 2<br>1 3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>9+9i</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>7<br>1 2<br>3 4<br>2 5<br>1 8<br>6 4<br>7 9<br>3 7</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>23+39i</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">real = <span class="number">0</span></span><br><span class="line">imaginary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    real += arr[i][<span class="number">0</span>]</span><br><span class="line">    imaginary += arr[i][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(real,<span class="string">&#x27;+&#x27;</span>,imaginary,<span class="string">&#x27;i&#x27;</span>, sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="购物单"><a href="#购物单" class="headerlink" title="购物单"></a>购物单</h3><p><strong>题目描述</strong></p><blockquote><p>小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。</p><p>这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。<br>小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。<br>现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。</p><p>取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。<br>你的任务是计算出，小明最少需要取多少现金。<br>以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。<br>**** 180.90 88折<br>**** 10.25 65折<br>**** 56.14 9折<br>**** 104.65 9折<br>**** 100.30 88折<br>**** 297.15 半价<br>**** 26.75 65折<br>**** 130.62 半价<br>**** 240.28 58折<br>**** 270.62 8折<br>**** 115.87 88折<br>**** 247.34 95折<br>**** 73.21 9折<br>**** 101.00 半价<br>**** 79.54 半价<br>**** 278.44 7折<br>**** 199.26 半价<br>**** 12.97 9折<br>**** 166.30 78折<br>**** 125.50 58折<br>**** 84.98 9折<br>**** 113.35 68折<br>**** 166.57 半价<br>**** 42.56 9折<br>**** 81.90 95折<br>**** 131.78 8折<br>**** 255.89 78折<br>**** 109.17 9折<br>**** 146.69 68折<br>**** 139.33 65折<br>**** 141.16 78折<br>**** 154.74 8折<br>**** 59.42 8折<br>**** 85.44 68折<br>**** 293.70 88折<br>**** 261.79 65折<br>**** 11.30 88折<br>**** 268.27 58折<br>**** 128.29 88折<br>**** 251.03 8折<br>**** 208.39 75折<br>**** 128.88 75折<br>**** 62.06 9折<br>**** 225.87 75折<br>**** 12.89 75折<br>**** 34.28 75折<br>**** 62.16 58折<br>**** 129.12 半价<br>**** 218.37 半价<br>**** 289.69 8折</p><p>需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。<br>特别地，半价是按50%计算。</p><p>请提交小明要从取款机上提取的金额，单位是元。<br>答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。</p></blockquote><p>首先在把数据复制到记事本中，用Ctrl+H键替换，把<code>****</code>用空格替换，把7折、8折、9折替换为70、80、90，半价替换为50。<br><code>item.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">180.90  88  </span><br><span class="line"> 10.25  65  </span><br><span class="line"> 56.14   90  </span><br><span class="line">104.65   90  </span><br><span class="line">100.30  88  </span><br><span class="line">297.15  50  </span><br><span class="line"> 26.75  65  </span><br><span class="line">130.62  50  </span><br><span class="line">240.28  58  </span><br><span class="line">270.62   80  </span><br><span class="line">115.87  88  </span><br><span class="line">247.34  95  </span><br><span class="line"> 73.21   90  </span><br><span class="line">101.00  50  </span><br><span class="line"> 79.54  50  </span><br><span class="line">278.44   70  </span><br><span class="line">199.26  50  </span><br><span class="line"> 12.97   90  </span><br><span class="line">166.30  78  </span><br><span class="line">125.50  58  </span><br><span class="line"> 84.98   90  </span><br><span class="line">113.35  68  </span><br><span class="line">166.57  50  </span><br><span class="line"> 42.56   90  </span><br><span class="line"> 81.90  95  </span><br><span class="line">131.78   80  </span><br><span class="line">255.89  78  </span><br><span class="line">109.17   90  </span><br><span class="line">146.69  68  </span><br><span class="line">139.33  65  </span><br><span class="line">141.16  78  </span><br><span class="line">154.74   80  </span><br><span class="line"> 59.42   80  </span><br><span class="line"> 85.44  68  </span><br><span class="line">293.70  88  </span><br><span class="line">261.79  65  </span><br><span class="line"> 11.30  88  </span><br><span class="line">268.27  58  </span><br><span class="line">128.29  88  </span><br><span class="line">251.03   80  </span><br><span class="line">208.39  75  </span><br><span class="line">128.88  75  </span><br><span class="line"> 62.06   90  </span><br><span class="line">225.87  75  </span><br><span class="line"> 12.89  75  </span><br><span class="line"> 34.28  75  </span><br><span class="line"> 62.16  58  </span><br><span class="line">129.12  50  </span><br><span class="line">218.37  50  </span><br><span class="line">289.69  80 </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;item.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    price, rate = <span class="built_in">map</span>(<span class="built_in">float</span>, line.split())</span><br><span class="line">    ans += price * rate / <span class="number">100</span></span><br><span class="line">file.close()</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h3 id="龟兔赛跑预测"><a href="#龟兔赛跑预测" class="headerlink" title="龟兔赛跑预测"></a>龟兔赛跑预测</h3><p><strong>题目描述</strong></p><blockquote><p>话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。</p><p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1, v2&lt;=100; t&lt;=300; s&lt;=10; l&lt;=10000且为v1, v2的公倍数)</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。<br>第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>10 5 5 2 20</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>D<br>4</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>10 5 5 1 20</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>R<br>3</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>10 5 5 3 20</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>T<br>4</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v1, v2, t, s, l = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">rabbit = <span class="number">0</span></span><br><span class="line">tortoise = <span class="number">0</span></span><br><span class="line">time = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> rabbit == l <span class="keyword">or</span> tortoise == l:  <span class="comment"># 如果兔子或乌龟到达终点，结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> rabbit - tortoise &gt;= t:  <span class="comment"># 兔子达到领先条件，休息</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s):  <span class="comment"># 休息时间按秒增加，乌龟路程按秒增加</span></span><br><span class="line">            tortoise += v2</span><br><span class="line">            time += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> tortoise == l:  </span><br><span class="line">                <span class="comment"># 兔子休息时，乌龟到达了终点，结束。</span></span><br><span class="line">                <span class="comment"># 注意：有可能兔子在休息中，乌龟就到达了终点</span></span><br><span class="line">                <span class="comment"># 所以休息时间未必循环完</span></span><br><span class="line">                <span class="comment"># 如：兔子要休息10s，乌龟可能在兔子休息的第9s就到达了终点</span></span><br><span class="line">                <span class="comment"># 这里的flag就起到提前结束的功能</span></span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:  <span class="comment"># 如果提前结束，则全部结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    time += <span class="number">1</span>  <span class="comment"># 每走一秒，兔子和乌龟按相应速度增加相应距离</span></span><br><span class="line">    rabbit += v1</span><br><span class="line">    tortoise += v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rabbit &gt; tortoise:  <span class="comment"># 谁先到达终点，谁的距离大</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> rabbit &lt; tortoise:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 相等则平局</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(time)</span><br></pre></td></tr></table></figure><h3 id="合根植物"><a href="#合根植物" class="headerlink" title="合根植物"></a>合根植物</h3><p><strong>题目描述</strong></p><blockquote><p>w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了一株合根植物。<br>这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。</p><p>如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。<br>接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000)<br>接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。</p><p>格子的编号一行一行，从上到下，从左到右编号。<br>比如：5 * 4 的小格子，编号：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16<br>17 18 19 20</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5 4<br>16<br>2 3<br>1 5<br>5 9<br>4 8<br>7 8<br>9 10<br>10 11<br>11 12<br>10 14<br>12 16<br>14 18<br>17 18<br>15 19<br>19 20<br>9 13<br>13 17</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>5</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>其合根情况参考下图：</p><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/RequireFile.do" alt></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">并查集算法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 用于找到x的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rootFind</span>(<span class="params">x</span>):</span></span><br><span class="line">    p = x </span><br><span class="line">    <span class="comment">#如果x的父节点不是他本身，就一直循坏到找到父节点为之</span></span><br><span class="line">    <span class="keyword">while</span> x != pre[x]: </span><br><span class="line">        x = pre[x]</span><br><span class="line">    <span class="comment"># 压缩路径，这个是优化的，所以可加可不加</span></span><br><span class="line">    <span class="keyword">while</span> p != x: <span class="comment"># 若当前节点不是父节点，找到父节点后，把沿途每个节点的根节点都设成父节点，使树变得扁平，以减小深度</span></span><br><span class="line">       p, pre[p] = pre[p], x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">cnt = m * n</span><br><span class="line"><span class="comment"># pre列表中存储的是每个节点的父节点</span></span><br><span class="line">pre = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt+<span class="number">1</span>)]</span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    roota = rootFind(a)</span><br><span class="line">    rootb = rootFind(b)</span><br><span class="line">    <span class="keyword">if</span> roota != rootb: </span><br><span class="line">        <span class="comment"># 如果父节点不一样就合并, 选任意一方为父</span></span><br><span class="line">        pre[roota] = pre[rootb]</span><br><span class="line">        <span class="comment">#同时合并的话，集合就会少一个</span></span><br><span class="line">        cnt -= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure><h3 id="换钞票"><a href="#换钞票" class="headerlink" title="换钞票"></a>换钞票</h3><p><strong>题目描述</strong></p><blockquote><p>x星球的钞票的面额只有：100元，5元，2元，1元，共4种。<br>小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。<br>小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，<br>剩下的当然都是5元面额的。</p><p>银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？<br>（5元，2元，1元面额的必须都有，不能是0）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总共200元</span></span><br><span class="line">total = <span class="number">200</span></span><br><span class="line"><span class="comment"># 由于2元是1元的10倍，即扣掉5元钞票的钱数，应为21的倍数</span></span><br><span class="line"><span class="comment"># 要使换的钱数最少，则5元的钞票要多</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span> // <span class="number">21</span>):</span><br><span class="line">    total -= <span class="number">21</span></span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 共换了多少张钞票</span></span><br><span class="line">        count = <span class="number">10</span> * i + i + total // <span class="number">5</span></span><br><span class="line">        <span class="built_in">print</span>(count)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="回形取数"><a href="#回形取数" class="headerlink" title="回形取数"></a>回形取数</h3><p><strong>题目描述</strong></p><blockquote><p>回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3 3<br>1 2 3<br>4 5 6<br>7 8 9</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1 4 7 8 9 6 3 2 5</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3 2<br>1 2<br>3 4<br>5 6</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1 3 5 6 4 2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">matrix = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    arr = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        matrix[i].append(<span class="built_in">int</span>(arr[j]))</span><br><span class="line"><span class="comment"># 初始位置</span></span><br><span class="line">x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># 外框到里框的个数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(m, n)//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">     <span class="comment"># 向下取数</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; m <span class="keyword">and</span> matrix[x][y] != -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(matrix[x][y], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        matrix[x][y] = -<span class="number">1</span>  <span class="comment"># 将去过的位置置为-1</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上个循环结束后x多加一次要减回来</span></span><br><span class="line">    x -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 列值加1，因为第零列在上个循环已经输出，往右推一行</span></span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向右取数</span></span><br><span class="line">    <span class="keyword">while</span>  y &lt; n <span class="keyword">and</span> matrix[x][y] != -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(matrix[x][y], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        matrix[x][y] = -<span class="number">1</span>  <span class="comment"># 将去过的位置置为-1</span></span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上个循环多加一次减回来</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 往上推一行</span></span><br><span class="line">    x -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向上取数</span></span><br><span class="line">    <span class="keyword">while</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> matrix[x][y] != -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(matrix[x][y], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        matrix[x][y] = -<span class="number">1</span>  <span class="comment"># 将去过的位置置为-1</span></span><br><span class="line">        x -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上个循环使多减一次加回来</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 往左推一行</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向左取数</span></span><br><span class="line">    <span class="keyword">while</span> y &gt;= <span class="number">0</span> <span class="keyword">and</span> matrix[x][y] != -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(matrix[x][y], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        matrix[x][y] = -<span class="number">1</span>  <span class="comment"># 将去过的位置置为-1</span></span><br><span class="line">        y -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上个循环多加一次减回来</span></span><br><span class="line">    y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向下推一行</span></span><br><span class="line">    x += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="金陵十三钗"><a href="#金陵十三钗" class="headerlink" title="金陵十三钗"></a>金陵十三钗</h3><p><strong>题目描述</strong></p><blockquote><p>在电影《金陵十三钗》中有十二个秦淮河的女人要自我牺牲代替十二个女学生去赴日本人的死亡宴会。为了不让日本人发现，自然需要一番乔装打扮。但由于天生材质的原因，每个人和每个人之间的相似度是不同的。由于我们这是编程题，因此情况就变成了金陵n钗。给出n个女人和n个学生的相似度矩阵，求她们之间的匹配所能获得的最大相似度。</p><p>所谓相似度矩阵是一个n*n的二维数组<code>like[i][j]</code>。其中i, j分别为女人的编号和学生的编号，皆从0到n-1编号。<code>like[i][j]</code>是一个0到100的整数值，表示第i个女人和第j个学生的相似度，值越大相似度越大，比如0表示完全不相似，100表示百分之百一样。每个女人都需要找一个自己代替的女学生。</p><p>最终要使两边一一配对，形成一个匹配。请编程找到一种匹配方案，使各对女人和女学生之间的相似度之和最大。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行一个正整数n表示有n个秦淮河女人和n个女学生<br>接下来n行给出相似度，每行n个0到100的整数，依次对应二维矩阵的n行n列。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>仅一行，一个整数，表示可获得的最大相似度。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4<br>97 91 68 14<br>8 33 27 92<br>36 32 98 53<br>73 7 17 82</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>354</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>最大相似度为91+92+98+73=354</p></blockquote><p>对于70%的数据，n&lt;=10<br>对于100%的数据，n&lt;=13</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本题类似n皇后问题，先列举出所有可能，在求其中和最大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queen</span>(<span class="params">cur=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> maxSum</span><br><span class="line">    <span class="comment"># 判断上行的棋子放置是否有问题</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(cur-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 若该女学生已被其他女人匹配</span></span><br><span class="line">        <span class="keyword">if</span> res[row] == res[cur-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 向上回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若匹配完毕</span></span><br><span class="line">    <span class="keyword">if</span> cur == n:</span><br><span class="line">        <span class="comment"># 算出当前排列的和</span></span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur_sum += matrix[i][res[i]]</span><br><span class="line">        <span class="comment"># 储存最大和</span></span><br><span class="line">        <span class="keyword">if</span> cur_sum &gt; maxSum:</span><br><span class="line">            maxSum = cur_sum</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每列</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 设置秦淮河女人匹配的女学生</span></span><br><span class="line">        res[cur] = col</span><br><span class="line">        <span class="comment"># 对下一个秦淮河女人进行匹配</span></span><br><span class="line">        queen(cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 相似度矩阵</span></span><br><span class="line">matrix = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">maxSum = <span class="number">0</span></span><br><span class="line">queen()</span><br><span class="line"><span class="built_in">print</span>(maxSum)</span><br></pre></td></tr></table></figure><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p><strong>题目描述</strong></p><blockquote><p>给定一个N阶矩阵A，输出A的M次幂（M是非负整数）<br>例如：<br>A =<br>1 2<br>3 4<br>A的2次幂<br>7 10<br>15 22</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数<br>接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>2 2<br>1 2<br>3 4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>7 10<br>15 22</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_matrix</span>(<span class="params">matrix1, matrix2, n</span>):</span></span><br><span class="line">    <span class="comment"># 存放乘法后的矩阵</span></span><br><span class="line">    res = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 遍历每个元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            pos = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 乘法后所得结果该位置的值等于两个数组该行和该列的加权</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                pos += matrix1[i][c] * matrix2[c][j]</span><br><span class="line">            res[i].append(pos)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">matrix = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    arr = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        matrix[i].append(<span class="built_in">int</span>(arr[j]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化单位矩阵</span></span><br><span class="line">res = [[<span class="number">1</span> <span class="keyword">if</span> i == j <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># m次幂</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">    res = mul_matrix(res, matrix, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(res[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h3 id="矩阵面积交"><a href="#矩阵面积交" class="headerlink" title="矩阵面积交"></a>矩阵面积交</h3><p><strong>题目描述</strong></p><blockquote><p>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入仅包含两行，每行描述一个矩形。<br>在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过$10^7$的实数表示。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出仅包含一个实数，为交的面积。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>1 1 3 3<br>2 2 4 4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rect1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">rect2 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">x1 = <span class="built_in">max</span>(<span class="built_in">min</span>(rect1[<span class="number">0</span>], rect1[<span class="number">2</span>]), <span class="built_in">min</span>(rect2[<span class="number">0</span>], rect2[<span class="number">2</span>]))</span><br><span class="line">y1 = <span class="built_in">max</span>(<span class="built_in">min</span>(rect1[<span class="number">1</span>], rect1[<span class="number">3</span>]), <span class="built_in">min</span>(rect2[<span class="number">1</span>], rect2[<span class="number">3</span>]))</span><br><span class="line">x2 = <span class="built_in">min</span>(<span class="built_in">max</span>(rect1[<span class="number">0</span>], rect1[<span class="number">2</span>]), <span class="built_in">max</span>(rect2[<span class="number">0</span>], rect2[<span class="number">2</span>]))</span><br><span class="line">y2 = <span class="built_in">min</span>(<span class="built_in">max</span>(rect1[<span class="number">1</span>], rect1[<span class="number">3</span>]), <span class="built_in">max</span>(rect2[<span class="number">1</span>], rect2[<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># 交集的面积</span></span><br><span class="line">inter = <span class="built_in">max</span>(x2-x1, <span class="number">0</span>) * <span class="built_in">max</span>(y2-y1, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(inter)</span><br></pre></td></tr></table></figure><h3 id="矩阵求和"><a href="#矩阵求和" class="headerlink" title="矩阵求和"></a>矩阵求和</h3><p><strong>题目描述</strong></p><blockquote><p>今天小明的任务是填满这么一张表： 表有n行n列，行和列的编号都从1算起。 其中第i行第j个元素的值是gcd(i, j)的平方，gcd表示最大公约数，以下是这个表的前四行的前四列：</p><p>1 1 1 1<br>1 4 1 4<br>1 1 9 1<br>1 4 1 16</p><p>小明突然冒出一个奇怪的想法，他想知道这张表中所有元素的和。 由于表过于庞大，他希望借助计算机的力量。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>一行一个正整数n意义见题。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一行一个数，表示所有元素的和。由于答案比较大，请输出模 (10^9 + 7)后的结果。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>48</p></blockquote><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%92%8C.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; 方法一：暴力求解会超时</span></span><br><span class="line"><span class="string"># 求最大公约数</span></span><br><span class="line"><span class="string">def gcd(i, j):</span></span><br><span class="line"><span class="string">    while j !=0:</span></span><br><span class="line"><span class="string">        k = i % j</span></span><br><span class="line"><span class="string">        i, j = j, k</span></span><br><span class="line"><span class="string">    return i</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">n = int(input())</span></span><br><span class="line"><span class="string">sum_arr = 0</span></span><br><span class="line"><span class="string">mod = 10 ** 9 + 7</span></span><br><span class="line"><span class="string">for i in range(1, n+1):</span></span><br><span class="line"><span class="string">    for j in range(1, n+1):</span></span><br><span class="line"><span class="string">        t = gcd(i, j) ** 2</span></span><br><span class="line"><span class="string">        sum_arr += t % mod</span></span><br><span class="line"><span class="string">print(sum_arr)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;方法二：欧拉函数（线性筛法）推荐&#x27;&#x27;&#x27;</span></span><br><span class="line">MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="comment"># 欧拉函数</span></span><br><span class="line">phi = []</span><br><span class="line"><span class="comment"># 存放[1, n/d]中，所有互质对的个数</span></span><br><span class="line">sum_ = []</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euler_table</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        phi.append(<span class="number">0</span>)</span><br><span class="line">        sum_.append(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># n=1时的欧拉函数为1</span></span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 求到n为止的欧拉函数(线性筛法)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># ph[i]为0时代表没遍历过，则此时i为素数</span></span><br><span class="line">        <span class="keyword">if</span> phi[i] == <span class="number">0</span>:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt;= n:</span><br><span class="line">                <span class="comment"># 先令phi[j] = j,则ph[j] / i = j / i = i^(k-1)</span></span><br><span class="line">                <span class="keyword">if</span> phi[j] == <span class="number">0</span>:</span><br><span class="line">                    phi[j] = j</span><br><span class="line">                <span class="comment"># 当i是素数时 phi(i) = i-1</span></span><br><span class="line">                <span class="comment"># phi(i^k) = i^(k-1) * (i-1) </span></span><br><span class="line">                <span class="comment"># 这里j = i^k</span></span><br><span class="line">                phi[j] = phi[j] // i * (i - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 进行递推，求得相应的phi[j]，使phi[j]上的值不再为0，那么下次遍历i时，若为0，则代表i为素数</span></span><br><span class="line">                j += i</span><br><span class="line">    sum_[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 递推，求互质对的个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        sum_[i] = sum_[i - <span class="number">1</span>] + phi[i] * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">euler_table(n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 将问题转化成了count(d)*d*d</span></span><br><span class="line">    ans = (ans + sum_[n // i] * i % MOD * i) % MOD</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h3 id="门牌制作"><a href="#门牌制作" class="headerlink" title="门牌制作"></a>门牌制作</h3><p><strong>题目描述</strong></p><blockquote><p>小蓝要为一条街的住户制作门牌号。</p><p>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。</p><p>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。</p><p>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><p>这是一道结果填空的题，你只需要算出结果后提交即可。<br>本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2021</span>):</span><br><span class="line">    count += <span class="built_in">str</span>(num).count(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><p><strong>题目描述</strong></p><blockquote><p>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。</p><p>010000<br>000100<br>001001<br>110000</p><p>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。</p><p>对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D&lt;L&lt;R&lt;U。</p></blockquote><p><code>data.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">01010101001011001001010110010110100100001000101010</span><br><span class="line">00001000100000101010010000100000001001100110100101</span><br><span class="line">01111011010010001000001101001011100011000000010000</span><br><span class="line">01000000001010100011010000101000001010101011001011</span><br><span class="line">00011111000000101000010010100010100000101100000000</span><br><span class="line">11001000110101000010101100011010011010101011110111</span><br><span class="line">00011011010101001001001010000001000101001110000000</span><br><span class="line">10100000101000100110101010111110011000010000111010</span><br><span class="line">00111000001010100001100010000001000101001100001001</span><br><span class="line">11000110100001110010001001010101010101010001101000</span><br><span class="line">00010000100100000101001010101110100010101010000101</span><br><span class="line">11100100101001001000010000010101010100100100010100</span><br><span class="line">00000010000000101011001111010001100000101010100011</span><br><span class="line">10101010011100001000011000010110011110110100001000</span><br><span class="line">10101010100001101010100101000010100000111011101001</span><br><span class="line">10000000101100010000101100101101001011100000000100</span><br><span class="line">10101001000000010100100001000100000100011110101001</span><br><span class="line">00101001010101101001010100011010101101110000110101</span><br><span class="line">11001010000100001100000010100101000001000111000010</span><br><span class="line">00001000110000110101101000000100101001001000011101</span><br><span class="line">10100101000101000000001110110010110101101010100001</span><br><span class="line">00101000010000110101010000100010001001000100010101</span><br><span class="line">10100001000110010001000010101001010101011111010010</span><br><span class="line">00000100101000000110010100101001000001000000000010</span><br><span class="line">11010000001001110111001001000011101001011011101000</span><br><span class="line">00000110100010001000100000001000011101000000110011</span><br><span class="line">10101000101000100010001111100010101001010000001000</span><br><span class="line">10000010100101001010110000000100101010001011101000</span><br><span class="line">00111100001000010000000110111000000001000000001011</span><br><span class="line">10000001100111010111010001000110111010101101111000</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">path = [[0,1,0,0,0,0],</span></span><br><span class="line"><span class="string">[0,0,0,1,0,0],</span></span><br><span class="line"><span class="string">[0,0,1,0,0,1],</span></span><br><span class="line"><span class="string">[1,1,0,0,0,0]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">path =[]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    contents = file.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> contents:</span><br><span class="line">    path.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">list</span>(i.strip()))))</span><br><span class="line"><span class="comment"># 迷宫的实质就是一个矩阵，即用（x，y）即可表示迷宫内的任意一点，再用一个字符串w来表示路径。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, w</span>):</span></span><br><span class="line">        self.x = x	<span class="comment"># 记录横坐标</span></span><br><span class="line">        self.y = y	<span class="comment"># 记录纵坐标</span></span><br><span class="line">        self.w = w	<span class="comment"># 记录路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">return</span> self.w	<span class="comment"># 输出路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Node(node.x - <span class="number">1</span>, node.y, node.w+<span class="string">&quot;U&quot;</span>)	<span class="comment"># 上的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">down</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Node(node.x + <span class="number">1</span>, node.y, node.w+<span class="string">&quot;D&quot;</span>)	<span class="comment"># 下的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Node(node.x, node.y - <span class="number">1</span>, node.w+<span class="string">&quot;L&quot;</span>)	<span class="comment"># 左的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Node(node.x, node.y + <span class="number">1</span>, node.w+<span class="string">&quot;R&quot;</span>)	<span class="comment"># 右的情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    row, col = <span class="built_in">len</span>(path), <span class="built_in">len</span>(path[<span class="number">0</span>]) <span class="comment"># 矩阵的长和宽</span></span><br><span class="line">    visited = <span class="built_in">set</span>() <span class="comment"># 记录访问过的点</span></span><br><span class="line">    queue = []</span><br><span class="line">    node = Node(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>) <span class="comment"># 设置起点</span></span><br><span class="line">    <span class="comment"># 存放进队列</span></span><br><span class="line">    queue.append(node)</span><br><span class="line">    <span class="comment"># 由于每次开始移动前先弹出，若后续没步走，则队列为0，结束</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">        moveNode = queue[<span class="number">0</span>] <span class="comment"># 设置当前移动点为moveNode</span></span><br><span class="line">        <span class="comment"># 开始移动前先弹出</span></span><br><span class="line">        queue.pop(<span class="number">0</span>)				</span><br><span class="line">        moveStr = <span class="built_in">str</span>(moveNode.x) + <span class="string">&quot; &quot;</span>+ <span class="built_in">str</span>(moveNode.y) <span class="comment"># 用于记录当前坐标是否走过</span></span><br><span class="line">        <span class="comment"># 若没走过则进行记录</span></span><br><span class="line">        <span class="keyword">if</span> moveStr <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(moveStr)</span><br><span class="line">            <span class="keyword">if</span> moveNode.x == row - <span class="number">1</span> <span class="keyword">and</span> moveNode.y == col - <span class="number">1</span>: <span class="comment"># 若到达终点则输出且退出循环</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(moveNode.__str__()))	<span class="comment"># 输出步数</span></span><br><span class="line">                <span class="built_in">print</span>(moveNode)	<span class="comment"># 打印路径</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> moveNode.x &lt; row - <span class="number">1</span> :	<span class="comment"># 首先顺序为下,不能超出边界</span></span><br><span class="line">                <span class="comment"># 若没有障碍物，则可以通行</span></span><br><span class="line">                <span class="keyword">if</span> path[moveNode.x + <span class="number">1</span>][moveNode.y] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 添加进队列</span></span><br><span class="line">                    queue.append(down(moveNode))</span><br><span class="line">            <span class="keyword">if</span> moveNode.y &gt; <span class="number">0</span>:	<span class="comment"># 第二顺序是左</span></span><br><span class="line">                <span class="keyword">if</span> path[moveNode.x][moveNode.y - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(left(moveNode))</span><br><span class="line">            <span class="keyword">if</span> moveNode.y &lt; col - <span class="number">1</span>: <span class="comment"># 第三顺序是右</span></span><br><span class="line">                <span class="keyword">if</span> path[moveNode.x][moveNode.y + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(right(moveNode))</span><br><span class="line">            <span class="keyword">if</span> moveNode.x &gt; <span class="number">0</span>:	<span class="comment"># 最后顺序是上</span></span><br><span class="line">                <span class="keyword">if</span> path[moveNode.x - <span class="number">1</span>][moveNode.y] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(up(moveNode))</span><br></pre></td></tr></table></figure><h3 id="迷宫2"><a href="#迷宫2" class="headerlink" title="迷宫2"></a>迷宫2</h3><p><strong>题目描述</strong></p><blockquote><p>X星球的一处迷宫游乐场建在某个小山坡上。它是由10x10相互连通的小房间组成的。房间的地板上写着一个很大的字母。</p><p>我们假设玩家是面朝上坡的方向站立，则：L表示走到左边的房间，R表示走到右边的房间，U表示走到上坡方向的房间，D表示走到下坡方向的房间。</p><p>X星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！</p><p>开始的时候，直升机把100名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。</p><p>请你计算一下，最后，有多少玩家会走出迷宫?而不是在里边兜圈子。</p><p>如果你还没明白游戏规则，可以参看一个简化的4x4迷宫的解说图：</p><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxNzE0NTk1OTk1" alt></p></blockquote><p>迷宫地图<code>迷宫2.txt</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UDDLUULRUL</span><br><span class="line">UURLLLRRRU</span><br><span class="line">RRUURLDLRD</span><br><span class="line">RUDDDDUUUU</span><br><span class="line">URUDLLRRUU</span><br><span class="line">DURLRLDLRL</span><br><span class="line">ULLURLLRDU</span><br><span class="line">RDLULLRDDD</span><br><span class="line">UUDDUDUDLL</span><br><span class="line">ULRDLUURRR</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">global</span> rows</span><br><span class="line">    <span class="keyword">global</span> cols</span><br><span class="line">    <span class="comment"># 走出迷宫，计数+1</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt; rows-<span class="number">1</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt; cols-<span class="number">1</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 若当前位置未走过，则标记为走过</span></span><br><span class="line">    <span class="keyword">if</span> paths[x][y] == <span class="number">0</span>:</span><br><span class="line">        paths[x][y] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 若已走过，则代表回到原路，走不出迷宫，退出</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 获取方向</span></span><br><span class="line">    direction = dataMap[x][y]</span><br><span class="line">    <span class="comment"># 上</span></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">        dfs(x-<span class="number">1</span>, y)</span><br><span class="line">    <span class="comment"># 下</span></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        dfs(x+<span class="number">1</span>, y)</span><br><span class="line">    <span class="comment"># 左</span></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        dfs(x, y-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 右</span></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">        dfs(x, y+<span class="number">1</span>)    </span><br><span class="line"><span class="comment"># 存储地图</span></span><br><span class="line">dataMap = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;迷宫2.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        dataMap.append(<span class="built_in">list</span>(line.strip()))</span><br><span class="line">rows = <span class="built_in">len</span>(dataMap)</span><br><span class="line">cols = <span class="built_in">len</span>(dataMap[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 记录走出人数</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        <span class="comment"># 用于记录走过的轨迹，未走过为0，走过为1</span></span><br><span class="line">        paths = [[<span class="number">0</span>]*cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        dfs(x, y)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="年号字串"><a href="#年号字串" class="headerlink" title="年号字串"></a>年号字串</h3><p><strong>题目描述</strong></p><blockquote><p>小明用字母A 对应数字1，B 对应2，以此类推，用Z 对应26。对于27以上的数字，小明用两位或更长位的字符串来对应，例如AA 对应27，AB 对应28，AZ 对应52，LQ 对应329。请问2019 对应的字符串是什么？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">n = <span class="number">2019</span></span><br><span class="line"><span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">    t = n % <span class="number">26</span></span><br><span class="line">    n = n // <span class="number">26</span></span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="number">64</span>+t)</span><br><span class="line"><span class="built_in">print</span>(ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="跑步锻炼"><a href="#跑步锻炼" class="headerlink" title="跑步锻炼"></a>跑步锻炼</h3><p><strong>题目描述</strong></p><blockquote><p>小蓝每天都锻炼身体。<br>正常情况下，小蓝每天跑1千米。如果某天是周一或者月初（1日），为了激励自己，小蓝要跑2千米。如果同时是周一或月初，小蓝也是跑2千米。<br>小蓝跑步已经坚持了很长时间，从2000年1月1日周六（含）到2020年10月1日周四（含）。请问这段时间小蓝总共跑步多少千米</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历日期可以用到datetime这个内置库</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一个是初始日期，一个是结束日期，因为range函数是半开半闭，所以结束日期要比要求的大一天</span></span><br><span class="line">start = datetime.datetime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">end = datetime.datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="comment"># 用结束日期-初始日期就能得到之间相差的天数。也就是遍历次数</span></span><br><span class="line"><span class="keyword">for</span> day <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>((end -  start).days)):</span><br><span class="line">    <span class="comment"># 再用初始天数，加上每次遍历的天数，就可以得到当前日期</span></span><br><span class="line">    <span class="comment"># 使用timedelta可以很方便的在日期上做天days，小时hour，分钟，秒，毫秒，微妙的时间计算</span></span><br><span class="line">    cur_date = start +  datetime.timedelta(days=day)</span><br><span class="line">    <span class="comment"># 用.strftime()方法可以访问这一天的各种参数</span></span><br><span class="line">    <span class="comment"># 获取天数和星期,为1日或星期1跑2km</span></span><br><span class="line">    <span class="keyword">if</span> (cur_date.strftime(<span class="string">&#x27;%d&#x27;</span>)) == <span class="string">&#x27;01&#x27;</span> <span class="keyword">or</span>  (cur_date.strftime(<span class="string">&#x27;%w&#x27;</span>)) == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">2</span></span><br><span class="line">    <span class="comment"># 否则为1km</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><h3 id="平面切分"><a href="#平面切分" class="headerlink" title="平面切分"></a>平面切分</h3><p><strong>题目描述</strong></p><blockquote><p>平面上有 N条直线，其中第i条直线是 y = Ai*x + B。</p><p>请计算这些直线将平面分成了几个部分。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行包含一个整数N。<br>以下N行，每行包含两个整数Ai, Bi。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一个整数代表答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3<br>1 1<br>2 2<br>3 3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>6</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在同一个平面内，如果添加的每一条直线互不相交，则每添加一条直线，就会增加一个平面；</span></span><br><span class="line"><span class="comment"># 当添加一条直线时，这条直线与当前平面内已有直线每产生一个不同位置的交点时</span></span><br><span class="line"><span class="comment"># 这条直线对平面总数量的贡献会额外增多一个</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">lines = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment">#这里是去掉重复直线</span></span><br><span class="line">lines = <span class="built_in">list</span>(<span class="built_in">set</span>(lines))</span><br><span class="line">n = <span class="built_in">len</span>(lines)</span><br><span class="line"><span class="comment">#得到两条直线交点，若平行，返回None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getnode</span>(<span class="params">lines1, lines2</span>):</span></span><br><span class="line">    A1 = lines1[<span class="number">0</span>]</span><br><span class="line">    B1 = lines1[<span class="number">1</span>]</span><br><span class="line">    A2 = lines2[<span class="number">0</span>]</span><br><span class="line">    B2 = lines2[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> A1 - A2 == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    x = (B2 - B1) / (A1 - A2)</span><br><span class="line">    y = A1 * x + B1</span><br><span class="line">    <span class="keyword">return</span> (x, y)</span><br><span class="line"><span class="comment"># 每条线对分割平面的贡献 默认为1，即两两平行</span></span><br><span class="line">ci = [<span class="number">1</span>] * n</span><br><span class="line"><span class="comment"># 交点去重</span></span><br><span class="line">node = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    node.clear()</span><br><span class="line">    <span class="comment"># 判断新增加的线与之前线是否有交点</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        tmp = getnode(lines[i], lines[j])</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line">        node.add(tmp)</span><br><span class="line">    <span class="comment"># 每有个交点贡献多1</span></span><br><span class="line">    ci[i] += <span class="built_in">len</span>(node)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(ci) + <span class="number">1</span>) </span><br></pre></td></tr></table></figure><h3 id="全球变暖"><a href="#全球变暖" class="headerlink" title="全球变暖"></a>全球变暖</h3><p><strong>题目描述</strong></p><blockquote><p>你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。</p><p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p><p>例如上图中的海域未来会变成如下样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">....#..</span><br><span class="line">.......</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行包含一个整数N。 (1 &lt;= N &lt;= 1000)</p><p>以下N行N列代表一张海域照片。</p><p>照片保证第1行、第1列、第N行、第N列的像素都是海洋。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一个整数表示答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>7<br>…….<br>.##….<br>.##….<br>….##.<br>..####.<br>…###.<br>…….</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路:</span></span><br><span class="line"><span class="string">在接收初始图之后，首先搜索查找初始岛屿数，在找到一个岛屿后，对整个岛屿进行标记，防止重复计数。</span></span><br><span class="line"><span class="string">随后再次进行搜索，如果有四周均为陆地的坐标，则标记此坐标未被淹没。</span></span><br><span class="line"><span class="string">最后查找所有未被淹没的坐标，并将坐标所处的整个岛标记，防止重复计数。</span></span><br><span class="line"><span class="string">初始岛屿数量减去未被淹没岛的数量，即为被淹没的岛的数量。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;例子1：</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string">.##....</span></span><br><span class="line"><span class="string">.##....</span></span><br><span class="line"><span class="string">....##.</span></span><br><span class="line"><span class="string">..####.</span></span><br><span class="line"><span class="string">...###.</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;例子2：</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string">.#.#.</span></span><br><span class="line"><span class="string">..#..</span></span><br><span class="line"><span class="string">.#.#.</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 用于搜寻岛屿的数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 如果该点是海洋或者已被访问过则跳过</span></span><br><span class="line">    <span class="keyword">if</span> maps[x][y] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span>  maps[x][y] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">	    <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 否则将该点标记为1，代表已访问过</span></span><br><span class="line">    maps[x][y] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment"># 搜索该点四周的点</span></span><br><span class="line">    dfs(x+<span class="number">1</span>, y)</span><br><span class="line">    dfs(x-<span class="number">1</span>, y)</span><br><span class="line">    dfs(x, y+<span class="number">1</span>)</span><br><span class="line">    dfs(x, y-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 初始海洋照片</span></span><br><span class="line">maps = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 初始岛屿个数</span></span><br><span class="line">first_num = <span class="number">0</span></span><br><span class="line"><span class="comment"># 剩余岛屿个数</span></span><br><span class="line">res_num = <span class="number">0</span></span><br><span class="line"><span class="comment"># 初始岛屿个数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> maps[x][y] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                dfs(x, y)</span><br><span class="line">                first_num += <span class="number">1</span></span><br><span class="line"><span class="comment"># 海域未来模样</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 照片保证第1行、第1列、第N行、第N列的像素都是海洋。</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> x == n-<span class="number">1</span> <span class="keyword">or</span> y == <span class="number">0</span> <span class="keyword">or</span> y == n-<span class="number">1</span> <span class="keyword">or</span> maps[x][y] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 四周都是陆地则标记为2，代表该岛屿不会被淹没</span></span><br><span class="line">        <span class="keyword">if</span> maps[x+<span class="number">1</span>][y] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> maps[x-<span class="number">1</span>][y] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> maps[x][y+<span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> maps[x][y-<span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            maps[x][y] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">        <span class="comment"># 否则标记为3代表将被淹没</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maps[x][y] = <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="comment"># 最后查找剩余多少个岛屿</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> maps[x][y] == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                dfs(x, y)</span><br><span class="line">                res_num += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出淹没了多少座岛</span></span><br><span class="line"><span class="built_in">print</span>(first_num - res_num)</span><br></pre></td></tr></table></figure><h3 id="蛇形填数"><a href="#蛇形填数" class="headerlink" title="蛇形填数"></a>蛇形填数</h3><p><strong>题目描述</strong></p><blockquote><p>如下图所示，小明用从1开始的正整数“蛇形”填充无限大的矩阵。<br>1 2 6 7 15 …<br>3 5 8 14 …<br>4 9 13 …<br>10 12 …<br>11 …<br>…<br>容易看出矩阵第二行第二列中的数是5。请你计算矩阵中第20行第20列的数是多少？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lis = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>)]</span><br><span class="line">num = <span class="number">1</span>  <span class="comment"># 记录当前的数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">41</span>):  <span class="comment"># 层数</span></span><br><span class="line">    <span class="keyword">for</span> j, k <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(i)), <span class="built_in">list</span>(<span class="built_in">range</span>(num, num + i))):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 偶数层</span></span><br><span class="line">            lis[j][i-j-<span class="number">1</span>] = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lis[i-j-<span class="number">1</span>][j] = k</span><br><span class="line">    num += i</span><br><span class="line"><span class="built_in">print</span>(lis[<span class="number">19</span>][<span class="number">19</span>])</span><br></pre></td></tr></table></figure><h3 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a>石子游戏</h3><p><strong>题目描述</strong></p><blockquote><p>石子游戏的规则如下：</p><p>地上有n堆石子，每次操作可选取两堆石子（石子个数分别为x和y）并将它们合并，操作的得分记为(x+1)×(y+1)，对地上的石子堆进行操作直到只剩下一堆石子时停止游戏。</p><p>请问在整个游戏过程中操作的总得分的最大值是多少？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入数据的第一行为整数n，表示地上的石子堆数；第二行至第n+1行是每堆石子的个数。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>程序输出一行，为游戏总得分的最大值。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>10<br>5105<br>19400<br>27309<br>19892<br>27814<br>25129<br>19272<br>12517<br>25419<br>4053</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>15212676150</p></blockquote><p>1≤n≤1000，1≤一堆中石子数≤50000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆数</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 每堆石子的个数</span></span><br><span class="line">data = [<span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 先排序</span></span><br><span class="line">data.sort()</span><br><span class="line"><span class="comment"># 分数</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="comment"># 贪心算法，每次取最大两堆合并</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(data) != <span class="number">1</span>:</span><br><span class="line">    result += (data[-<span class="number">1</span>] + <span class="number">1</span>) * (data[-<span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">    data[-<span class="number">2</span>] += data[-<span class="number">1</span>]</span><br><span class="line">    data.pop(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h3><p><strong>题目描述</strong></p><blockquote><p>给定一个以秒为单位的时间t，要求用H:M:S的格式来表示这个时间。H表示时间，M表示分钟，而S表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出只有一行，是以“H:M:S”的格式所表示的时间，不包括引号。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>0</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>0:0:0</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5436</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1:30:36</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%d:%d:%d&#x27;</span>%(t//<span class="number">3600</span>, t%<span class="number">3600</span>//<span class="number">60</span>, t%<span class="number">3600</span>%<span class="number">60</span>))</span><br></pre></td></tr></table></figure><h3 id="数的读法"><a href="#数的读法" class="headerlink" title="数的读法"></a>数的读法</h3><p><strong>题目描述</strong></p><blockquote><p>Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。</p><p>所以，他迫切地需要一个系统，然后当他输入1234567009时，会给出相应的念法：十二亿三千四百五十六万七千零九，用汉语拼音表示为shi er yi san qian si bai wu shi liu wan qi qian ling jiu，这样他只需要照着念就可以了。</p><p>你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。</p><p>注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>有一个数字串，数值大小不超过2,000,000,000。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>1234567009</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>shi er yi san qian si bai wu shi liu wan qi qian ling jiu</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment"># 数值读法</span></span><br><span class="line">pin_yin = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;ling&#x27;</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;yi&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;er&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;san&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;si&#x27;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;wu&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;liu&#x27;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;qi&#x27;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;ba&#x27;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;jiu&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 特殊位置读法</span></span><br><span class="line">pin_yin_2 = &#123;<span class="number">0</span>: <span class="string">&#x27;&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;shi&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;bai&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;qian&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;wan&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;shi&#x27;</span>,</span><br><span class="line">             <span class="number">6</span>: <span class="string">&#x27;bai&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;qian&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;yi&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;shi&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 个位的索引</span></span><br><span class="line">l = <span class="built_in">len</span>(n) - <span class="number">1</span></span><br><span class="line"><span class="comment"># 从最高位开始遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)):</span><br><span class="line">    <span class="comment"># 当前位的值</span></span><br><span class="line">    cur = <span class="built_in">int</span>(n[i])</span><br><span class="line">    <span class="comment"># 当前位的值不为0时的读法</span></span><br><span class="line">    <span class="keyword">if</span> cur != <span class="number">0</span>:  </span><br><span class="line">        <span class="comment"># 个位与当前位索引相差1,、5、9，即在十位，十万位，十亿位置且开头为1时</span></span><br><span class="line">        <span class="comment"># 不读出1</span></span><br><span class="line">        <span class="comment"># 如10， shi ; 100000, shi wan; 1000000000, shi yi</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="number">1</span> <span class="keyword">and</span> i == <span class="number">0</span> <span class="keyword">and</span> (l - i == <span class="number">1</span> <span class="keyword">or</span> l - i == <span class="number">5</span> <span class="keyword">or</span> l - i == <span class="number">9</span>):</span><br><span class="line">            <span class="built_in">print</span>(pin_yin_2[l - i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 输出当前数的读法</span></span><br><span class="line">        <span class="built_in">print</span>(pin_yin[n[i]], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="comment"># 输出指定位置的读法</span></span><br><span class="line">        <span class="built_in">print</span>(pin_yin_2[l - i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="comment"># 处理当前位的值为0的读法问题</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="comment"># 如果此0是在万位或亿位，则读出万或亿</span></span><br><span class="line">        <span class="comment"># 如shi wan, shi yi</span></span><br><span class="line">        <span class="keyword">if</span> l - i == <span class="number">4</span> <span class="keyword">or</span> l - i == <span class="number">8</span>:  </span><br><span class="line">            <span class="built_in">print</span>(pin_yin_2[l - i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="comment"># 如果后一位仍然为0，或者，当前是最后一位，则不读此0</span></span><br><span class="line">        <span class="keyword">elif</span> (i &lt; l <span class="keyword">and</span> n[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> i == l:  </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则才读出这个零</span></span><br><span class="line">            <span class="built_in">print</span>(pin_yin[<span class="string">&#x27;0&#x27;</span>], end=<span class="string">&#x27; &#x27;</span>)  </span><br></pre></td></tr></table></figure><h3 id="数的分解"><a href="#数的分解" class="headerlink" title="数的分解"></a>数的分解</h3><p><strong>题目描述</strong></p><blockquote><p>把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 因为三个数要各不相同 i从小到大 j从小到大并比i大，则为了保证不重,k也因比j大</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2019</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(i) <span class="keyword">and</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(i):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="number">2019</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(j) <span class="keyword">and</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(j):</span><br><span class="line">                k = <span class="number">2019</span> - i - j</span><br><span class="line">                <span class="keyword">if</span> k &gt; j <span class="keyword">and</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(k) <span class="keyword">and</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(k):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="数列求值"><a href="#数列求值" class="headerlink" title="数列求值"></a>数列求值</h3><p><strong>题目描述</strong></p><blockquote><p>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</p><p>给定数列 1, 1, 1, 3, 5, 9, 17,⋯，从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f0=<span class="number">1</span></span><br><span class="line">f1=<span class="number">1</span></span><br><span class="line">f2=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">20190324</span>):</span><br><span class="line">    result = (f0 + f1 + f2) % <span class="number">10000</span></span><br><span class="line">    f0 = f1</span><br><span class="line">    f1 = f2</span><br><span class="line">    f2 = result</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="数位递增的数"><a href="#数位递增的数" class="headerlink" title="数位递增的数"></a>数位递增的数</h3><p><strong>题目描述</strong></p><blockquote><p>一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含一个整数n。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行包含一个整数，表示答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>30</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>26</p></blockquote><p>对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>对于所有评测用例，1 &lt;= n &lt;= 1000000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    num = <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(num) == <span class="number">1</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[j] &gt; num[j+<span class="number">1</span>]:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="数字9"><a href="#数字9" class="headerlink" title="数字9"></a>数字9</h3><p><strong>题目描述</strong></p><blockquote><p>在1至2019中，有多少个数的数位中包含数字9？</p><p>注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2020</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;9&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(num):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><strong>题目描述</strong></p><blockquote><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/tri.png" alt></p><p>图为一个数字三角形。 请编一个程序计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。<br>● 每一步可沿左斜线向下或右斜线向下走；<br>● 1＜三角形行数≤100；<br>● 三角形中的数字为整数0，1，…99；</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>首先读到的是三角形的行数。</p><p>接下来描述整个三角形</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>最大总和（整数）</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>30</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathMax</span>(<span class="params">path, x, y, leftNum, rightNum</span>):</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="comment"># 添加当前路径</span></span><br><span class="line">    path.append(pyramid[x][y])</span><br><span class="line">    <span class="comment"># 如果走到底返回</span></span><br><span class="line">    <span class="keyword">if</span> x == n-<span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 左下和右下次数相差不超过1，记录路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftNum - rightNum) &lt;= <span class="number">1</span>:</span><br><span class="line">            paths.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pleft = []</span><br><span class="line">    pright = []</span><br><span class="line">    pleft += path</span><br><span class="line">    pright += path</span><br><span class="line">    <span class="comment"># 左下走</span></span><br><span class="line">    pathMax(pleft, x+<span class="number">1</span>, y, leftNum+<span class="number">1</span>, rightNum)</span><br><span class="line">    <span class="comment"># 右下走</span></span><br><span class="line">    pathMax(pright, x+<span class="number">1</span>, y+<span class="number">1</span>, leftNum, rightNum+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">pyramid = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 用于所有可能路径</span></span><br><span class="line">paths = []</span><br><span class="line">pathMax([], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="comment"># 返回最大路径</span></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">    tmp = <span class="built_in">sum</span>(path)</span><br><span class="line">    <span class="keyword">if</span> tmp &gt; res:</span><br><span class="line">        res = tmp</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="特别数的和"><a href="#特别数的和" class="headerlink" title="特别数的和"></a>特别数的和</h3><p><strong>题目描述</strong></p><blockquote><p>小明对数位中含有2 、 0 、 1 、 9 的数字很感兴趣（不包括前导 0 ），在 1 到 40 中这样的数包括 1 、 2 、 9 、 10 至 32 、 39 和 40 ，共 28 个，他们的和是 574 。请问，在1 到 n 中，所有这样的数的和是多少？</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行包含一个整数n。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行，包含一个整数，表示满足条件的数的和。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>40</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>574</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">input</span>())+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(i) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(i) <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(i) <span class="keyword">or</span> <span class="string">&#x27;9&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(i):</span><br><span class="line">        res += i</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="特殊回文数"><a href="#特殊回文数" class="headerlink" title="特殊回文数"></a>特殊回文数</h3><p><strong>题目描述</strong></p><blockquote><p>123321是一个非常特殊的数，它从左边读和从右边读是一样的。</p><p>输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行，包含一个正整数n。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>按从小到大的顺序输出满足条件的整数，每个整数占一行。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>52</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>899998<br>989989<br>998899</p></blockquote><p>1&lt;=n&lt;=54</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="comment">#6位数，n一定为偶数</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">    s = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> (s - i - j) &lt; <span class="number">10</span> <span class="keyword">and</span> (s - i - j) &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="built_in">str</span>(i)+<span class="built_in">str</span>(j)+<span class="built_in">str</span>(s-i-j)*<span class="number">2</span>+<span class="built_in">str</span>(j)+<span class="built_in">str</span>(i)))</span><br><span class="line"><span class="comment">#5位数，n减去中间那个数一定为偶数  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (n - i) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s = (n - i) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> s &lt;= <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> (s - j) &gt;= <span class="number">0</span> <span class="keyword">and</span> (s - j) &lt; <span class="number">10</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="built_in">str</span>(j)+<span class="built_in">str</span>(s-j)+<span class="built_in">str</span>(i)+<span class="built_in">str</span>(s-j)+<span class="built_in">str</span>(j)))</span><br><span class="line">               </span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(end - start)</span><br></pre></td></tr></table></figure><h3 id="完美的代价"><a href="#完美的代价" class="headerlink" title="完美的代价"></a>完美的代价</h3><p><strong>题目描述</strong></p><blockquote><p>回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。</p><p>交换的定义是：交换两个相邻的字符，例如mamad</p><p>第一次交换 ad : mamda</p><p>第二次交换 md : madma</p><p>第三次交换 ma : madam (回文！完美！)</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)<br>第二行是一个字符串，长度为N.只包含小写字母</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>如果可能，输出最少的交换次数。<br>否则输出Impossible</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5<br>mamad</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 统计出现奇数次的字符的个数</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="comment"># 交换次数</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 由于最后形成回文，只需遍历一半即可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">    <span class="comment"># 从另一半寻找是否有字符与之相等</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, i - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 没找到</span></span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            <span class="comment"># 记录奇数个数的字符</span></span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果有一个字符出现的次数是奇数次数，而且n是偶数，那么不可能构成回文</span></span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> flag == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Impossible&#x27;</span>)</span><br><span class="line">                exit()</span><br><span class="line">            <span class="comment"># 如果奇数次数的字符出现两个以上，那么不可能构成回文</span></span><br><span class="line">            <span class="keyword">if</span>  flag &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Impossible&#x27;</span>)</span><br><span class="line">                exit() </span><br><span class="line">        <span class="comment"># 若找到</span></span><br><span class="line">        <span class="keyword">elif</span> arr[j] == arr[i]:</span><br><span class="line">            <span class="comment"># 一直将其交换到对应位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(j, n-<span class="number">1</span>-i):</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                <span class="comment"># 记录交换次数</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="完全二叉树的权值"><a href="#完全二叉树的权值" class="headerlink" title="完全二叉树的权值"></a>完全二叉树的权值</h3><p><strong>题目描述</strong></p><blockquote><p>给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 A1, A2, · · · AN，如下图所示：</p><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/image-20220302170648228.png" alt></p><p>现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。</p><p>注：根的深度是 1。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行包含一个整数 N。<br>第二行包含 N 个整数 A1, A2, · · · AN 。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数代表答案。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>7<br>1 6 5 4 3 2 1</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>2</p></blockquote><p>对于所有评测用例， 1 ≤ N ≤ 100000， −100000 ≤ Ai ≤ 100000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 二叉树深度</span></span><br><span class="line">deep = <span class="number">1</span></span><br><span class="line"><span class="comment"># 用于记录权值最大的深度</span></span><br><span class="line">max_deep = deep</span><br><span class="line"><span class="comment"># 记录最大权重</span></span><br><span class="line">max_sum = <span class="number">0</span></span><br><span class="line"><span class="comment"># 深度为deep的完全二叉树节点个数为(2^n)-1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">2</span> ** deep - <span class="number">1</span> &lt;= n:</span><br><span class="line">    <span class="comment"># 当前深度的节点个数 = 当前深度完全二叉树的总个数-上层深度完全二叉树的总个数</span></span><br><span class="line">    data_sum = <span class="built_in">sum</span>(data[<span class="number">2</span> ** (deep - <span class="number">1</span>) - <span class="number">1</span>: <span class="number">2</span> ** deep - <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 记录最大权重所在深度</span></span><br><span class="line">    <span class="keyword">if</span> max_sum &lt; data_sum:</span><br><span class="line">        max_sum = data_sum</span><br><span class="line">        max_deep = deep</span><br><span class="line">    deep += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出最大权重所在深度</span></span><br><span class="line"><span class="built_in">print</span>(max_deep)</span><br></pre></td></tr></table></figure><h3 id="晚会节目单"><a href="#晚会节目单" class="headerlink" title="晚会节目单"></a>晚会节目单</h3><p><strong>题目描述</strong></p><blockquote><p>小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。</p><p>这 n个节目是按照小明设想的顺序给定的，顺序不能改变。</p><p>小明发现，观众对于晚会的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。</p><p>小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。<br>第二行包含 n 个整数，依次为每个节目的好看值。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行包含 m 个整数，为选出的节目的好看值。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5 3<br>3 1 2 5 4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3 5 4</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>选择了第1, 4, 5个节目。</p></blockquote><p>对于 30% 的评测用例，1 &lt;= n &lt;= 20；<br>对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>对于所有评测用例，1 &lt;= n&lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">tvlist = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 选最大</span></span><br><span class="line">res = []</span><br><span class="line"><span class="comment"># 开始索引</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="comment"># 当前个数为0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 直到选满m个</span></span><br><span class="line"><span class="keyword">while</span> count &lt; m:</span><br><span class="line">    <span class="comment"># 从选出的值对应的索引序号后开始到n - m + count中选</span></span><br><span class="line">    res.append(<span class="built_in">max</span>(tvlist[index: n - m + count + <span class="number">1</span>]))</span><br><span class="line">    index = tvlist[index: n - m + count + <span class="number">1</span>].index(res[count]) + index + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计数</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(*res)</span><br><span class="line"><span class="comment"># n,m =map(int,input().split())</span></span><br><span class="line"><span class="comment"># tvlist = list(map(int, input().split()))</span></span><br><span class="line"><span class="comment"># maxTv= tvlist.copy()</span></span><br><span class="line"><span class="comment"># maxTv.sort(reverse=True)</span></span><br><span class="line"><span class="comment"># maxTv = maxTv[:m]</span></span><br><span class="line"><span class="comment"># count = 0</span></span><br><span class="line"><span class="comment"># for tv in tvlist:</span></span><br><span class="line"><span class="comment">#     if tv in maxTv:</span></span><br><span class="line"><span class="comment">#         print(tv, end=&#x27; &#x27;)</span></span><br><span class="line"><span class="comment">#         count += 1</span></span><br><span class="line"><span class="comment">#         if count == m:</span></span><br><span class="line"><span class="comment">#             break</span></span><br></pre></td></tr></table></figure><h3 id="芯片测试"><a href="#芯片测试" class="headerlink" title="芯片测试"></a>芯片测试</h3><p><strong>题目描述</strong></p><blockquote><p>有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。</p><p>每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。</p><p>给出所有芯片的测试结果，问哪些芯片是好芯片。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入数据第一行为一个整数n，表示芯片个数。<br>第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>按从小到大的顺序输出所有好芯片的编号</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>3<br>1 0 1<br>0 1 0<br>1 0 1</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1 3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    arr_ = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i].append(<span class="built_in">int</span>(arr_[j]))</span><br><span class="line"><span class="comment"># 既然好芯片比坏芯片多，那么我们只需记录每一列0的个数就行了，若个数超过n/2，则此芯片为坏芯片</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> arr[i][j] == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; n / <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(j+<span class="number">1</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="幸运顾客"><a href="#幸运顾客" class="headerlink" title="幸运顾客"></a>幸运顾客</h3><p><strong>题目描述</strong></p><blockquote><p>为了吸引更多的顾客，某商场决定推行有奖抽彩活动。“本商场每日将产生一名幸运顾客，凡购买30元以上商品者均有机会获得本商场提供的一份精美礼品。”该商场的幸运顾客产生方式十分奇特：每位顾客可至抽奖台抽取一个幸运号码，该商场在抽奖活动推出的第i天将从所有顾客中（包括不在本日购物满30元者）挑出幸运号第i小的顾客作为当日的幸运顾客。该商场的商品本就价廉物美，自从有奖活动推出后，顾客更是络绎不绝，因此急需你编写一个程序，为他解决幸运顾客的产生问题。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第1行一个整数N，表示命令数。<br>第2~N+1行，每行一个数，表示命令。如果x&gt;=0，表示有一顾客抽取了号码x；如果x=-1，表示傍晚抽取该日的幸运号码。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>对应各命令-1输出幸运号码；每行一个号码。(两个相同的幸运号看作两个号码)</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>6<br>3<br>4<br>-1<br>-1<br>3<br>-1</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3<br>4<br>4</p></blockquote><p>共10组数据。<br>对100%的数据，N=$10^6$所有命令为-1或int范围内的非负数，前i的命令中-1的数量不超过[i/2]（向下取整）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 存放号码</span></span><br><span class="line">consumer = []</span><br><span class="line"><span class="comment"># 统计-1的个数</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="comment"># 存放结果</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    data = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> data != -<span class="number">1</span>:</span><br><span class="line">        consumer.append(data)</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        consumer.sort()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(consumer[ans])</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h3><p><strong>题目描述</strong></p><blockquote><p>小明想知道，满足以下条件的正整数序列的数量：</p><ol><li><p>第一项为n；</p></li><li><p>第二项不超过n；</p></li><li><p>从第三项开始，每一项小于前两项的差的绝对值。</p><p>请计算，对于给定的n，有多少种满足条件的序列。</p></li></ol></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行包含一个整数n。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>7</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>以下是满足条件的序列：<br>4 1<br>4 1 1<br>4 1 2<br>4 2<br>4 2 1<br>4 3<br>4 4</p></blockquote><p>对于 20% 的评测用例，1 &lt;= n &lt;= 5；<br>对于 50% 的评测用例，1 &lt;= n &lt;= 10；<br>对于 80% 的评测用例，1 &lt;= n &lt;= 100；<br>对于所有评测用例，1 &lt;= n &lt;= 1000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于派生下一项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_item</span>(<span class="params">res</span>):</span></span><br><span class="line">    new_res = []</span><br><span class="line">    <span class="comment"># 当前序列最后两项的绝对差</span></span><br><span class="line">    ab = <span class="built_in">abs</span>(res[-<span class="number">2</span>] - res[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 若能派生出下一项</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ab):</span><br><span class="line">        <span class="comment"># 则新序列为当前序列加下一项</span></span><br><span class="line">        new_res.append(res + [i])</span><br><span class="line">    <span class="keyword">return</span> new_res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一项</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 用于记录序列</span></span><br><span class="line">res_list = []</span><br><span class="line"><span class="comment"># 用于记录可派生项</span></span><br><span class="line">accept_list = []</span><br><span class="line"><span class="comment"># 用于循环</span></span><br><span class="line">temp_list = []</span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 第二项</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 记录此时的第一项和第二项</span></span><br><span class="line">    res_list.append([n, i])</span><br><span class="line"><span class="comment"># 记录此时的序列用于循环</span></span><br><span class="line">temp_list += res_list</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> temp_list:  <span class="comment"># 判断temp_list的每一项</span></span><br><span class="line">        next_ = next_item(res)  <span class="comment"># 判断这项可以再派生下一项</span></span><br><span class="line">        <span class="comment"># 添加记录到accept_list</span></span><br><span class="line">        accept_list += next_</span><br><span class="line">    temp_list.clear()  <span class="comment"># 清空</span></span><br><span class="line">    res_list = accept_list + res_list  <span class="comment"># 把新派生出的项加到res_list，res_list此时已包含两项加新派生的项</span></span><br><span class="line">    temp_list += accept_list  <span class="comment"># 新派生的项加到temp_list进行下次循环用</span></span><br><span class="line">    accept_list.clear() <span class="comment"># 清空</span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res_list:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res_list) % <span class="number">10000</span>)</span><br></pre></td></tr></table></figure><h3 id="寻找2020"><a href="#寻找2020" class="headerlink" title="寻找2020"></a>寻找2020</h3><p><strong>题目描述</strong></p><blockquote><p>小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。</p><p>小蓝只关注三种构成 2020 的方式：<br>• 同一行里面连续四个字符从左到右构成 2020。<br>• 同一列里面连续四个字符从上到下构成 2020。<br>• 在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。</p><p>例如，对于下面的矩阵：<br>220000<br>000000<br>002202<br>000000<br>000022<br>002020<br>一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。</p><p>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件<code>2020.txt</code>，里面给出了小蓝的矩阵。</p><p>请帮助小蓝确定在他的矩阵中有多少个 2020。</p></blockquote><p><code>2020.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">220000</span><br><span class="line">000000</span><br><span class="line">002202</span><br><span class="line">000000</span><br><span class="line">000022</span><br><span class="line">002020</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nums, result=[], <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2020.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        nums.append(<span class="built_in">list</span>(line.strip()))</span><br><span class="line">move=[[<span class="number">0</span>, <span class="number">1</span>],[<span class="number">1</span>, <span class="number">0</span>],[<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums[<span class="number">0</span>])):       </span><br><span class="line">        <span class="keyword">for</span> xx, yy <span class="keyword">in</span> move:</span><br><span class="line">            num = <span class="built_in">str</span>(nums[x][y])</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                x_, y_= x + xx * m, y + yy * m</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= x_ &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> <span class="number">0</span> &lt;= y_ &lt;<span class="built_in">len</span>(nums[<span class="number">0</span>]):</span><br><span class="line">                    num += <span class="built_in">str</span>(nums[x_][y_])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="string">&#x27;2020&#x27;</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p><strong>题目描述</strong></p><blockquote><p>杨辉三角形又称Pascal三角形，它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。</p><p>下面给出了杨辉三角形的前4行：</p><p>1</p><p>1 1</p><p>1 2 1</p><p>1 3 3 1</p><p>给出n，输出它的前n行。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入包含一个数n。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1<br>1 1<br>1 2 1<br>1 3 3 1</p></blockquote><p>1 &lt;= n &lt;= 34。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">triangle_yang = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">triangle_yang[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="comment"># 每一行的第一列和最后一列为1</span></span><br><span class="line">    triangle_yang[i][<span class="number">0</span>], triangle_yang[i][-<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="comment"># 其余为两肩数值之和</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">        triangle_yang[i][j] = triangle_yang[i-<span class="number">1</span>][j-<span class="number">1</span>] + triangle_yang[i-<span class="number">1</span>][j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 输出杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(triangle_yang[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h3 id="叶节点数"><a href="#叶节点数" class="headerlink" title="叶节点数"></a>叶节点数</h3><p><strong>题目描述</strong></p><blockquote><p>一棵包含有2019个结点的二叉树，最多包含多少个叶结点？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n为深度</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">2</span> ** n - <span class="number">1</span> &lt; <span class="number">2019</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"><span class="comment"># 2019节点多于深度为n-1的二叉树，小于深度为n的二叉树，通过普通的数学计算，可得最后层的叶子节点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ** n - <span class="number">1</span> - (<span class="number">2</span> ** (n - <span class="number">1</span>) - <span class="number">1</span>) - (<span class="number">2</span> ** n - <span class="number">1</span> - <span class="number">2019</span>) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="音节判断"><a href="#音节判断" class="headerlink" title="音节判断"></a>音节判断</h3><p><strong>题目描述</strong></p><blockquote><p>小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。</p><p>给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。</p><p>元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行，包含一个单词，单词中只包含小写英文字母。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出答案，或者为yes，或者为no。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>lanqiao</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>yes</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>world</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>no</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">alpha = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">    <span class="keyword">if</span> str1[i] <span class="keyword">in</span> alpha <span class="keyword">and</span> str1[i-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> alpha:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">2</span> <span class="keyword">and</span> str1[i] <span class="keyword">not</span> <span class="keyword">in</span> alpha:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span>(flag <span class="keyword">and</span> count == <span class="number">2</span>): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="预测身高"><a href="#预测身高" class="headerlink" title="预测身高"></a>预测身高</h3><p><strong>题目描述</strong></p><blockquote><p>生理卫生老师在课堂上娓娓道来：<br>你能看见你未来的样子吗？显然不能。但你能预测自己成年后的身高，有公式：<br>男孩成人后身高=（父亲身高+母亲身高）/ 2 * 1.08<br>女孩成人后身高=(父亲身高*0.923+母亲身高）/ 2<br>数学老师听见了，回头说：这是大样本统计拟合公式，准确性不错。<br>生物老师听见了，回头说：结果不是绝对的，影响身高的因素很多，比如营养、疾病、体育锻炼、睡眠、情绪、环境因素等。<br>老师们齐回头，看见同学们都正在预测自己的身高。<br>毛老师见此情形，推推眼镜说：何必手算，编程又快又简单…<br>约定：<br>身高的单位用米表示，所以自然是会有小数的。<br>男性用整数1表示，女性用整数0表示。<br>预测的身高保留三位小数</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>用空格分开的三个数，整数 小数 小数<br>分别表示：性别 父亲身高 母亲身高</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一个小数，表示根据上述表示预测的身高（保留三位小数）</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>1 1.91 1.70</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1.949</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>0 1.00 2.077</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1.500</p></blockquote><p>父母身高范围（0，3]<br>时间限制1.0秒</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sex, dad, mom = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(sex) == <span class="number">0</span>:</span><br><span class="line">    height = (dad * <span class="number">0.923</span> + mom) / <span class="number">2</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    height = (dad + mom) / <span class="number">2</span>*<span class="number">1.08</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.3f&#x27;</span> % height)</span><br></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p><strong>题目描述</strong></p><blockquote><p>1200000有多少个约数（只计算正约数）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 根据对称，只要到根号即可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">float</span>(<span class="number">1200000</span>)**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1200000</span> % i == <span class="number">0</span>:</span><br><span class="line">        count += <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><h3 id="长草"><a href="#长草" class="headerlink" title="长草"></a>长草</h3><p><strong>题目描述</strong></p><blockquote><p>小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>请告诉小明，k 个月后空地上哪些地方有草。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含两个整数 n, m。<br>接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>接下来包含一个整数 k。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>4 5<br>.g…<br>…..<br>..g..<br>…..<br>2</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>gggg.<br>gggg.<br>ggggg<br>.ggg.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grow</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> R:</span><br><span class="line">        x1 = x + offset[<span class="number">0</span>]</span><br><span class="line">        y1 = y + offset[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> y1 &gt;= <span class="number">0</span> <span class="keyword">and</span> y1 &lt; m <span class="keyword">and</span> x1 &gt;= <span class="number">0</span> <span class="keyword">and</span> x1 &lt; n <span class="keyword">and</span> area[x1][y1] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            area[x1][y1] = <span class="string">&#x27;g&#x27;</span></span><br><span class="line">            flag[x1][y1] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">area = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 上下左右</span></span><br><span class="line">R = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 长草月数</span></span><br><span class="line"><span class="keyword">for</span> month <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    <span class="comment"># 记录已经生长过的草位置</span></span><br><span class="line">    flag = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> area[i][j] == <span class="string">&#x27;g&#x27;</span> <span class="keyword">and</span> flag[i][j] == <span class="number">0</span>:</span><br><span class="line">                flag[i][j] = <span class="number">1</span></span><br><span class="line">                grow(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出第k月长草情况</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> area:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(row))</span><br></pre></td></tr></table></figure><h3 id="长整数加法"><a href="#长整数加法" class="headerlink" title="长整数加法"></a>长整数加法</h3><p><strong>题目描述</strong></p><blockquote><p>输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行，表示a + b的值。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>20100122201001221234567890<br>2010012220100122</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>20100122203011233454668012</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">arr1 = <span class="built_in">input</span>()</span><br><span class="line">arr2 = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment"># 比较两者长度，进行补0</span></span><br><span class="line">length = <span class="built_in">len</span>(arr1) - <span class="built_in">len</span>(arr2)</span><br><span class="line"><span class="keyword">if</span> length &gt; <span class="number">0</span>:</span><br><span class="line">    arr2 = <span class="string">&#x27;0&#x27;</span> * length + arr2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    arr1 = <span class="string">&#x27;0&#x27;</span> * (-length) + arr1</span><br><span class="line"><span class="comment"># 存放结果</span></span><br><span class="line">result = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1)+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 进位</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1)):</span><br><span class="line">    <span class="comment"># 从个位开始加，同时加上进位</span></span><br><span class="line">    <span class="built_in">sum</span> = k + <span class="built_in">int</span>(arr1[<span class="built_in">len</span>(arr1)-i-<span class="number">1</span>]) + <span class="built_in">int</span>(arr2[<span class="built_in">len</span>(arr1)-i-<span class="number">1</span>]) </span><br><span class="line">    <span class="comment"># 从个位开始存放结果</span></span><br><span class="line">    result[<span class="built_in">len</span>(arr1) - i] = <span class="built_in">sum</span> % <span class="number">10</span></span><br><span class="line">    <span class="comment"># 设置进位</span></span><br><span class="line">    k = <span class="built_in">sum</span> // <span class="number">10</span></span><br><span class="line"><span class="comment"># 最高位进位</span></span><br><span class="line"><span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">    result[<span class="number">0</span>] = k</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1)+<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 排除最高位为0的情况</span></span><br><span class="line">    <span class="keyword">if</span> result[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(result[i], end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="装饰珠"><a href="#装饰珠" class="headerlink" title="装饰珠"></a>装饰珠</h3><p><strong>题目描述</strong></p><blockquote><p>在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取 相应的技能，以提升自己的战斗能力。</p><p>已知猎人身上一共有 6 件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠 (也可以选择不镶嵌)。</p><p>装饰珠有 M 种，编号 1 至 M，分别对应 M 种技能，第 i 种装饰珠的等级为 $L_i$，只能镶嵌在等级大于等于 $L_i$ 的装饰孔中。<br>对第 i 种技能来说，当装备相应技能的装饰珠数量达到 $K_i$个时，会产生$W_i(K_i)$的价值，镶嵌同类技能的数量越多，产生的价值越大，即$W_i(K_{i-1})&lt;W_i(K_i)$。但每个技能都有上限$P_i$(1≤$P_i$≤7)，当装备的珠子数量超过$P_i$时，只会产生$W_i(P_i)$的价值。</p><p>对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得 6 件装备能得到的总价值达到最大。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第 1 至 6 行，包含 6 件装备的描述。其中第i行的第一个整数$N_i$表示第i件装备的装饰孔数量。后面紧接着$N_i$个整数，分别表示该装备上每个装饰孔的等级L(1≤ L ≤4)。<br>第 7 行包含一个正整数 M，表示装饰珠 (技能) 种类数量。<br>第 8 至 M + 7 行，每行描述一种装饰珠 (技能) 的情况。每行的前两个整数$L_j$(1≤ $L_j$ ≤4)和$P_j$(1≤ $P_j$ ≤7)分别表示第 j 种装饰珠的等级和上限。接下来$P_j$个整数，其中第 k 个数表示装备该中装饰珠数量为 k 时的价值$W_j(k)$。<br>其中1 ≤ $N_i$ ≤ 50，1 ≤ M ≤ $10^4$，1 ≤ $W_j(k)$ ≤ $10^4$。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行包含一个整数，表示能够得到的最大价值。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>1 1<br>2 1 2<br>1 1<br>2 2 2<br>1 1<br>1 3<br>3<br>1 5 1 2 3 5 8<br>2 4 2 4 8 15<br>3 2 5 10</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>20</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>按照如下方式镶嵌珠子得到最大价值 20，括号内表示镶嵌的装饰珠的种类编号：<br>1: (1)<br>2: (1) (2)<br>3: (1)<br>4: (2) (2)<br>5: (1)<br>6: (2)</p><p>4 颗技能 1 装饰珠，4 颗技能 2 装饰珠$W_1(4) + W_2(4) = 5 + 15 = 20$。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curItem表示当前装备索引</span></span><br><span class="line"><span class="comment"># curHole表示当前孔洞索引</span></span><br><span class="line"><span class="comment"># holeNum表示当前装备孔洞总数量</span></span><br><span class="line"><span class="comment"># skillNums记录孔洞装备情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">holeValue</span>(<span class="params">skillNums, curItem, curHole, holeNum, phole</span>):</span></span><br><span class="line">    <span class="comment"># 遍历完所有孔，记录数据退出</span></span><br><span class="line">    <span class="keyword">if</span> curHole == holeNum:</span><br><span class="line">        phole.append(skillNums)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 当前孔位的装备容量</span></span><br><span class="line">    maxLimit = items[curItem][curHole+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 如果技能等级小等容量，则可以装备</span></span><br><span class="line">        <span class="keyword">if</span> skills[j][<span class="number">0</span>] &lt;= maxLimit:</span><br><span class="line">            tmp = []</span><br><span class="line">            tmp += skillNums</span><br><span class="line">            tmp[j] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 记录当前孔装备技能</span></span><br><span class="line">            holeValue(tmp, curItem, curHole+<span class="number">1</span>, holeNum, phole)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索所有的可能价值</span></span><br><span class="line"><span class="comment"># skillNums用于封装各个技能的数量</span></span><br><span class="line"><span class="comment"># cur代表当前是第几号装备</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allValue</span>(<span class="params">skillNums, cur</span>):</span></span><br><span class="line">    <span class="comment"># 遍历完所有装备，记录数据退出</span></span><br><span class="line">    <span class="keyword">if</span> cur == <span class="number">6</span>:</span><br><span class="line">        values.append(skillNums)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 用于记录每个孔位的可能装备情况</span></span><br><span class="line">    phole = []</span><br><span class="line">    <span class="comment"># 所需该装备的所有可能装备情况</span></span><br><span class="line">    holeValue(skillNums, cur, <span class="number">0</span>, items[cur][<span class="number">0</span>], phole)</span><br><span class="line">    <span class="comment"># 进行下一个装备的搜索</span></span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> phole:</span><br><span class="line">        allValue(arr, cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装备</span></span><br><span class="line">items = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 技能</span></span><br><span class="line">skills = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="comment"># 用于记录所有的可能价值</span></span><br><span class="line">values = []</span><br><span class="line"><span class="comment"># 搜寻所有可能</span></span><br><span class="line">allValue([<span class="number">0</span>]*n, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 存放最大价值</span></span><br><span class="line">maxValue = <span class="number">0</span></span><br><span class="line"><span class="comment"># 遍历每种可能</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历每个技能的可能存放数量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):</span><br><span class="line">        <span class="comment"># 求取价值</span></span><br><span class="line">        index = <span class="built_in">min</span>(value[i], skills[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            tmp += skills[i][index+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> tmp &gt; maxValue:</span><br><span class="line">        maxValue = tmp</span><br><span class="line"><span class="built_in">print</span>(maxValue)</span><br></pre></td></tr></table></figure><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p><strong>题目描述</strong></p><blockquote><p>给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包含一个字符串S，由大小写英文字母组成。<br>第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。<br>第三行包含一个整数n，表示给出的文字的行数。<br>接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>Hello<br>1<br>5<br>HelloWorld<br>HiHiHelloHiHi<br>GrepIsAGreatTool<br>HELLO<br>HELLOisNOTHello</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>HelloWorld<br>HiHiHelloHiHi<br>HELLOisNOTHello</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">buttom = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> buttom == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> i:</span><br><span class="line">            res.append(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s = s.lower()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> i.lower():</span><br><span class="line">            res.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">    <span class="built_in">print</span>(res[i])</span><br></pre></td></tr></table></figure><h3 id="字符串对比"><a href="#字符串对比" class="headerlink" title="字符串对比"></a>字符串对比</h3><p><strong>题目描述</strong></p><blockquote><p>给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：<br>1：两个字符串长度不等。比如 Beijing 和 Hebei<br>2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing<br>3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing<br>4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing<br>编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>包括两行，每行都是一个字符串</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>仅有一个数字，表明这两个字符串的关系编号</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>BEIjing<br>beiJing</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">str2 = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str1) != <span class="built_in">len</span>(str2):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> str1 == str2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> str1.lower() == str2.lower():</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串跳步"><a href="#字符串跳步" class="headerlink" title="字符串跳步"></a>字符串跳步</h3><p><strong>题目描述</strong></p><blockquote><p>给定一个字符串，你需要从第start位开始每隔step位输出字符串对应位置上的字符。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行：一个只包含小写字母的字符串。<br>第二行：两个非负整数start和step，意义见上。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一行，表示对应输出。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>abcdefg<br>2 2</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>ceg</p></blockquote><p>start从0开始计数。<br>字符串长度不超过100000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">start, step = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(s[start::step])</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列-LCS）"><a href="#最长公共子序列-LCS）" class="headerlink" title="最长公共子序列(LCS）"></a>最长公共子序列(LCS）</h3><p><strong>题目描述</strong></p><blockquote><p>给定两个字符串，寻找这两个字串之间的最长公共子序列。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入两行，分别包含一个字符串，仅含有小写字母。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>最长公共子序列的长度。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>abcdgh<br>aedfhb</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>3</p></blockquote><p><strong>样例说明</strong></p><blockquote><p>最长公共子序列为a，d，h。</p></blockquote><p>字串长度1~1000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">str2 = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment"># res[i][j]代表长度str1长度为i,str2长度为j时的最长公共子序列的长度</span></span><br><span class="line">res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2)+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)+<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 从零开始递归</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2)+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 其中一个字符串长度为0时，最长公共子序列的长度为0</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">            res[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 否则若当前长度位置i和j的字符相等，则最长公共子序列的长度更新为i-1和j-1长度时最长公共子序列的长度+1</span></span><br><span class="line">        <span class="keyword">elif</span> str1[i-<span class="number">1</span>] == str2[j-<span class="number">1</span>]:</span><br><span class="line">            res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若当前长度位置i和j的字符不相等，则最长公共子序列的长度为最长的(i-1和j长度时的最长公共子序列长度，i和j-1长度时的最长公共子序列长度)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[i][j] = <span class="built_in">max</span>(res[i - <span class="number">1</span>][j], res[i][j - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 返回最终长度时的最长公共子序列的长度</span></span><br><span class="line"><span class="built_in">print</span>(res[-<span class="number">1</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="最长滑雪道"><a href="#最长滑雪道" class="headerlink" title="最长滑雪道"></a>最长滑雪道</h3><p><strong>题目描述</strong></p><blockquote><p>小袁非常喜欢滑雪， 因为滑雪很刺激。为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。 小袁想知道在某个区域中最长的一个滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。如下：</p><p><img src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao/image-20220302190226582.png" alt></p><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。<br>你的任务就是找到最长的一条滑坡，并且将滑坡的长度输出。 滑坡的长度定义为经过点的个数，例如滑坡24-17-16-1的长度是4。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入的第一行表示区域的行数R和列数C(1&lt;=R, C&lt;=10)。下面是R行，每行有C个整数，依次是每个点的高度h（0&lt;= h &lt;=10000）。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>只有一行，为一个整数，即最长区域的长度。</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>25</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归搜索， 求该位置出发的最长路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># 初始化为1</span></span><br><span class="line">    maxHeight = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 该位置周边的四个点</span></span><br><span class="line">    offset = [[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> offset:</span><br><span class="line">        <span class="comment"># 下一个搜索点的横坐标</span></span><br><span class="line">        tx = x + i[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 下一个搜索点的纵坐标</span></span><br><span class="line">        ty = y + i[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 若超出边界，跳过</span></span><br><span class="line">        <span class="keyword">if</span> tx &lt; <span class="number">0</span> <span class="keyword">or</span> tx &gt; R - <span class="number">1</span> <span class="keyword">or</span> ty &lt; <span class="number">0</span> <span class="keyword">or</span> ty &gt; C - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 若不满足高度差，跳过</span></span><br><span class="line">        <span class="keyword">if</span> arr[tx][ty] &gt;= arr[x][y]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 当前位置出发的最长路径只有两种情况</span></span><br><span class="line">        <span class="comment"># 1.找不到满足条件的搜索点为它自身 2.下一个搜索点的最长路径+1</span></span><br><span class="line">        maxHeight = <span class="built_in">max</span>(maxHeight, dfs(tx, ty) + <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> maxHeight</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line">R, C = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">arr = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(R)]</span><br><span class="line"><span class="comment"># 存放最长路径的结果</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(R):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(C):</span><br><span class="line">        res = <span class="built_in">max</span>(res, dfs(x, y))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="最长字符序列-同LCS"><a href="#最长字符序列-同LCS" class="headerlink" title="最长字符序列(同LCS)"></a>最长字符序列(同LCS)</h3><p><strong>题目描述</strong></p><blockquote><p>设x(i), y(i), z(i)表示单个字符，则X={x(1)x(2)……x(m)}，Y={y(1)y(2)……y(n)}，Z={z(1)z(2)……z(k)},我们称其为字符序列，其中m,n和k分别是字符序列X，Y，Z的长度，括号()中的数字被称作字符序列的下标。<br>如果存在一个严格递增而且长度大于0的下标序列{i1,i2……ik}，使得对所有的j=1,2,……k，有x(ij)=z(j)，那么我们称Z是X的字符子序列。而且，如果Z既是X的字符子序列又是Y的字符子序列，那么我们称Z为X和Y的公共字符序列。<br>在我们今天的问题中，我们希望计算两个给定字符序列X和Y的最大长度的公共字符序列，这里我们只要求输出这个最大长度公共子序列对应的长度值。<br>举例来说，字符序列X=abcd，Y=acde，那么它们的最大长度为3，相应的公共字符序列为acd。</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>输入一行，用空格隔开的两个字符串</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出这两个字符序列对应的最大长度公共字符序列的长度值</p></blockquote><p><strong>输入样例</strong></p><blockquote><p>aAbB aabb</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">input</span>().split()</span><br><span class="line">arr = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">            arr[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> a[i-<span class="number">1</span>] == b[j-<span class="number">1</span>]:</span><br><span class="line">            arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[i][j] = <span class="built_in">max</span>(arr[i][j-<span class="number">1</span>], arr[i-<span class="number">1</span>][j])</span><br><span class="line"><span class="built_in">print</span>(arr[-<span class="number">1</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Qiyuan-Z</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qiyuan-z.github.io/2022/03/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E5%88%86%E4%BA%AB(Python%E7%89%88)/">https://qiyuan-z.github.io/2022/03/02/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E5%88%86%E4%BA%AB(Python%E7%89%88)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Qiyuan-Z.github.io" target="_blank">Yuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/lanqiao.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/30/OpenCV%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91%EF%BC%88Python%EF%BC%89/"><img class="prev-cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/opencv.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OpenCV多线程方式处理视频（Python）</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/19/PyQt5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"><img class="next-cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/qt.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PyQt5的安装与使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/30/OpenCV多线程方式处理视频（Python）/" title="OpenCV多线程方式处理视频（Python）"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/opencv.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">OpenCV多线程方式处理视频（Python）</div></div></a></div><div><a href="/2022/01/19/PyQt5的安装与使用/" title="PyQt5的安装与使用"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/qt.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-19</div><div class="title">PyQt5的安装与使用</div></div></a></div><div><a href="/2020/05/18/Ubuntu下pip安装numba/" title="Ubuntu下pip安装numba"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/ubuntu.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-18</div><div class="title">Ubuntu下pip安装numba</div></div></a></div><div><a href="/2020/05/05/解决Pycharm大量占用C盘问题/" title="解决Pycharm大量占用C盘问题"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/pycharm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-05</div><div class="title">解决Pycharm大量占用C盘问题</div></div></a></div><div><a href="/2020/01/26/Pytorch快速安装教程/" title="Pytorch快速安装教程"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/pytorch.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-26</div><div class="title">Pytorch快速安装教程</div></div></a></div><div><a href="/2019/12/19/PyQt5与Opencv的小小融合/" title="PyQt5与Opencv的小小融合"><img class="cover" src="https://yuanblog-1300912400.cos.ap-shanghai.myqcloud.com/img/opencv.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-19</div><div class="title">PyQt5与Opencv的小小融合</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">比赛介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E7%BB%84%E7%AB%9E%E8%B5%9B%E8%A7%84%E5%88%99%E5%8F%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">Python组竞赛规则及说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">组别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E8%B5%9B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">竞赛赛程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">竞赛形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%B5%9B%E9%80%89%E6%89%8B%E6%9C%BA%E5%99%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">2.4.</span> <span class="toc-text">参赛选手机器环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%A2%98%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">试题形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%A2%98%E8%80%83%E6%9F%A5%E8%8C%83%E5%9B%B4%E8%AF%95%E9%A2%98%E8%80%83%E6%9F%A5%E8%8C%83%E5%9B%B4"><span class="toc-number">2.6.</span> <span class="toc-text">试题考查范围试题考查范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E6%8F%90%E4%BA%A4"><span class="toc-number">2.7.</span> <span class="toc-text">答案提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86"><span class="toc-number">2.8.</span> <span class="toc-text">评分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">试题及答案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">成绩统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FJ%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.</span> <span class="toc-text">FJ字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E5%A5%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">K好数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number">3.4.</span> <span class="toc-text">N皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2N%E7%9A%87%E5%90%8E"><span class="toc-number">3.5.</span> <span class="toc-text">2N皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sin%E4%B9%8B%E8%88%9E"><span class="toc-number">3.6.</span> <span class="toc-text">sin之舞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2"><span class="toc-number">3.7.</span> <span class="toc-text">不同子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D"><span class="toc-number">3.8.</span> <span class="toc-text">成绩排名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BF%E5%8E%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">3.9.</span> <span class="toc-text">承压计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E5%B0%BE%E9%9B%B6"><span class="toc-number">3.10.</span> <span class="toc-text">乘积尾零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E5%88%86%E6%9E%90"><span class="toc-number">3.11.</span> <span class="toc-text">单词分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97"><span class="toc-number">3.12.</span> <span class="toc-text">等差数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%B7%AE%E7%B4%A0%E6%95%B0%E5%88%97"><span class="toc-number">3.13.</span> <span class="toc-text">等差素数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%80%92%E7%BD%AE%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">3.14.</span> <span class="toc-text">递归倒置字符数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E4%B8%89%E5%85%83%E7%BB%84"><span class="toc-number">3.15.</span> <span class="toc-text">递增三元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%87%A0%E4%B8%AA%E5%B9%B8%E8%BF%90%E6%95%B0"><span class="toc-number">3.16.</span> <span class="toc-text">第几个幸运数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%89%8B%E8%A1%A8"><span class="toc-number">3.17.</span> <span class="toc-text">调手表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C"><span class="toc-number">3.18.</span> <span class="toc-text">队列操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A0%BC%E5%88%86%E5%89%B2"><span class="toc-number">3.19.</span> <span class="toc-text">方格分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">3.20.</span> <span class="toc-text">分解质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%B0"><span class="toc-number">3.21.</span> <span class="toc-text">分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-number">3.22.</span> <span class="toc-text">复数求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E5%8D%95"><span class="toc-number">3.23.</span> <span class="toc-text">购物单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B"><span class="toc-number">3.24.</span> <span class="toc-text">龟兔赛跑预测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%A0%B9%E6%A4%8D%E7%89%A9"><span class="toc-number">3.25.</span> <span class="toc-text">合根植物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E9%92%9E%E7%A5%A8"><span class="toc-number">3.26.</span> <span class="toc-text">换钞票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0"><span class="toc-number">3.27.</span> <span class="toc-text">回形取数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%91%E9%99%B5%E5%8D%81%E4%B8%89%E9%92%97"><span class="toc-number">3.28.</span> <span class="toc-text">金陵十三钗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-number">3.29.</span> <span class="toc-text">矩阵乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF%E4%BA%A4"><span class="toc-number">3.30.</span> <span class="toc-text">矩阵面积交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E5%92%8C"><span class="toc-number">3.31.</span> <span class="toc-text">矩阵求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%A8%E7%89%8C%E5%88%B6%E4%BD%9C"><span class="toc-number">3.32.</span> <span class="toc-text">门牌制作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB"><span class="toc-number">3.33.</span> <span class="toc-text">迷宫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB2"><span class="toc-number">3.34.</span> <span class="toc-text">迷宫2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B4%E5%8F%B7%E5%AD%97%E4%B8%B2"><span class="toc-number">3.35.</span> <span class="toc-text">年号字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%91%E6%AD%A5%E9%94%BB%E7%82%BC"><span class="toc-number">3.36.</span> <span class="toc-text">跑步锻炼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%88%87%E5%88%86"><span class="toc-number">3.37.</span> <span class="toc-text">平面切分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96"><span class="toc-number">3.38.</span> <span class="toc-text">全球变暖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0"><span class="toc-number">3.39.</span> <span class="toc-text">蛇形填数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F"><span class="toc-number">3.40.</span> <span class="toc-text">石子游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.41.</span> <span class="toc-text">时间转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%AF%BB%E6%B3%95"><span class="toc-number">3.42.</span> <span class="toc-text">数的读法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-number">3.43.</span> <span class="toc-text">数的分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC"><span class="toc-number">3.44.</span> <span class="toc-text">数列求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0"><span class="toc-number">3.45.</span> <span class="toc-text">数位递增的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%979"><span class="toc-number">3.46.</span> <span class="toc-text">数字9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">3.47.</span> <span class="toc-text">数字三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C"><span class="toc-number">3.48.</span> <span class="toc-text">特别数的和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">3.49.</span> <span class="toc-text">特殊回文数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">3.50.</span> <span class="toc-text">完美的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%83%E5%80%BC"><span class="toc-number">3.51.</span> <span class="toc-text">完全二叉树的权值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%9A%E4%BC%9A%E8%8A%82%E7%9B%AE%E5%8D%95"><span class="toc-number">3.52.</span> <span class="toc-text">晚会节目单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95"><span class="toc-number">3.53.</span> <span class="toc-text">芯片测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B8%E8%BF%90%E9%A1%BE%E5%AE%A2"><span class="toc-number">3.54.</span> <span class="toc-text">幸运顾客</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0"><span class="toc-number">3.55.</span> <span class="toc-text">序列计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE2020"><span class="toc-number">3.56.</span> <span class="toc-text">寻找2020</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">3.57.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-number">3.58.</span> <span class="toc-text">叶节点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E8%8A%82%E5%88%A4%E6%96%AD"><span class="toc-number">3.59.</span> <span class="toc-text">音节判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E8%BA%AB%E9%AB%98"><span class="toc-number">3.60.</span> <span class="toc-text">预测身高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">3.61.</span> <span class="toc-text">约数个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%8D%89"><span class="toc-number">3.62.</span> <span class="toc-text">长草</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="toc-number">3.63.</span> <span class="toc-text">长整数加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E7%8F%A0"><span class="toc-number">3.64.</span> <span class="toc-text">装饰珠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">3.65.</span> <span class="toc-text">字符串操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E6%AF%94"><span class="toc-number">3.66.</span> <span class="toc-text">字符串对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%B3%E6%AD%A5"><span class="toc-number">3.67.</span> <span class="toc-text">字符串跳步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-LCS%EF%BC%89"><span class="toc-number">3.68.</span> <span class="toc-text">最长公共子序列(LCS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%BB%91%E9%9B%AA%E9%81%93"><span class="toc-number">3.69.</span> <span class="toc-text">最长滑雪道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97-%E5%90%8CLCS"><span class="toc-number">3.70.</span> <span class="toc-text">最长字符序列(同LCS)</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022<i id="heartbeat" class="fa fas fa-heartbeat"></i> Qiyuan-Z</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br>昨日までの私は、もうどこにもいない<br></p></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk({clientID:"2d10cfb27783db577e70",clientSecret:"154292876bb14966f6ae57304b67859617b08c94",repo:"gitalk",owner:"Qiyuan-Z",admin:["Qiyuan-Z"],id:"1329d4a00cba99dccbdf5a5f23b23bad",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount}).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/npm/akilar-live2d-widget/autoload.min.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>