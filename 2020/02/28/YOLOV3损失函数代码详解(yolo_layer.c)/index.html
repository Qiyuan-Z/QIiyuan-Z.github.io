<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>YOLOV3损失函数代码详解(yolo_layer.c) | Yuan</title><meta name="keywords" content="目标检测,YOLOv3"><meta name="author" content="Qiyuan-Z"><meta name="copyright" content="Qiyuan-Z"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言YOLOV3的损失函数在YOLOV2的基础上，用多个独立的逻辑回归损失代替了YOLOV2里面的softmax损失，然后去掉了对Anchor在前12800次训练轮次中的回归损失，也即是YOLOV2损失函数的第二项。另外新增了一个ignore_thresh参数来忽略一些和GT box的IOU大于ignore_thresh的预测框的objectness损失。除了以上细节，其它部分和YOLOV2的处理"><meta property="og:type" content="article"><meta property="og:title" content="YOLOV3损失函数代码详解(yolo_layer.c)"><meta property="og:url" content="https://qiyuan-z.github.io/2020/02/28/YOLOV3%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3(yolo_layer.c)/index.html"><meta property="og:site_name" content="Yuan"><meta property="og:description" content="前言YOLOV3的损失函数在YOLOV2的基础上，用多个独立的逻辑回归损失代替了YOLOV2里面的softmax损失，然后去掉了对Anchor在前12800次训练轮次中的回归损失，也即是YOLOV2损失函数的第二项。另外新增了一个ignore_thresh参数来忽略一些和GT box的IOU大于ignore_thresh的预测框的objectness损失。除了以上细节，其它部分和YOLOV2的处理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><meta property="article:published_time" content="2020-02-28T04:45:26.355Z"><meta property="article:modified_time" content="2022-01-01T08:22:45.694Z"><meta property="article:author" content="Qiyuan-Z"><meta property="article:tag" content="目标检测"><meta property="article:tag" content="YOLOv3"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qiyuan-z.github.io/2020/02/28/YOLOV3%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3(yolo_layer.c)/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:200,languages:{author:"作者: Qiyuan-Z",link:"链接: ",source:"来源: Yuan",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-01 16:22:45"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">115</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">YOLOV3损失函数代码详解(yolo_layer.c)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-28T04:45:26.355Z" title="发表于 2020-02-28 12:45:26">2020-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-01T08:22:45.694Z" title="更新于 2022-01-01 16:22:45">2022-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>YOLOV3的损失函数在YOLOV2的基础上，用多个独立的逻辑回归损失代替了YOLOV2里面的softmax损失，然后去掉了对Anchor在前12800次训练轮次中的回归损失，也即是YOLOV2损失函数的第二项。另外新增了一个ignore_thresh参数来忽略一些和GT box的IOU大于ignore_thresh的预测框的objectness损失。除了以上细节，其它部分和YOLOV2的处理类似。</p><h2 id="AlexeyAB的一些更新"><a href="#AlexeyAB的一些更新" class="headerlink" title="AlexeyAB的一些更新"></a>AlexeyAB的一些更新</h2><p>除了上面提到的相对于YOLOV2一些基础改动，AlexeyAB大神在目标框回归过程中新增了IOU/GIOU/DIOU/CIOU Loss，并且在分类过程中新增了Focal Loss，方便大家在自己的数据集上进行试验，预祝涨点。</p><h2 id="代码解析步骤"><a href="#代码解析步骤" class="headerlink" title="代码解析步骤"></a>代码解析步骤</h2><h3 id="yolo-层"><a href="#yolo-层" class="headerlink" title="[yolo]层"></a>[yolo]层</h3><p>YOLOV3使用[yolo] 层来计算损失函数以及预测分类和边界框回归，前面经过 darknet-53 的基础网络提取特征，又经过一些特征融合，就得到了3个不同尺度的 yolo 层，分别预测大、中、小物体。主要代码在<code>/src/yolo_layer.c</code>。cfg文件的配置如下：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[yolo]</span><br><span class="line">mask = 0,1,2  #该层预测哪个规模的框，0,1,2表示预测小物体</span><br><span class="line">anchors = 10,13,  16,30,  33,23,  30,61,  62,45,  59,119,  116,90,  156,198,  373,326 </span><br><span class="line">classes=80</span><br><span class="line">num=9</span><br><span class="line">jitter=.3</span><br><span class="line">ignore_thresh = .7</span><br><span class="line">truth_thresh = 1</span><br><span class="line">random=1</span><br></pre></td></tr></table></figure><p></p><h3 id="make-yolo-layer-完成-yolo-层初始化操作"><a href="#make-yolo-layer-完成-yolo-层初始化操作" class="headerlink" title="make_yolo_layer 完成 yolo 层初始化操作"></a>make_yolo_layer 完成 yolo 层初始化操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// 构造YOLOV3的yolo层</span><br><span class="line">// batch 一个batch中包含图片的张数</span><br><span class="line">// w 输入图片的宽度</span><br><span class="line">// h 输入图片的高度</span><br><span class="line">// n 一个cell预测多少个bbox</span><br><span class="line">// total total Anchor bbox的数目</span><br><span class="line">// mask 使用的是0,1,2 还是</span><br><span class="line">// classes 网络需要识别的物体类别数</span><br><span class="line">layer make_yolo_layer(int batch, int w, int h, int n, int total, int *mask, int classes, int max_boxes)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    layer l = &#123; (LAYER_TYPE)0 &#125;;</span><br><span class="line">    l.type = YOLO; //层类别</span><br><span class="line"></span><br><span class="line">    l.n = n; //一个cell预测多少个bbox</span><br><span class="line">    l.total = total; //anchors的数目，为9</span><br><span class="line">    l.batch = batch;// 一个batch包含图片的张数</span><br><span class="line">    l.h = h; // 输入图片的宽度</span><br><span class="line">    l.w = w; // 输入图片的高度</span><br><span class="line">    l.c = n*(classes + 4 + 1); // 输入图片的通道数, 3*(20 + 5)</span><br><span class="line">    l.out_w = l.w;// 输出图片的宽度</span><br><span class="line">    l.out_h = l.h;// 输出图片的高度</span><br><span class="line">    l.out_c = l.c;// 输出图片的通道数</span><br><span class="line">    l.classes = classes;//目标类别数</span><br><span class="line">    l.cost = (float*)xcalloc(1, sizeof(float)); //yolo层总的损失</span><br><span class="line">    l.biases = (float*)xcalloc(total * 2, sizeof(float)); //存储bbox的Anchor box的[w,h]</span><br><span class="line">    if(mask) l.mask = mask; //yolov3有mask传入</span><br><span class="line">    else&#123;</span><br><span class="line">        l.mask = (int*)xcalloc(n, sizeof(int));</span><br><span class="line">        for(i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            l.mask[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//存储bbox的Anchor box的[w,h]的更新值</span><br><span class="line">    l.bias_updates = (float*)xcalloc(n * 2, sizeof(float));</span><br><span class="line">	// 一张训练图片经过yolo层后得到的输出元素个数（等于网格数*每个网格预测的矩形框数*每个矩形框的参数个数）</span><br><span class="line">    l.outputs = h*w*n*(classes + 4 + 1);</span><br><span class="line">	//一张训练图片输入到yolo层的元素个数（注意是一张图片，对于yolo_layer，输入和输出的元素个数相等）</span><br><span class="line">    l.inputs = l.outputs;</span><br><span class="line">	//每张图片含有的真实矩形框参数的个数（max_boxes表示一张图片中最多有max_boxes个ground truth矩形框，每个真实矩形框有</span><br><span class="line">    //5个参数，包括x,y,w,h四个定位参数，以及物体类别）,注意max_boxes是darknet程序内写死的，实际上每张图片可能</span><br><span class="line">    //并没有max_boxes个真实矩形框，也能没有这么多参数，但为了保持一致性，还是会留着这么大的存储空间，只是其中的</span><br><span class="line">    //值为空而已.</span><br><span class="line">    l.max_boxes = max_boxes;</span><br><span class="line">	// GT: max_boxes*(4+1) 存储max_boxes个bbox的信息，这里是假设图片中GT bbox的数量是</span><br><span class="line">	//小于max_boxes的，这里是写死的；此处与yolov1是不同的</span><br><span class="line">    l.truths = l.max_boxes*(4 + 1);    // 90*(4 + 1);</span><br><span class="line">	// yolo层误差项(包含整个batch的)</span><br><span class="line">    l.delta = (float*)xcalloc(batch * l.outputs, sizeof(float));</span><br><span class="line">	//yolo层所有输出（包含整个batch的）</span><br><span class="line">    //yolo的输出维度是l.out_w*l.out_h，等于输出的维度，输出的通道数为l.out_c，也即是输入的通道数，具体为：n*(classes+coords+1)</span><br><span class="line">	//YOLO检测模型将图片分成S*S个网格，每个网格又预测B个矩形框，最后输出的就是这些网格中包含的所有矩形框的信息</span><br><span class="line">    l.output = (float*)xcalloc(batch * l.outputs, sizeof(float));</span><br><span class="line">	// 存储bbox的Anchor box的[w,h]的初始化,在src/parse.c中parse_yolo函数会加载cfg中Anchor尺寸</span><br><span class="line">    for(i = 0; i &lt; total*2; ++i)&#123;</span><br><span class="line">        l.biases[i] = .5;</span><br><span class="line">    &#125;</span><br><span class="line">	// yolo层的前向传播</span><br><span class="line">    l.forward = forward_yolo_layer;</span><br><span class="line">	// yolo层的反向传播</span><br><span class="line">    l.backward = backward_yolo_layer;</span><br><span class="line">#ifdef GPU</span><br><span class="line">    l.forward_gpu = forward_yolo_layer_gpu;</span><br><span class="line">    l.backward_gpu = backward_yolo_layer_gpu;</span><br><span class="line">    l.output_gpu = cuda_make_array(l.output, batch*l.outputs);</span><br><span class="line">    l.delta_gpu = cuda_make_array(l.delta, batch*l.outputs);</span><br><span class="line"></span><br><span class="line">    free(l.output);</span><br><span class="line">    if (cudaSuccess == cudaHostAlloc(&amp;l.output, batch*l.outputs*sizeof(float), cudaHostRegisterMapped)) l.output_pinned = 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        cudaGetLastError(); // reset CUDA-error</span><br><span class="line">        l.output = (float*)xcalloc(batch * l.outputs, sizeof(float));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(l.delta);</span><br><span class="line">    if (cudaSuccess == cudaHostAlloc(&amp;l.delta, batch*l.outputs*sizeof(float), cudaHostRegisterMapped)) l.delta_pinned = 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        cudaGetLastError(); // reset CUDA-error</span><br><span class="line">        l.delta = (float*)xcalloc(batch * l.outputs, sizeof(float));</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;yolo\n&quot;);</span><br><span class="line">    srand(time(0));</span><br><span class="line"></span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-yolo-box-获得预测的边界框"><a href="#get-yolo-box-获得预测的边界框" class="headerlink" title="get_yolo_box 获得预测的边界框"></a>get_yolo_box 获得预测的边界框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//获取某个矩形框的4个定位信息，即根据输入的矩形框索引从l.output中获取该矩形框的定位信息x,y,w,h</span><br><span class="line">//x  yolo_layer的输出，即l.output，包含所有batch预测得到的矩形框信息</span><br><span class="line">//biases 表示Anchor框的长和宽</span><br><span class="line">//index 矩形框的首地址（索引，矩形框中存储的首个参数x在l.output中的索引）</span><br><span class="line">//i 第几行（yolo_layer维度为l.out_w*l.out_c）</span><br><span class="line">//j 第几列</span><br><span class="line">//lw 特征图的宽度</span><br><span class="line">//lh 特征图的高度</span><br><span class="line">//w 输入图像的宽度</span><br><span class="line">//h 输入图像的高度</span><br><span class="line">//stride 不同的特征图具有不同的步长(即是两个grid cell之间跨的像素个数不同)</span><br><span class="line"></span><br><span class="line">//biases中存储的是预定以的anchor box的宽和高（输入图尺度），(lw,lh)是yolo层输入的特征图尺度，</span><br><span class="line">//(w,h)是整个网络输入图尺度，get_yolo_box()函数利用了论文截图中的公式，而且把结果分别利用特征</span><br><span class="line">//图宽高和输入图宽高做了归一化。既然这个机制是用来限制回归，避免预测很远的目标，那么这个预测</span><br><span class="line">//范围是多大呢？(b.x,by)最小是(i,j),最大是(i+1,x+1)，即中心点在特征图上最多一定一个像素（假设</span><br><span class="line">//输入图下采样n得到特征图，特征图中一个像素对应输入图的n个像素）(b.w,b.h)最大是(2.7 * anchor.w,</span><br><span class="line">//2.7 * anchor.h),最小就是(anchor.w,anchor.h)，这是在输入图尺寸下的值。</span><br><span class="line"></span><br><span class="line">box get_yolo_box(float *x, float *biases, int n, int index, int i, int j, int lw, int lh, int w, int h, int stride)</span><br><span class="line">&#123;</span><br><span class="line">    box b;</span><br><span class="line">    // ln - natural logarithm (base = e)</span><br><span class="line">    // x` = t.x * lw - i;   // x = ln(x`/(1-x`))   // x - output of previous conv-layer</span><br><span class="line">    // y` = t.y * lh - i;   // y = ln(y`/(1-y`))   // y - output of previous conv-layer</span><br><span class="line">                            // w = ln(t.w * net.w / anchors_w); // w - output of previous conv-layer</span><br><span class="line">                            // h = ln(t.h * net.h / anchors_h); // h - output of previous conv-layer</span><br><span class="line">    b.x = (i + x[index + 0*stride]) / lw;</span><br><span class="line">    b.y = (j + x[index + 1*stride]) / lh;</span><br><span class="line">    b.w = exp(x[index + 2*stride]) * biases[2*n]   / w;</span><br><span class="line">    b.h = exp(x[index + 3*stride]) * biases[2*n+1] / h;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delta-yolo-box-计算预测边界框的误差"><a href="#delta-yolo-box-计算预测边界框的误差" class="headerlink" title="delta_yolo_box 计算预测边界框的误差"></a>delta_yolo_box 计算预测边界框的误差</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">//调用方式：delta_yolo_box(truth, l.output, l.biases, l.mask[n], box_index, i, j, l.w, l.h, state.net.w, state.net.h, l.delta, (2 - truth.w*truth.h), l.w*l.h, l.iou_normalizer * class_multiplier, l.iou_loss, 1, l.max_delta);</span><br><span class="line">// 计算预测边界框的误差</span><br><span class="line">ious delta_yolo_box(box truth, float *x, float *biases, int n, int index, int i, int j, int lw, int lh, int w, int h, float *delta, float scale, int stride, float iou_normalizer, IOU_LOSS iou_loss, int accumulate, int max_delta)</span><br><span class="line">&#123;</span><br><span class="line">    ious all_ious = &#123; 0 &#125;;</span><br><span class="line">    // i - step in layer width</span><br><span class="line">    // j - step in layer height</span><br><span class="line">    //  Returns a box in absolute coordinates</span><br><span class="line">	// 获得第j*w+i个cell的第n个bbox在当前特征图的[x,y,w,h]</span><br><span class="line">    box pred = get_yolo_box(x, biases, n, index, i, j, lw, lh, w, h, stride);</span><br><span class="line">	//iou</span><br><span class="line">    all_ious.iou = box_iou(pred, truth);</span><br><span class="line">	//giou</span><br><span class="line">    all_ious.giou = box_giou(pred, truth);</span><br><span class="line">	//diou</span><br><span class="line">    all_ious.diou = box_diou(pred, truth);</span><br><span class="line">	//ciou</span><br><span class="line">    all_ious.ciou = box_ciou(pred, truth);</span><br><span class="line">    // avoid nan in dx_box_iou</span><br><span class="line">	</span><br><span class="line">    if (pred.w == 0) &#123; pred.w = 1.0; &#125;</span><br><span class="line">    if (pred.h == 0) &#123; pred.h = 1.0; &#125;</span><br><span class="line">    if (iou_loss == MSE)    // old loss</span><br><span class="line">    &#123;</span><br><span class="line">		// 计算GT bbox的tx, ty, tw, th</span><br><span class="line">        float tx = (truth.x*lw - i); //和预测值匹配</span><br><span class="line">        float ty = (truth.y*lh - j);</span><br><span class="line">        float tw = log(truth.w*w / biases[2 * n]); //log 使大框和小框的误差影响接近</span><br><span class="line">        float th = log(truth.h*h / biases[2 * n + 1]);</span><br><span class="line"></span><br><span class="line">        // accumulate delta</span><br><span class="line">		//计算tx, ty, tw, th的梯度</span><br><span class="line">        delta[index + 0 * stride] += scale * (tx - x[index + 0 * stride]) * iou_normalizer;  //计算误差 delta，乘了权重系数 scale=(2-truth.w*truth.h)</span><br><span class="line">        delta[index + 1 * stride] += scale * (ty - x[index + 1 * stride]) * iou_normalizer;</span><br><span class="line">        delta[index + 2 * stride] += scale * (tw - x[index + 2 * stride]) * iou_normalizer;</span><br><span class="line">        delta[index + 3 * stride] += scale * (th - x[index + 3 * stride]) * iou_normalizer;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // https://github.com/generalized-iou/g-darknet</span><br><span class="line">        // https://arxiv.org/abs/1902.09630v2</span><br><span class="line">        // https://giou.stanford.edu/</span><br><span class="line">        all_ious.dx_iou = dx_box_iou(pred, truth, iou_loss);</span><br><span class="line"></span><br><span class="line">        // jacobian^t (transpose)</span><br><span class="line">        //float dx = (all_ious.dx_iou.dl + all_ious.dx_iou.dr);</span><br><span class="line">        //float dy = (all_ious.dx_iou.dt + all_ious.dx_iou.db);</span><br><span class="line">        //float dw = ((-0.5 * all_ious.dx_iou.dl) + (0.5 * all_ious.dx_iou.dr));</span><br><span class="line">        //float dh = ((-0.5 * all_ious.dx_iou.dt) + (0.5 * all_ious.dx_iou.db));</span><br><span class="line"></span><br><span class="line">        // jacobian^t (transpose)</span><br><span class="line">        float dx = all_ious.dx_iou.dt;</span><br><span class="line">        float dy = all_ious.dx_iou.db;</span><br><span class="line">        float dw = all_ious.dx_iou.dl;</span><br><span class="line">        float dh = all_ious.dx_iou.dr;</span><br><span class="line"></span><br><span class="line">        // predict exponential, apply gradient of e^delta_t ONLY for w,h</span><br><span class="line">        dw *= exp(x[index + 2 * stride]);</span><br><span class="line">        dh *= exp(x[index + 3 * stride]);</span><br><span class="line"></span><br><span class="line">        // normalize iou weight</span><br><span class="line">        dx *= iou_normalizer;</span><br><span class="line">        dy *= iou_normalizer;</span><br><span class="line">        dw *= iou_normalizer;</span><br><span class="line">        dh *= iou_normalizer;</span><br><span class="line"></span><br><span class="line">        dx = fix_nan_inf(dx);</span><br><span class="line">        dy = fix_nan_inf(dy);</span><br><span class="line">        dw = fix_nan_inf(dw);</span><br><span class="line">        dh = fix_nan_inf(dh);</span><br><span class="line"></span><br><span class="line">        dx = clip_value(dx, max_delta);</span><br><span class="line">        dy = clip_value(dy, max_delta);</span><br><span class="line">        dw = clip_value(dw, max_delta);</span><br><span class="line">        dh = clip_value(dh, max_delta);</span><br><span class="line"></span><br><span class="line">        if (!accumulate) &#123;</span><br><span class="line">            delta[index + 0 * stride] = 0;</span><br><span class="line">            delta[index + 1 * stride] = 0;</span><br><span class="line">            delta[index + 2 * stride] = 0;</span><br><span class="line">            delta[index + 3 * stride] = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // accumulate delta</span><br><span class="line">        delta[index + 0 * stride] += dx;</span><br><span class="line">        delta[index + 1 * stride] += dy;</span><br><span class="line">        delta[index + 2 * stride] += dw;</span><br><span class="line">        delta[index + 3 * stride] += dh;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回梯度</span><br><span class="line">    return all_ious;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delta-yolo-class-计算类别误差"><a href="#delta-yolo-class-计算类别误差" class="headerlink" title="delta_yolo_class 计算类别误差"></a>delta_yolo_class 计算类别误差</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//计算类别误差</span><br><span class="line">void delta_yolo_class(float *output, float *delta, int index, int class_id, int classes, int stride, float *avg_cat, int focal_loss, float label_smooth_eps, float *classes_multipliers)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    if (delta[index + stride*class_id])&#123; //应该不会进入这个判断，因为 delta[index] 初值为0</span><br><span class="line">        delta[index + stride*class_id] = (1 - label_smooth_eps) - output[index + stride*class_id];</span><br><span class="line">        if (classes_multipliers) delta[index + stride*class_id] *= classes_multipliers[class_id];</span><br><span class="line">        if(avg_cat) *avg_cat += output[index + stride*class_id];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Focal loss</span><br><span class="line">    if (focal_loss) &#123;</span><br><span class="line">        // Focal Loss</span><br><span class="line">        float alpha = 0.5;    // 0.25 or 0.5</span><br><span class="line">        //float gamma = 2;    // hardcoded in many places of the grad-formula</span><br><span class="line"></span><br><span class="line">        int ti = index + stride*class_id;</span><br><span class="line">        float pt = output[ti] + 0.000000000000001F;</span><br><span class="line">        // http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiItKDEteCkqKDIqeCpsb2coeCkreC0xKSIsImNvbG9yIjoiIzAwMDAwMCJ9LHsidHlwZSI6MTAwMH1d</span><br><span class="line">        float grad = -(1 - pt) * (2 * pt*logf(pt) + pt - 1);    // http://blog.csdn.net/linmingan/article/details/77885832</span><br><span class="line">        //float grad = (1 - pt) * (2 * pt*logf(pt) + pt - 1);    // https://github.com/unsky/focal-loss</span><br><span class="line"></span><br><span class="line">        for (n = 0; n &lt; classes; ++n) &#123; //对所有类别，如果预测正确，则误差为 1-predict，否则为 0-predict</span><br><span class="line">            delta[index + stride*n] = (((n == class_id) ? 1 : 0) - output[index + stride*n]);</span><br><span class="line"></span><br><span class="line">            delta[index + stride*n] *= alpha*grad;</span><br><span class="line"></span><br><span class="line">            if (n == class_id &amp;&amp; avg_cat) *avg_cat += output[index + stride*n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // default</span><br><span class="line">        for (n = 0; n &lt; classes; ++n) &#123;</span><br><span class="line">            delta[index + stride*n] = ((n == class_id) ? (1 - label_smooth_eps) : (0 + label_smooth_eps/classes)) - output[index + stride*n];</span><br><span class="line">            if (classes_multipliers &amp;&amp; n == class_id) delta[index + stride*class_id] *= classes_multipliers[class_id];</span><br><span class="line">            if (n == class_id &amp;&amp; avg_cat) *avg_cat += output[index + stride*n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="entry-index-得到指针偏移量，即入口需要的索引"><a href="#entry-index-得到指针偏移量，即入口需要的索引" class="headerlink" title="entry_index 得到指针偏移量，即入口需要的索引"></a>entry_index 得到指针偏移量，即入口需要的索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief 计算某个矩形框中某个参数在l.output中的索引。一个矩形框包含了x,y,w,h,c,C1,C2...,Cn信息，</span><br><span class="line"> *        前四个用于定位，第五个为矩形框含有物体的置信度信息c，即矩形框中存在物体的概率为多大，而C1到Cn</span><br><span class="line"> *        为矩形框中所包含的物体分别属于这n类物体的概率。本函数负责获取该矩形框首个定位信息也即x值在</span><br><span class="line"> *        l.output中索引、获取该矩形框置信度信息c在l.output中的索引、获取该矩形框分类所属概率的首个</span><br><span class="line"> *        概率也即C1值的索引，具体是获取矩形框哪个参数的索引，取决于输入参数entry的值，这些在</span><br><span class="line"> *        forward_region_layer()函数中都有用到，由于l.output的存储方式，当entry=0时，就是获取矩形框</span><br><span class="line"> *        x参数在l.output中的索引；当entry=4时，就是获取矩形框置信度信息c在l.output中的索引；当</span><br><span class="line"> *        entry=5时，就是获取矩形框首个所属概率C1在l.output中的索引，具体可以参考forward_region_layer()</span><br><span class="line"> *        中调用本函数时的注释.</span><br><span class="line"> * @param l 当前region_layer</span><br><span class="line"> * @param batch 当前照片是整个batch中的第几张，因为l.output中包含整个batch的输出，所以要定位某张训练图片</span><br><span class="line"> *              输出的众多网格中的某个矩形框，当然需要该参数.</span><br><span class="line"> * @param location 这个参数，说实话，感觉像个鸡肋参数，函数中用这个参数获取n和loc的值，这个n就是表示网格中</span><br><span class="line"> *                 的第几个预测矩形框（比如每个网格预测5个矩形框，那么n取值范围就是从0~4，loc就是某个</span><br><span class="line"> *                 通道上的元素偏移（region_layer输出的通道数为l.out_c = (classes + coords + 1)，</span><br><span class="line"> *                 这样说可能没有说明白，这都与l.output的存储结构相关，见下面详细注释以及其他说明。总之，</span><br><span class="line"> *                 查看一下调用本函数的父函数forward_region_layer()就知道了，可以直接输入n和j*l.w+i的，</span><br><span class="line"> *                 没有必要输入location，这样还得重新计算一次n和loc.</span><br><span class="line"> * @param entry 切入点偏移系数，关于这个参数，就又要扯到l.output的存储结构了，见下面详细注释以及其他说明.</span><br><span class="line"> * @details l.output这个参数的存储内容以及存储方式已经在多个地方说明了，再多的文字都不及图文说明，此处再</span><br><span class="line"> *          简要罗嗦几句，更为具体的参考图文说明。l.output中存储了整个batch的训练输出，每张训练图片都会输出</span><br><span class="line"> *          l.out_w*l.out_h个网格，每个网格会预测l.n个矩形框，每个矩形框含有l.classes+l.coords+1个参数，</span><br><span class="line"> *          而最后一层的输出通道数为l.n*(l.classes+l.coords+1)，可以想象下最终输出的三维张量是个什么样子的。</span><br><span class="line"> *          展成一维数组存储时，l.output可以首先分成batch个大段，每个大段存储了一张训练图片的所有输出；进一步细分，</span><br><span class="line"> *          取其中第一大段分析，该大段中存储了第一张训练图片所有输出网格预测的矩形框信息，每个网格预测了l.n个矩形框，</span><br><span class="line"> *          存储时，l.n个矩形框是分开存储的，也就是先存储所有网格中的第一个矩形框，而后存储所有网格中的第二个矩形框，</span><br><span class="line"> *          依次类推，如果每个网格中预测5个矩形框，则可以继续把这一大段分成5个中段。继续细分，5个中段中取第</span><br><span class="line"> *          一个中段来分析，这个中段中按行（有l.out_w*l.out_h个网格，按行存储）依次存储了这张训练图片所有输出网格中</span><br><span class="line"> *          的第一个矩形框信息，要注意的是，这个中段存储的顺序并不是挨个挨个存储每个矩形框的所有信息，</span><br><span class="line"> *          而是先存储所有矩形框的x，而后是所有的y,然后是所有的w,再是h，c，最后的的概率数组也是拆分进行存储，</span><br><span class="line"> *          并不是一下子存储完一个矩形框所有类的概率，而是先存储所有网格所属第一类的概率，再存储所属第二类的概率，</span><br><span class="line"> *          具体来说这一中段首先存储了l.out_w*l.out_h个x，然后是l.out_w*l.out_c个y，依次下去，</span><br><span class="line"> *          最后是l.out_w*l.out_h个C1（属于第一类的概率，用C1表示，下面类似），l.out_w*l.outh个C2,...,</span><br><span class="line"> *          l.out_w*l.out_c*Cn（假设共有n类），所以可以继续将中段分成几个小段，依次为x,y,w,h,c,C1,C2,...Cn</span><br><span class="line"> *          小段，每小段的长度都为l.out_w*l.out_c.</span><br><span class="line"> *          现在回过来看本函数的输入参数，batch就是大段的偏移数（从第几个大段开始，对应是第几张训练图片），</span><br><span class="line"> *          由location计算得到的n就是中段的偏移数（从第几个中段开始，对应是第几个矩形框），</span><br><span class="line"> *          entry就是小段的偏移数（从几个小段开始，对应具体是那种参数，x,c还是C1），而loc则是最后的定位，</span><br><span class="line"> *          前面确定好第几大段中的第几中段中的第几小段的首地址，loc就是从该首地址往后数loc个元素，得到最终定位</span><br><span class="line"> *          某个具体参数（x或c或C1）的索引值，比如l.output中存储的数据如下所示（这里假设只存了一张训练图片的输出，</span><br><span class="line"> *          因此batch只能为0；并假设l.out_w=l.out_h=2,l.classes=2）：</span><br><span class="line"> *          xxxxyyyywwwwhhhhccccC1C1C1C1C2C2C2C2-#-xxxxyyyywwwwhhhhccccC1C1C1C1C2C2C2C2，</span><br><span class="line"> *          n=0则定位到-#-左边的首地址（表示每个网格预测的第一个矩形框），n=1则定位到-#-右边的首地址（表示每个网格预测的第二个矩形框）</span><br><span class="line"> *          entry=0,loc=0获取的是x的索引，且获取的是第一个x也即l.out_w*l.out_h个网格中第一个网格中第一个矩形框x参数的索引；</span><br><span class="line"> *          entry=4,loc=1获取的是c的索引，且获取的是第二个c也即l.out_w*l.out_h个网格中第二个网格中第一个矩形框c参数的索引；</span><br><span class="line"> *          entry=5,loc=2获取的是C1的索引，且获取的是第三个C1也即l.out_w*l.out_h个网格中第三个网格中第一个矩形框C1参数的索引；</span><br><span class="line"> *          如果要获取第一个网格中第一个矩形框w参数的索引呢？如果已经获取了其x值的索引，显然用x的索引加上3*l.out_w*l.out_h即可获取到，</span><br><span class="line"> *          这正是delta_region_box()函数的做法；</span><br><span class="line"> *          如果要获取第三个网格中第一个矩形框C2参数的索引呢？如果已经获取了其C1值的索引，显然用C1的索引加上l.out_w*l.out_h即可获取到，</span><br><span class="line"> *          这正是delta_region_class()函数中的做法；</span><br><span class="line"> *          由上可知，entry=0时,即偏移0个小段，是获取x的索引；entry=4,是获取自信度信息c的索引；entry=5，是获取C1的索引.</span><br><span class="line"> *          l.output的存储方式大致就是这样，个人觉得说的已经很清楚了，但可视化效果终究不如图文说明～</span><br><span class="line">*/</span><br><span class="line">static int entry_index(layer l, int batch, int location, int entry)</span><br><span class="line">&#123;</span><br><span class="line">    int n =   location / (l.w*l.h);</span><br><span class="line">    int loc = location % (l.w*l.h);</span><br><span class="line">    return batch*l.outputs + n*l.w*l.h*(4+l.classes+1) + entry*l.w*l.h + loc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forward-yolo-layer-前向传播函数"><a href="#forward-yolo-layer-前向传播函数" class="headerlink" title="forward_yolo_layer 前向传播函数"></a>forward_yolo_layer 前向传播函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line">//前向传播</span><br><span class="line">void forward_yolo_layer(const layer l, network_state state)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, b, t, n;</span><br><span class="line">	//将层输入直接拷贝到层输出</span><br><span class="line">    memcpy(l.output, state.input, l.outputs*l.batch * sizeof(float));</span><br><span class="line">   //在 cpu 里，把预测输出的 x,y,confidence 和80种类别都 sigmoid 激活，确保值在0~1</span><br><span class="line">#ifndef GPU</span><br><span class="line">    for (b = 0; b &lt; l.batch; ++b) &#123;</span><br><span class="line">        for (n = 0; n &lt; l.n; ++n) &#123;</span><br><span class="line">			// 获取第b个batch开始的index</span><br><span class="line">            int index = entry_index(l, b, n*l.w*l.h, 0);</span><br><span class="line">			// 对预测的tx,ty进行逻辑回归预测,</span><br><span class="line">            activate_array(l.output + index, 2 * l.w*l.h, LOGISTIC);        // x,y,</span><br><span class="line">            scal_add_cpu(2 * l.w*l.h, l.scale_x_y, -0.5*(l.scale_x_y - 1), l.output + index, 1);    // scale x,y</span><br><span class="line">            // 获取第b个batch confidence开始的index</span><br><span class="line">			index = entry_index(l, b, n*l.w*l.h, 4);</span><br><span class="line">			// 对预测的confidence以及class进行逻辑回归</span><br><span class="line">            activate_array(l.output + index, (1 + l.classes)*l.w*l.h, LOGISTIC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // delta is zeroed</span><br><span class="line">	//将yolo层的误差项进行初始化(包含整个batch的)</span><br><span class="line">    memset(l.delta, 0, l.outputs * l.batch * sizeof(float));</span><br><span class="line">	// inference阶段,到此结束</span><br><span class="line">    if (!state.train) return;</span><br><span class="line">    //float avg_iou = 0;</span><br><span class="line">    float tot_iou = 0; //总的IoU（Intersection over Union）</span><br><span class="line">    float tot_giou = 0;</span><br><span class="line">    float tot_diou = 0;</span><br><span class="line">    float tot_ciou = 0;</span><br><span class="line">    float tot_iou_loss = 0;</span><br><span class="line">    float tot_giou_loss = 0;</span><br><span class="line">    float tot_diou_loss = 0;</span><br><span class="line">    float tot_ciou_loss = 0;</span><br><span class="line">    float recall = 0;</span><br><span class="line">    float recall75 = 0;</span><br><span class="line">    float avg_cat = 0;</span><br><span class="line">    float avg_obj = 0;</span><br><span class="line">    float avg_anyobj = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int class_count = 0;</span><br><span class="line">    *(l.cost) = 0; // yolo层的总损失初始化为0</span><br><span class="line">    for (b = 0; b &lt; l.batch; ++b) &#123;// 遍历batch中的每一张图片</span><br><span class="line">        for (j = 0; j &lt; l.h; ++j) &#123;</span><br><span class="line">            for (i = 0; i &lt; l.w; ++i) &#123;// 遍历每个cell, 当前cell编号[j, i]</span><br><span class="line">                for (n = 0; n &lt; l.n; ++n) &#123;// 遍历每一个bbox, 当前bbox编号 [n]</span><br><span class="line">					// 在这里与yolov2 reorg层是相似的, 获得第j*w+i个cell第n个bbox的index</span><br><span class="line">                    int box_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 0);</span><br><span class="line">					// 计算第j*w+i个cell第n个bbox在当前特征图上的相对位置[x,y],在网络输入图片上的相对宽度,高度[w,h]</span><br><span class="line">                    box pred = get_yolo_box(l.output, l.biases, l.mask[n], box_index, i, j, l.w, l.h, state.net.w, state.net.h, l.w*l.h);</span><br><span class="line">                    float best_match_iou = 0;</span><br><span class="line">                    int best_match_t = 0;</span><br><span class="line">                    float best_iou = 0; // 保存最大iou</span><br><span class="line">                    int best_t = 0;// 保存最大iou的bbox id</span><br><span class="line">                    for (t = 0; t &lt; l.max_boxes; ++t) &#123;// 遍历每一个GT bbox</span><br><span class="line">						// 将第t个bbox由float数组转bbox结构体,方便计算iou</span><br><span class="line">                        box truth = float_to_box_stride(state.truth + t*(4 + 1) + b*l.truths, 1);</span><br><span class="line">						//获取第t个bbox的类别，检查是否有标注错误</span><br><span class="line">                        int class_id = state.truth[t*(4 + 1) + b*l.truths + 4];</span><br><span class="line">                        if (class_id &gt;= l.classes) &#123;</span><br><span class="line">                            printf(&quot; Warning: in txt-labels class_id=%d &gt;= classes=%d in cfg-file. In txt-labels class_id should be [from 0 to %d] \n&quot;, class_id, l.classes, l.classes - 1);</span><br><span class="line">                            printf(&quot; truth.x = %f, truth.y = %f, truth.w = %f, truth.h = %f, class_id = %d \n&quot;, truth.x, truth.y, truth.w, truth.h, class_id);</span><br><span class="line">                            getchar();</span><br><span class="line">                            continue; // if label contains class_id more than number of classes in the cfg-file</span><br><span class="line">                        &#125;</span><br><span class="line">						// 如果x坐标为0则取消,因为yolov3这里定义了max_boxes个bbox</span><br><span class="line">                        if (!truth.x) break;  // continue;</span><br><span class="line"></span><br><span class="line">                        int class_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 4 + 1);//预测bbox 类别s下标</span><br><span class="line">                        int obj_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 4); //预测bbox objectness下标</span><br><span class="line">                        float objectness = l.output[obj_index]; //预测bbox object置信度</span><br><span class="line">						//获得预测bbox 的类别信息，如果某个类别的概率超过0.25返回1</span><br><span class="line">                        int class_id_match = compare_yolo_class(l.output, l.classes, class_index, l.w*l.h, objectness, class_id, 0.25f);</span><br><span class="line"></span><br><span class="line">                        float iou = box_iou(pred, truth); // 计算pred bbox与第t个GT bbox之间的iou</span><br><span class="line">						// 这个地方和原始的DarkNet实现不太一样，多了一个class_id_match=1的限制，即预测bbox的置信度必须大于0.25</span><br><span class="line">                        if (iou &gt; best_match_iou &amp;&amp; class_id_match == 1) &#123;</span><br><span class="line">                            best_match_iou = iou;</span><br><span class="line">                            best_match_t = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (iou &gt; best_iou) &#123;</span><br><span class="line">                            best_iou = iou; // 记录iou最大的iou</span><br><span class="line">                            best_t = t; // 记录该GT bbox的编号t</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					// 在这里与yolov2 reorg层是相似的, 获得第j*w+i个cell第n个bbox的confidence</span><br><span class="line">                    int obj_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 4);</span><br><span class="line">					// 统计pred bbox的confidence</span><br><span class="line">                    avg_anyobj += l.output[obj_index];</span><br><span class="line">					 // 与yolov1相似,先将所有pred bbox都当做noobject, 计算其confidence梯度，不过这里多了一个平衡系数</span><br><span class="line">                    l.delta[obj_index] = l.cls_normalizer * (0 - l.output[obj_index]);</span><br><span class="line">					// best_iou大于阈值则说明pred box有物体,在yolov3中正样本阈值ignore_thresh=.5</span><br><span class="line">                    if (best_match_iou &gt; l.ignore_thresh) &#123;</span><br><span class="line">                        l.delta[obj_index] = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">					// pred bbox为完全预测正确样本,在yolov3完全预测正确样本的阈值truth_thresh=1.</span><br><span class="line">					//这个参数在cfg文件中，值为1，这个条件语句永远不可能成立</span><br><span class="line">                    if (best_iou &gt; l.truth_thresh) &#123;</span><br><span class="line">						// 作者在YOLOV3论文中的第4节提到了这部分。</span><br><span class="line">						// 作者尝试Faster-RCNN中提到的双IOU策略，当Anchor与GT的IoU大于0.7时，该Anchor被算作正样本</span><br><span class="line">						//计入损失中，但训练过程中并没有产生好的结果，所以最后放弃了。</span><br><span class="line">                        l.delta[obj_index] = l.cls_normalizer * (1 - l.output[obj_index]);</span><br><span class="line">						 // 获得best_iou对应GT bbox的class的index</span><br><span class="line">                        int class_id = state.truth[best_t*(4 + 1) + b*l.truths + 4];</span><br><span class="line">						//yolov3 yolo层中map=0, 不参与计算</span><br><span class="line">                        if (l.map) class_id = l.map[class_id];</span><br><span class="line">						// 获得best_iou对应pred bbox的class的index</span><br><span class="line">                        int class_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 4 + 1);</span><br><span class="line">                        delta_yolo_class(l.output, l.delta, class_index, class_id, l.classes, l.w*l.h, 0, l.focal_loss, l.label_smooth_eps, l.classes_multipliers);</span><br><span class="line">                        box truth = float_to_box_stride(state.truth + best_t*(4 + 1) + b*l.truths, 1);</span><br><span class="line">                        const float class_multiplier = (l.classes_multipliers) ? l.classes_multipliers[class_id] : 1.0f;</span><br><span class="line">                        // 计算pred bbox的[x,y,w,h]的梯度</span><br><span class="line">						delta_yolo_box(truth, l.output, l.biases, l.mask[n], box_index, i, j, l.w, l.h, state.net.w, state.net.h, l.delta, (2 - truth.w*truth.h), l.w*l.h, l.iou_normalizer * class_multiplier, l.iou_loss, 1, l.max_delta);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (t = 0; t &lt; l.max_boxes; ++t) &#123;</span><br><span class="line">			//遍历每一个GT box</span><br><span class="line">			// 将第t个bbox由float数组转bbox结构体,方便计算iou</span><br><span class="line">            box truth = float_to_box_stride(state.truth + t*(4 + 1) + b*l.truths, 1);</span><br><span class="line">            if (truth.x &lt; 0 || truth.y &lt; 0 || truth.x &gt; 1 || truth.y &gt; 1 || truth.w &lt; 0 || truth.h &lt; 0) &#123;</span><br><span class="line">                char buff[256];</span><br><span class="line">                printf(&quot; Wrong label: truth.x = %f, truth.y = %f, truth.w = %f, truth.h = %f \n&quot;, truth.x, truth.y, truth.w, truth.h);</span><br><span class="line">                sprintf(buff, &quot;echo \&quot;Wrong label: truth.x = %f, truth.y = %f, truth.w = %f, truth.h = %f\&quot; &gt;&gt; bad_label.list&quot;,</span><br><span class="line">                    truth.x, truth.y, truth.w, truth.h);</span><br><span class="line">                system(buff);</span><br><span class="line">            &#125;</span><br><span class="line">            int class_id = state.truth[t*(4 + 1) + b*l.truths + 4];</span><br><span class="line">            if (class_id &gt;= l.classes) continue; // if label contains class_id more than number of classes in the cfg-file</span><br><span class="line"></span><br><span class="line">            if (!truth.x) break;  // 如果x坐标为0则取消，因为yolov3定义了max_boxes个bbox,可能实际上没那么多</span><br><span class="line">            float best_iou = 0; //保存最大的IOU</span><br><span class="line">            int best_n = 0; //保存最大IOU的bbox index</span><br><span class="line">            i = (truth.x * l.w); // 获得当前t个GT bbox所在的cell</span><br><span class="line">            j = (truth.y * l.h);</span><br><span class="line">            box truth_shift = truth;</span><br><span class="line">            truth_shift.x = truth_shift.y = 0; //将truth_shift的box位置移动到0,0</span><br><span class="line">            for (n = 0; n &lt; l.total; ++n) &#123; // 遍历每一个anchor bbox找到与GT bbox最大的IOU</span><br><span class="line">                box pred = &#123; 0 &#125;;</span><br><span class="line">                pred.w = l.biases[2 * n] / state.net.w; // 计算pred bbox的w在相对整张输入图片的位置</span><br><span class="line">                pred.h = l.biases[2 * n + 1] / state.net.h; // 计算pred bbox的h在相对整张输入图片的位置</span><br><span class="line">                float iou = box_iou(pred, truth_shift); // 计算GT box truth_shift 与 预测bbox pred二者之间的IOU</span><br><span class="line">                if (iou &gt; best_iou) &#123;</span><br><span class="line">                    best_iou = iou;// 记录最大的IOU</span><br><span class="line">                    best_n = n;// 以及记录该bbox的编号n</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 上面记录bbox的编号,是否由该层Anchor预测的</span><br><span class="line">            int mask_n = int_index(l.mask, best_n, l.n);</span><br><span class="line">            if (mask_n &gt;= 0) &#123;</span><br><span class="line">                int class_id = state.truth[t*(4 + 1) + b*l.truths + 4];</span><br><span class="line">                if (l.map) class_id = l.map[class_id];</span><br><span class="line">				// 获得best_iou对应anchor box的index</span><br><span class="line">                int box_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 0);</span><br><span class="line">				//这个参数是用来控制样本数量不均衡的，即Focal Loss中的alpha</span><br><span class="line">                const float class_multiplier = (l.classes_multipliers) ? l.classes_multipliers[class_id] : 1.0f;</span><br><span class="line">				// 计算best_iou对应Anchor bbox的[x,y,w,h]的梯度</span><br><span class="line">                ious all_ious = delta_yolo_box(truth, l.output, l.biases, best_n, box_index, i, j, l.w, l.h, state.net.w, state.net.h, l.delta, (2 - truth.w*truth.h), l.w*l.h, l.iou_normalizer * class_multiplier, l.iou_loss, 1, l.max_delta);</span><br><span class="line"></span><br><span class="line">				// 下面的都是模板检测最新的工作，metricl learning，包括IOU/GIOU/DIOU/CIOU Loss</span><br><span class="line">                // range is 0 &lt;= 1</span><br><span class="line">                tot_iou += all_ious.iou;</span><br><span class="line">                tot_iou_loss += 1 - all_ious.iou;</span><br><span class="line">                // range is -1 &lt;= giou &lt;= 1</span><br><span class="line">                tot_giou += all_ious.giou;</span><br><span class="line">                tot_giou_loss += 1 - all_ious.giou;</span><br><span class="line"></span><br><span class="line">                tot_diou += all_ious.diou;</span><br><span class="line">                tot_diou_loss += 1 - all_ious.diou;</span><br><span class="line"></span><br><span class="line">                tot_ciou += all_ious.ciou;</span><br><span class="line">                tot_ciou_loss += 1 - all_ious.ciou;</span><br><span class="line">				// 获得best_iou对应anchor box的confidence的index</span><br><span class="line">                int obj_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 4);</span><br><span class="line">				//统计confidence</span><br><span class="line">                avg_obj += l.output[obj_index];</span><br><span class="line">				// 计算confidence的梯度</span><br><span class="line">                l.delta[obj_index] = class_multiplier * l.cls_normalizer * (1 - l.output[obj_index]);</span><br><span class="line">				// 获得best_iou对应GT box的class的index</span><br><span class="line">                int class_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 4 + 1);</span><br><span class="line">				// 获得best_iou对应anchor box的class的index</span><br><span class="line">                delta_yolo_class(l.output, l.delta, class_index, class_id, l.classes, l.w*l.h, &amp;avg_cat, l.focal_loss, l.label_smooth_eps, l.classes_multipliers);</span><br><span class="line"></span><br><span class="line">                ++count;</span><br><span class="line">                ++class_count;</span><br><span class="line">                if (all_ious.iou &gt; .5) recall += 1;</span><br><span class="line">                if (all_ious.iou &gt; .75) recall75 += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			//下面这个过程和上面一样，不过多约束了一个iou_thresh</span><br><span class="line">            // iou_thresh</span><br><span class="line">            for (n = 0; n &lt; l.total; ++n) &#123;</span><br><span class="line">                int mask_n = int_index(l.mask, n, l.n);</span><br><span class="line">                if (mask_n &gt;= 0 &amp;&amp; n != best_n &amp;&amp; l.iou_thresh &lt; 1.0f) &#123;</span><br><span class="line">                    box pred = &#123; 0 &#125;;</span><br><span class="line">                    pred.w = l.biases[2 * n] / state.net.w;</span><br><span class="line">                    pred.h = l.biases[2 * n + 1] / state.net.h;</span><br><span class="line">                    float iou = box_iou(pred, truth_shift);</span><br><span class="line">                    // iou, n</span><br><span class="line"></span><br><span class="line">                    if (iou &gt; l.iou_thresh) &#123;</span><br><span class="line">                        int class_id = state.truth[t*(4 + 1) + b*l.truths + 4];</span><br><span class="line">                        if (l.map) class_id = l.map[class_id];</span><br><span class="line"></span><br><span class="line">                        int box_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 0);</span><br><span class="line">                        const float class_multiplier = (l.classes_multipliers) ? l.classes_multipliers[class_id] : 1.0f;</span><br><span class="line">                        ious all_ious = delta_yolo_box(truth, l.output, l.biases, n, box_index, i, j, l.w, l.h, state.net.w, state.net.h, l.delta, (2 - truth.w*truth.h), l.w*l.h, l.iou_normalizer * class_multiplier, l.iou_loss, 1, l.max_delta);</span><br><span class="line"></span><br><span class="line">                        // range is 0 &lt;= 1</span><br><span class="line">                        tot_iou += all_ious.iou;</span><br><span class="line">                        tot_iou_loss += 1 - all_ious.iou;</span><br><span class="line">                        // range is -1 &lt;= giou &lt;= 1</span><br><span class="line">                        tot_giou += all_ious.giou;</span><br><span class="line">                        tot_giou_loss += 1 - all_ious.giou;</span><br><span class="line"></span><br><span class="line">                        tot_diou += all_ious.diou;</span><br><span class="line">                        tot_diou_loss += 1 - all_ious.diou;</span><br><span class="line"></span><br><span class="line">                        tot_ciou += all_ious.ciou;</span><br><span class="line">                        tot_ciou_loss += 1 - all_ious.ciou;</span><br><span class="line"></span><br><span class="line">                        int obj_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 4);</span><br><span class="line">                        avg_obj += l.output[obj_index];</span><br><span class="line">                        l.delta[obj_index] = class_multiplier * l.cls_normalizer * (1 - l.output[obj_index]);</span><br><span class="line"></span><br><span class="line">                        int class_index = entry_index(l, b, mask_n*l.w*l.h + j*l.w + i, 4 + 1);</span><br><span class="line">                        delta_yolo_class(l.output, l.delta, class_index, class_id, l.classes, l.w*l.h, &amp;avg_cat, l.focal_loss, l.label_smooth_eps, l.classes_multipliers);</span><br><span class="line"></span><br><span class="line">                        ++count;</span><br><span class="line">                        ++class_count;</span><br><span class="line">                        if (all_ious.iou &gt; .5) recall += 1;</span><br><span class="line">                        if (all_ious.iou &gt; .75) recall75 += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // averages the deltas obtained by the function: delta_yolo_box()_accumulate</span><br><span class="line">        for (j = 0; j &lt; l.h; ++j) &#123;</span><br><span class="line">            for (i = 0; i &lt; l.w; ++i) &#123;</span><br><span class="line">                for (n = 0; n &lt; l.n; ++n) &#123;</span><br><span class="line">					// 在这里与yolov2 reorg层是相似的, 获得第j*w+i个cell第n个bbox的index</span><br><span class="line">                    int box_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 0);</span><br><span class="line">					//获得第j*w+i个cell第n个bbox的类别</span><br><span class="line">                    int class_index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 4 + 1);</span><br><span class="line">					//特征图的大小</span><br><span class="line">                    const int stride = l.w*l.h;</span><br><span class="line">					//对梯度进行平均</span><br><span class="line">                    averages_yolo_deltas(class_index, box_index, stride, l.classes, l.delta);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //*(l.cost) = pow(mag_array(l.delta, l.outputs * l.batch), 2);</span><br><span class="line">    //printf(&quot;Region %d Avg IOU: %f, Class: %f, Obj: %f, No Obj: %f, .5R: %f, .75R: %f,  count: %d\n&quot;, state.index, avg_iou / count, avg_cat / class_count, avg_obj / count, avg_anyobj / (l.w*l.h*l.n*l.batch), recall / count, recall75 / count, count);</span><br><span class="line"></span><br><span class="line">    int stride = l.w*l.h;</span><br><span class="line">    float* no_iou_loss_delta = (float *)calloc(l.batch * l.outputs, sizeof(float));</span><br><span class="line">    memcpy(no_iou_loss_delta, l.delta, l.batch * l.outputs * sizeof(float));</span><br><span class="line">    for (b = 0; b &lt; l.batch; ++b) &#123;</span><br><span class="line">        for (j = 0; j &lt; l.h; ++j) &#123;</span><br><span class="line">            for (i = 0; i &lt; l.w; ++i) &#123;</span><br><span class="line">                for (n = 0; n &lt; l.n; ++n) &#123;</span><br><span class="line">					//yolov3如果使用的是iou loss，也就是metric learning的方式，那么x,y,w,h的loss可以设置为0</span><br><span class="line">                    int index = entry_index(l, b, n*l.w*l.h + j*l.w + i, 0);</span><br><span class="line">                    no_iou_loss_delta[index + 0 * stride] = 0;</span><br><span class="line">                    no_iou_loss_delta[index + 1 * stride] = 0;</span><br><span class="line">                    no_iou_loss_delta[index + 2 * stride] = 0;</span><br><span class="line">                    no_iou_loss_delta[index + 3 * stride] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//计算所有的分类loss</span><br><span class="line">    float classification_loss = l.cls_normalizer * pow(mag_array(no_iou_loss_delta, l.outputs * l.batch), 2);</span><br><span class="line">    free(no_iou_loss_delta);</span><br><span class="line">	//计算总的loss</span><br><span class="line">    float loss = pow(mag_array(l.delta, l.outputs * l.batch), 2);</span><br><span class="line">	//计算回归loss</span><br><span class="line">    float iou_loss = loss - classification_loss;</span><br><span class="line"></span><br><span class="line">    float avg_iou_loss = 0;</span><br><span class="line">    // gIOU loss + MSE (objectness) loss</span><br><span class="line">    if (l.iou_loss == MSE) &#123;</span><br><span class="line">        *(l.cost) = pow(mag_array(l.delta, l.outputs * l.batch), 2);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // Always compute classification loss both for iou + cls loss and for logging with mse loss</span><br><span class="line">        // TODO: remove IOU loss fields before computing MSE on class</span><br><span class="line">        //   probably split into two arrays</span><br><span class="line">        if (l.iou_loss == GIOU) &#123;</span><br><span class="line">            avg_iou_loss = count &gt; 0 ? l.iou_normalizer * (tot_giou_loss / count) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">			//count代表目标个数</span><br><span class="line">            avg_iou_loss = count &gt; 0 ? l.iou_normalizer * (tot_iou_loss / count) : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        *(l.cost) = avg_iou_loss + classification_loss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loss /= l.batch;</span><br><span class="line">    classification_loss /= l.batch;</span><br><span class="line">    iou_loss /= l.batch;</span><br><span class="line"></span><br><span class="line">    printf(&quot;v3 (%s loss, Normalizer: (iou: %f, cls: %f) Region %d Avg (IOU: %f, GIOU: %f), Class: %f, Obj: %f, No Obj: %f, .5R: %f, .75R: %f, count: %d, loss = %f, class_loss = %f, iou_loss = %f\n&quot;,</span><br><span class="line">        (l.iou_loss == MSE ? &quot;mse&quot; : (l.iou_loss == GIOU ? &quot;giou&quot; : &quot;iou&quot;)), l.iou_normalizer, l.cls_normalizer, state.index, tot_iou / count, tot_giou / count, avg_cat / class_count, avg_obj / count, avg_anyobj / (l.w*l.h*l.n*l.batch), recall / count, recall75 / count, count,</span><br><span class="line">        loss, classification_loss, iou_loss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="backward-yolo-layer-误差反向传播"><a href="#backward-yolo-layer-误差反向传播" class="headerlink" title="backward_yolo_layer 误差反向传播"></a>backward_yolo_layer 误差反向传播</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//误差反向传播</span><br><span class="line">void backward_yolo_layer(const layer l, network_state state)</span><br><span class="line">&#123;</span><br><span class="line">	//直接把 l.delta 拷贝给上一层的 delta。注意 net.delta 指向 prev_layer.delta。</span><br><span class="line">   axpy_cpu(l.batch*l.inputs, 1, l.delta, 1, state.delta, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="correct-yolo-boxes-调整预测-box-中心和大小"><a href="#correct-yolo-boxes-调整预测-box-中心和大小" class="headerlink" title="correct_yolo_boxes 调整预测 box 中心和大小"></a>correct_yolo_boxes 调整预测 box 中心和大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//调整预测 box 中心和大小</span><br><span class="line"></span><br><span class="line">void correct_yolo_boxes(detection *dets, int n, int w, int h, int netw, int neth, int relative, int letter)</span><br><span class="line">&#123;</span><br><span class="line">	//w 和 h 是输入图片的尺寸，netw 和 neth 是网络输入尺寸</span><br><span class="line">    int i;</span><br><span class="line">    // network height (or width)</span><br><span class="line">    int new_w = 0;</span><br><span class="line">    // network height (or width)</span><br><span class="line">    int new_h = 0;</span><br><span class="line">    // Compute scale given image w,h vs network w,h</span><br><span class="line">    // I think this &quot;rotates&quot; the image to match network to input image w/h ratio</span><br><span class="line">    // new_h and new_w are really just network width and height</span><br><span class="line">    if (letter) &#123;</span><br><span class="line">        if (((float)netw / w) &lt; ((float)neth / h)) &#123; //新图片尺寸</span><br><span class="line">            new_w = netw;</span><br><span class="line">            new_h = (h * netw) / w;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            new_h = neth;</span><br><span class="line">            new_w = (w * neth) / h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        new_w = netw;</span><br><span class="line">        new_h = neth;</span><br><span class="line">    &#125;</span><br><span class="line">    // difference between network width and &quot;rotated&quot; width</span><br><span class="line">    float deltaw = netw - new_w;</span><br><span class="line">    // difference between network height and &quot;rotated&quot; height</span><br><span class="line">    float deltah = neth - new_h;</span><br><span class="line">    // ratio between rotated network width and network width</span><br><span class="line">    float ratiow = (float)new_w / netw;</span><br><span class="line">    // ratio between rotated network width and network width</span><br><span class="line">    float ratioh = (float)new_h / neth;</span><br><span class="line">    for (i = 0; i &lt; n; ++i) &#123; //调整 box 相对新图片尺寸的位置</span><br><span class="line"></span><br><span class="line">        box b = dets[i].bbox;</span><br><span class="line">        // x = ( x - (deltaw/2)/netw ) / ratiow;</span><br><span class="line">        //   x - [(1/2 the difference of the network width and rotated width) / (network width)]</span><br><span class="line">        b.x = (b.x - deltaw / 2. / netw) / ratiow;</span><br><span class="line">        b.y = (b.y - deltah / 2. / neth) / ratioh;</span><br><span class="line">        // scale to match rotation of incoming image</span><br><span class="line">        b.w *= 1 / ratiow;</span><br><span class="line">        b.h *= 1 / ratioh;</span><br><span class="line"></span><br><span class="line">        // relative seems to always be == 1, I don&#x27;t think we hit this condition, ever.</span><br><span class="line">        if (!relative) &#123;</span><br><span class="line">            b.x *= w;</span><br><span class="line">            b.w *= w;</span><br><span class="line">            b.y *= h;</span><br><span class="line">            b.h *= h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dets[i].bbox = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yolo-num-detections-预测输出中置信度超过阈值的-box-个数"><a href="#yolo-num-detections-预测输出中置信度超过阈值的-box-个数" class="headerlink" title="yolo_num_detections 预测输出中置信度超过阈值的 box 个数"></a>yolo_num_detections 预测输出中置信度超过阈值的 box 个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//预测输出中置信度超过阈值的 box 个数</span><br><span class="line">int yolo_num_detections(layer l, float thresh)</span><br><span class="line">&#123;</span><br><span class="line">    int i, n;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (i = 0; i &lt; l.w*l.h; ++i)&#123;</span><br><span class="line">        for(n = 0; n &lt; l.n; ++n)&#123;</span><br><span class="line">			////获得置信度偏移位置</span><br><span class="line">            int obj_index  = entry_index(l, 0, n*l.w*l.h + i, 4);</span><br><span class="line">			//置信度超过阈值</span><br><span class="line">            if(l.output[obj_index] &gt; thresh)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-yolo-detections-获得预测输出中超过阈值的-box"><a href="#get-yolo-detections-获得预测输出中超过阈值的-box" class="headerlink" title="get_yolo_detections 获得预测输出中超过阈值的 box"></a>get_yolo_detections 获得预测输出中超过阈值的 box</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//获得预测输出中超过阈值的 box</span><br><span class="line">int get_yolo_detections(layer l, int w, int h, int netw, int neth, float thresh, int *map, int relative, detection *dets, int letter)</span><br><span class="line">&#123;</span><br><span class="line">    //printf(&quot;\n l.batch = %d, l.w = %d, l.h = %d, l.n = %d \n&quot;, l.batch, l.w, l.h, l.n);</span><br><span class="line">    int i,j,n;</span><br><span class="line">    float *predictions = l.output;</span><br><span class="line">    // This snippet below is not necessary</span><br><span class="line">    // Need to comment it in order to batch processing &gt;= 2 images</span><br><span class="line">    //if (l.batch == 2) avg_flipped_yolo(l);</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (i = 0; i &lt; l.w*l.h; ++i)&#123;</span><br><span class="line">        int row = i / l.w;</span><br><span class="line">        int col = i % l.w;</span><br><span class="line">        for(n = 0; n &lt; l.n; ++n)&#123;</span><br><span class="line">            int obj_index  = entry_index(l, 0, n*l.w*l.h + i, 4);</span><br><span class="line">            float objectness = predictions[obj_index]; //置信度</span><br><span class="line">            //if(objectness &lt;= thresh) continue;    // incorrect behavior for Nan values</span><br><span class="line">            if (objectness &gt; thresh) &#123;</span><br><span class="line">                //printf(&quot;\n objectness = %f, thresh = %f, i = %d, n = %d \n&quot;, objectness, thresh, i, n);</span><br><span class="line">                int box_index = entry_index(l, 0, n*l.w*l.h + i, 0);</span><br><span class="line">                dets[count].bbox = get_yolo_box(predictions, l.biases, l.mask[n], box_index, col, row, l.w, l.h, netw, neth, l.w*l.h);</span><br><span class="line">                dets[count].objectness = objectness;</span><br><span class="line">                dets[count].classes = l.classes;</span><br><span class="line">                for (j = 0; j &lt; l.classes; ++j) &#123;</span><br><span class="line">                    int class_index = entry_index(l, 0, n*l.w*l.h + i, 4 + 1 + j);</span><br><span class="line">                    float prob = objectness*predictions[class_index];//置信度 x 类别概率</span><br><span class="line">                    dets[count].prob[j] = (prob &gt; thresh) ? prob : 0;//小于阈值则概率置0</span><br><span class="line">                &#125;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    correct_yolo_boxes(dets, count, w, h, netw, neth, relative, letter);//调整 box 大小</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Qiyuan-Z</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qiyuan-z.github.io/2020/02/28/YOLOV3%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3(yolo_layer.c)/">https://qiyuan-z.github.io/2020/02/28/YOLOV3%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3(yolo_layer.c)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Qiyuan-Z.github.io" target="_blank">Yuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><a class="post-meta__tags" href="/tags/YOLOv3/">YOLOv3</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/28/YOLOv2/"><img class="prev-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">YOLOv2</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/27/YOLOv1/"><img class="next-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">YOLOv1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02/18/YOLOv3模型构建中的YOLOLayer/" title="YOLOv3模型构建中的YOLOLayer"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3模型构建中的YOLOLayer</div></div></a></div><div><a href="/2020/02/18/YOLOv3网络模型的构建/" title="YOLOv3网络模型的构建"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3网络模型的构建</div></div></a></div><div><a href="/2020/02/18/在YOLOv3模型中添加Attention机制/" title="在YOLOv3模型中添加Attention机制"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">在YOLOv3模型中添加Attention机制</div></div></a></div><div><a href="/2020/02/15/Pytorch版YOLOv3中的代码配置和数据集构建/" title="Pytorch版YOLOv3中的代码配置和数据集构建"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">Pytorch版YOLOv3中的代码配置和数据集构建</div></div></a></div><div><a href="/2020/02/15/YOLOv3中的参数进化/" title="YOLOv3中的参数进化"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3中的参数进化</div></div></a></div><div><a href="/2020/02/15/YOLOv3的数据加载机制和增强方法/" title="YOLOv3的数据加载机制和增强方法"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3的数据加载机制和增强方法</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlexeyAB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9B%B4%E6%96%B0"><span class="toc-number">2.</span> <span class="toc-text">AlexeyAB的一些更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">代码解析步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yolo-%E5%B1%82"><span class="toc-number">3.1.</span> <span class="toc-text">[yolo]层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make-yolo-layer-%E5%AE%8C%E6%88%90-yolo-%E5%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">make_yolo_layer 完成 yolo 层初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-yolo-box-%E8%8E%B7%E5%BE%97%E9%A2%84%E6%B5%8B%E7%9A%84%E8%BE%B9%E7%95%8C%E6%A1%86"><span class="toc-number">3.3.</span> <span class="toc-text">get_yolo_box 获得预测的边界框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delta-yolo-box-%E8%AE%A1%E7%AE%97%E9%A2%84%E6%B5%8B%E8%BE%B9%E7%95%8C%E6%A1%86%E7%9A%84%E8%AF%AF%E5%B7%AE"><span class="toc-number">3.4.</span> <span class="toc-text">delta_yolo_box 计算预测边界框的误差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delta-yolo-class-%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%88%AB%E8%AF%AF%E5%B7%AE"><span class="toc-number">3.5.</span> <span class="toc-text">delta_yolo_class 计算类别误差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entry-index-%E5%BE%97%E5%88%B0%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E5%8D%B3%E5%85%A5%E5%8F%A3%E9%9C%80%E8%A6%81%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.6.</span> <span class="toc-text">entry_index 得到指针偏移量，即入口需要的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-yolo-layer-%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">forward_yolo_layer 前向传播函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backward-yolo-layer-%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="toc-number">3.8.</span> <span class="toc-text">backward_yolo_layer 误差反向传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#correct-yolo-boxes-%E8%B0%83%E6%95%B4%E9%A2%84%E6%B5%8B-box-%E4%B8%AD%E5%BF%83%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.9.</span> <span class="toc-text">correct_yolo_boxes 调整预测 box 中心和大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yolo-num-detections-%E9%A2%84%E6%B5%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E7%BD%AE%E4%BF%A1%E5%BA%A6%E8%B6%85%E8%BF%87%E9%98%88%E5%80%BC%E7%9A%84-box-%E4%B8%AA%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">yolo_num_detections 预测输出中置信度超过阈值的 box 个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-yolo-detections-%E8%8E%B7%E5%BE%97%E9%A2%84%E6%B5%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E8%B6%85%E8%BF%87%E9%98%88%E5%80%BC%E7%9A%84-box"><span class="toc-number">3.11.</span> <span class="toc-text">get_yolo_detections 获得预测输出中超过阈值的 box</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022<i id="heartbeat" class="fa fas fa-heartbeat"></i> Qiyuan-Z</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br>昨日までの私は、もうどこにもいない<br></p></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk({clientID:"2d10cfb27783db577e70",clientSecret:"154292876bb14966f6ae57304b67859617b08c94",repo:"gitalk",owner:"Qiyuan-Z",admin:["Qiyuan-Z"],id:"0b221fada1493a24501f04f3624b0bf2",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount}).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/gh/Qiyuan-Z/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body></html>