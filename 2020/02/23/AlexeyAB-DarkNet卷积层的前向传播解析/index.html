<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AlexeyAB DarkNet卷积层的前向传播解析 | Yuan</title><meta name="keywords" content="目标检测,YOLOv3"><meta name="author" content="Qiyuan-Z"><meta name="copyright" content="Qiyuan-Z"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言今天来介绍一下DarkNet中卷积层的前向传播和反向传播的实现，卷积层是卷积神经网络中的核心组件，了解它的底层代码实现对我们理解卷积神经网络以及优化卷积神经网络都有一些帮助。 卷积层的构造卷积层的构造主要在src&#x2F;convolutional_layer.c中的make_convolutional_layer中进行实现，下面给出部分核心代码。 12345678910111213141516171"><meta property="og:type" content="article"><meta property="og:title" content="AlexeyAB DarkNet卷积层的前向传播解析"><meta property="og:url" content="https://qiyuan-z.github.io/2020/02/23/AlexeyAB-DarkNet%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="Yuan"><meta property="og:description" content="前言今天来介绍一下DarkNet中卷积层的前向传播和反向传播的实现，卷积层是卷积神经网络中的核心组件，了解它的底层代码实现对我们理解卷积神经网络以及优化卷积神经网络都有一些帮助。 卷积层的构造卷积层的构造主要在src&#x2F;convolutional_layer.c中的make_convolutional_layer中进行实现，下面给出部分核心代码。 12345678910111213141516171"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><meta property="article:published_time" content="2020-02-23T05:57:41.249Z"><meta property="article:modified_time" content="2022-01-01T08:01:05.202Z"><meta property="article:author" content="Qiyuan-Z"><meta property="article:tag" content="目标检测"><meta property="article:tag" content="YOLOv3"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qiyuan-z.github.io/2020/02/23/AlexeyAB-DarkNet%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:200,languages:{author:"作者: Qiyuan-Z",link:"链接: ",source:"来源: Yuan",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-01 16:01:05"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">115</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">AlexeyAB DarkNet卷积层的前向传播解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-23T05:57:41.249Z" title="发表于 2020-02-23 13:57:41">2020-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-01T08:01:05.202Z" title="更新于 2022-01-01 16:01:05">2022-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来介绍一下DarkNet中卷积层的前向传播和反向传播的实现，卷积层是卷积神经网络中的核心组件，了解它的底层代码实现对我们理解卷积神经网络以及优化卷积神经网络都有一些帮助。</p><h2 id="卷积层的构造"><a href="#卷积层的构造" class="headerlink" title="卷积层的构造"></a>卷积层的构造</h2><p>卷积层的构造主要在<code>src/convolutional_layer.c</code>中的<code>make_convolutional_layer</code>中进行实现，下面给出部分核心代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** batch 每个batch含有的图片数</span><br><span class="line">** step</span><br><span class="line">** h 图像高度(行数)</span><br><span class="line">** w 图像宽度(列数)</span><br><span class="line">** c 输入图像通道数</span><br><span class="line">** n 卷积核个数</span><br><span class="line">** groups 分组数</span><br><span class="line">** size 卷积核尺寸</span><br><span class="line">** stride 步长</span><br><span class="line">** dilation 空洞卷积空洞率</span><br><span class="line">** padding 四周补0长度</span><br><span class="line">** activation 激活函数类别</span><br><span class="line">** batch_normalize 是否进行BN</span><br><span class="line">** binary 是否对权重进行二值化</span><br><span class="line">** xnor 是否对权重以及输入进行二值化</span><br><span class="line">** adam 优化方式</span><br><span class="line">** use_bin_output</span><br><span class="line">** index 分组卷积的时候分组索引</span><br><span class="line">** antialiasing 抗锯齿标志，如果为真强行设置所有的步长为1</span><br><span class="line">** share_layer 标志参数，表示这一个卷积层是否和其它卷积层共享权重</span><br><span class="line">** assisted_excitation</span><br><span class="line">** deform 暂时不知道</span><br><span class="line">** train 标志参数，是否在训练</span><br><span class="line">*/</span><br><span class="line">convolutional_layer make_convolutional_layer(int batch, int steps, int h, int w, int c, int n, int groups, int size, int stride_x, int stride_y, int dilation, int padding, ACTIVATION activation,</span><br><span class="line"> int batch_normalize, int binary, int xnor, int adam, int use_bin_output, int index, int antialiasing, convolutional_layer *share_layer, int assisted_excitation, int deform, int train)</span><br><span class="line">&#123;</span><br><span class="line">    int total_batch = batch*steps;</span><br><span class="line">    int i;</span><br><span class="line">    convolutional_layer l = &#123; (LAYER_TYPE)0 &#125;;</span><br><span class="line">    l.type = CONVOLUTIONAL;</span><br><span class="line">    l.train = train;</span><br><span class="line"></span><br><span class="line">    if (xnor) groups = 1;   //对于二值网络，不能使用分组卷积</span><br><span class="line">    if (groups &lt; 1) groups = 1;</span><br><span class="line"></span><br><span class="line">    const int blur_stride_x = stride_x;</span><br><span class="line">    const int blur_stride_y = stride_y;</span><br><span class="line">    l.antialiasing = antialiasing;</span><br><span class="line">    if (antialiasing) &#123;</span><br><span class="line">        stride_x = stride_y = l.stride = l.stride_x = l.stride_y = 1; // use stride=1 in host-layer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l.deform = deform;</span><br><span class="line">    l.assisted_excitation = assisted_excitation;</span><br><span class="line">    l.share_layer = share_layer;</span><br><span class="line">    l.index = index;</span><br><span class="line">    l.h = h;</span><br><span class="line">    l.w = w;</span><br><span class="line">    l.c = c;</span><br><span class="line">    l.groups = groups;</span><br><span class="line">    l.n = n;</span><br><span class="line">    l.binary = binary;</span><br><span class="line">    l.xnor = xnor;</span><br><span class="line">    l.use_bin_output = use_bin_output;</span><br><span class="line">    l.batch = batch;</span><br><span class="line">    l.steps = steps;</span><br><span class="line">    l.stride = stride_x;</span><br><span class="line">    l.stride_x = stride_x;</span><br><span class="line">    l.stride_y = stride_y;</span><br><span class="line">    l.dilation = dilation;</span><br><span class="line">    l.size = size;</span><br><span class="line">    l.pad = padding;</span><br><span class="line">    l.batch_normalize = batch_normalize;</span><br><span class="line">    l.learning_rate_scale = 1;</span><br><span class="line">	// 该卷积层总的权重元素个数（权重元素个数等于输入数据的通道数/分组数*卷积核个数*卷积核的二维尺寸，注意因为每一个卷积核是同时作用于输入数据</span><br><span class="line">    // 的多个通道上的，因此实际上卷积核是三维的，包括两个维度的平面尺寸，以及输入数据通道数这个维度，每个通道上的卷积核参数都是独立的训练参数）</span><br><span class="line">    l.nweights = (c / groups) * n * size * size;</span><br><span class="line">	// 如果是共享卷积层，可以直接用共享的卷积层来赋值（猜测是有预训练权重的时候可以直接赋值）</span><br><span class="line">    if (l.share_layer) &#123;</span><br><span class="line">        if (l.size != l.share_layer-&gt;size || l.nweights != l.share_layer-&gt;nweights || l.c != l.share_layer-&gt;c || l.n != l.share_layer-&gt;n) &#123;</span><br><span class="line">            printf(&quot;Layer size, nweights, channels or filters don&#x27;t match for the share_layer&quot;);</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l.weights = l.share_layer-&gt;weights;</span><br><span class="line">        l.weight_updates = l.share_layer-&gt;weight_updates;</span><br><span class="line"></span><br><span class="line">        l.biases = l.share_layer-&gt;biases;</span><br><span class="line">        l.bias_updates = l.share_layer-&gt;bias_updates;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">		// 该卷积层总的权重元素(卷积核元素)个数=输入图像通道数 / 分组数*卷积核个数*卷积核尺寸</span><br><span class="line">        l.weights = (float*)xcalloc(l.nweights, sizeof(float));</span><br><span class="line">		// bias就是Wx+b中的b（上面的weights就是W），有多少个卷积核，就有多少个b（与W的个数一一对应，每个W的元素个数为c*size*size）</span><br><span class="line">        l.biases = (float*)xcalloc(n, sizeof(float));</span><br><span class="line">		// 训练期间，需要执行反向传播</span><br><span class="line">        if (train) &#123;</span><br><span class="line">			// 敏感图和特征图的尺寸应该是一样的</span><br><span class="line">            l.weight_updates = (float*)xcalloc(l.nweights, sizeof(float));</span><br><span class="line">			// bias的敏感图，维度和bias一致</span><br><span class="line">            l.bias_updates = (float*)xcalloc(n, sizeof(float));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // float scale = 1./sqrt(size*size*c);</span><br><span class="line">	// 初始化权重：缩放因子*标准正态分布随机数，缩放因子等于sqrt(2./(size*size*c))，随机初始化</span><br><span class="line">    // 此处初始化权重为正态分布，而在全连接层make_connected_layer()中初始化权重是均匀分布的。</span><br><span class="line">    // TODO：个人感觉，这里应该加一个if条件语句：if(weightfile)，因为如果导入了预训练权重文件，就没有必要这样初始化了（事实上在detector.c的train_detector()函数中，</span><br><span class="line">    // 紧接着parse_network_cfg()函数之后，就添加了if(weightfile)语句判断是否导入权重系数文件，如果导入了权重系数文件，也许这里初始化的值也会覆盖掉，</span><br><span class="line">    // 总之这里的权重初始化的处理方式还是值得思考的，也许更好的方式是应该设置专门的函数进行权重的初始化，同时偏置也是，不过这里似乎没有考虑偏置的初始化，在make_connected_layer()中倒是有。。。）</span><br><span class="line">    float scale = sqrt(2./(size*size*c/groups));</span><br><span class="line">    for(i = 0; i &lt; l.nweights; ++i) l.weights[i] = scale*rand_uniform(-1, 1);   // rand_normal();</span><br><span class="line">	// 根据该层输入图像的尺寸、卷积核尺寸以及跨度计算输出特征图的宽度和高度</span><br><span class="line">    int out_h = convolutional_out_height(l);</span><br><span class="line">    int out_w = convolutional_out_width(l);</span><br><span class="line">	// 输出图像高度</span><br><span class="line">    l.out_h = out_h;</span><br><span class="line">	// 输出图像宽度	</span><br><span class="line">    l.out_w = out_w;</span><br><span class="line">	// 输出图像通道数(等于卷积核个数,有多少个卷积核，最终就得到多少张特征图，每张特征图是一个通道)</span><br><span class="line">    l.out_c = n;</span><br><span class="line">    l.outputs = l.out_h * l.out_w * l.out_c; // 对应每张输入图片的所有输出特征图的总元素个数（每张输入图片会得到n也即l.out_c张特征图）</span><br><span class="line">    l.inputs = l.w * l.h * l.c; // mini-batch中每张输入图片的像素元素个数</span><br><span class="line">    l.activation = activation;</span><br><span class="line"></span><br><span class="line">    l.output = (float*)xcalloc(total_batch*l.outputs, sizeof(float)); // l.output为该层所有的输出（包括mini-batch所有输入图片的输出）</span><br><span class="line">#ifndef GPU</span><br><span class="line">    if (train) l.delta = (float*)xcalloc(total_batch*l.outputs, sizeof(float));  // l.delta 该层的敏感度图，和输出的维度想同</span><br><span class="line">#endif  // not GPU</span><br><span class="line"></span><br><span class="line">	// 卷积层三种指针函数，对应三种计算：前向，反向，更新</span><br><span class="line">    l.forward = forward_convolutional_layer;</span><br><span class="line">    l.backward = backward_convolutional_layer;</span><br><span class="line">    l.update = update_convolutional_layer;</span><br></pre></td></tr></table></figure><h2 id="卷积层前向传播的代码解析"><a href="#卷积层前向传播的代码解析" class="headerlink" title="卷积层前向传播的代码解析"></a>卷积层前向传播的代码解析</h2><p>代码在<code>src/convolutional_layer.c</code>中，注释如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">// 卷积层的前向传播核心代码</span><br><span class="line">void forward_convolutional_layer(convolutional_layer l, network_state state)</span><br><span class="line">&#123;</span><br><span class="line">    int out_h = convolutional_out_height(l);</span><br><span class="line">    int out_w = convolutional_out_width(l);</span><br><span class="line">    int i, j;</span><br><span class="line">	// l.outputs = l.out_h * l.out_w * l.out_c在make各网络层函数中赋值（比如make_convolutional_layer()），</span><br><span class="line">    // 对应每张输入图片的所有输出特征图的总元素个数（每张输入图片会得到n也即l.out_c张特征图）</span><br><span class="line">    // 初始化输出l.output全为0.0；输入l.outputs*l.batch为输出的总元素个数，其中l.outputs为batch</span><br><span class="line">    // 中一个输入对应的输出的所有元素的个数，l.batch为一个batch输入包含的图片张数；0表示初始化所有输出为0；</span><br><span class="line">    fill_cpu(l.outputs*l.batch, 0, l.output, 1);</span><br><span class="line"></span><br><span class="line">	// 是否进行二值化操作</span><br><span class="line">    if (l.xnor &amp;&amp; (!l.align_bit_weights || state.train)) &#123;</span><br><span class="line">        if (!l.align_bit_weights || state.train) &#123;</span><br><span class="line">            binarize_weights(l.weights, l.n, l.nweights, l.binary_weights);</span><br><span class="line">            //printf(&quot;\n binarize_weights l.align_bit_weights = %p \n&quot;, l.align_bit_weights);</span><br><span class="line">        &#125;</span><br><span class="line">        swap_binary(&amp;l);</span><br><span class="line">        binarize_cpu(state.input, l.c*l.h*l.w*l.batch, l.binary_input);</span><br><span class="line">        state.input = l.binary_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m = l.n / l.groups; // 该层的卷积核个数</span><br><span class="line">    int k = l.size*l.size*l.c / l.groups; // 该层每个卷积核的参数元素个数</span><br><span class="line">    int n = out_h*out_w; // 该层每个特征图的尺寸(元素个数)</span><br><span class="line"></span><br><span class="line">    static int u = 0;</span><br><span class="line">    u++;</span><br><span class="line">    // 该循环即为卷积计算核心代码：所有卷积核对batch中每张图片进行卷积运算</span><br><span class="line">    // 每次循环处理一张输入图片（所有卷积核对batch中一张图片做卷积运算）</span><br><span class="line">    for(i = 0; i &lt; l.batch; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">		// 该循环是为了处理分组卷积</span><br><span class="line">        for (j = 0; j &lt; l.groups; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">			// 当前组卷积核(也即权重)，元素个数为l.n*l.c/l.groups*l.size*l.size,</span><br><span class="line">            // 共有l.n行，l.c/l.gropus,l.c*l.size*l.size列</span><br><span class="line">            float *a = l.weights +j*l.nweights / l.groups;</span><br><span class="line">			// 对输入图像进行重排之后的图像数据，所以内存空间申请为网络中最大占用内存</span><br><span class="line">            float *b = state.workspace;</span><br><span class="line">			// 存储一张输入图片（多通道）当前组的输出特征图（输入图片是多通道的，输出</span><br><span class="line">            // 图片也是多通道的，有多少组卷积核就有多少组通道，每个分组后的卷积核得到一张特征图即为一个通道）</span><br><span class="line">            // 这里似乎有点拗口，可以看下分组卷积原理。</span><br><span class="line">            float *c = l.output +(i*l.groups + j)*n*m;</span><br><span class="line"></span><br><span class="line">            //gemm(0,0,m,n,k,1,a,k,b,n,1,c,n);</span><br><span class="line">            //gemm_nn_custom(m, n, k, 1, a, k, b, n, c, n);</span><br><span class="line">			//二值网络，特殊处理，里面还有一些优化，细节很多，这里暂时不管二值网络这部分，把注意力先放在普通卷积层的计算上</span><br><span class="line">            if (l.xnor &amp;&amp; l.align_bit_weights &amp;&amp; !state.train &amp;&amp; l.stride_x == l.stride_y)</span><br><span class="line">            &#123;</span><br><span class="line">                memset(b, 0, l.bit_align*l.size*l.size*l.c * sizeof(float));</span><br><span class="line"></span><br><span class="line">                if (l.c % 32 == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    //printf(&quot; l.index = %d - new XNOR \n&quot;, l.index);</span><br><span class="line"></span><br><span class="line">                    int ldb_align = l.lda_align;</span><br><span class="line">                    size_t new_ldb = k + (ldb_align - k%ldb_align); // (k / 8 + 1) * 8;</span><br><span class="line">                    //size_t t_intput_size = new_ldb * l.bit_align;// n;</span><br><span class="line">                    //size_t t_bit_input_size = t_intput_size / 8;// +1;</span><br><span class="line"></span><br><span class="line">                    int re_packed_input_size = l.c * l.w * l.h;</span><br><span class="line">                    memset(state.workspace, 0, re_packed_input_size * sizeof(float));</span><br><span class="line"></span><br><span class="line">                    const size_t new_c = l.c / 32;</span><br><span class="line">                    size_t in_re_packed_input_size = new_c * l.w * l.h + 1;</span><br><span class="line">                    memset(l.bin_re_packed_input, 0, in_re_packed_input_size * sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">                    //float *re_packed_input = calloc(l.c * l.w * l.h, sizeof(float));</span><br><span class="line">                    //uint32_t *bin_re_packed_input = calloc(new_c * l.w * l.h + 1, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">                    // float32x4 by channel (as in cuDNN)</span><br><span class="line">                    repack_input(state.input, state.workspace, l.w, l.h, l.c);</span><br><span class="line"></span><br><span class="line">                    // 32 x floats -&gt; 1 x uint32_t</span><br><span class="line">                    float_to_bit(state.workspace, (unsigned char *)l.bin_re_packed_input, l.c * l.w * l.h);</span><br><span class="line"></span><br><span class="line">                    //free(re_packed_input);</span><br><span class="line"></span><br><span class="line">                    // slow - convolution the packed inputs and weights: float x 32 by channel (as in cuDNN)</span><br><span class="line">                    //convolution_repacked((uint32_t *)bin_re_packed_input, (uint32_t *)l.align_bit_weights, l.output,</span><br><span class="line">                    //    l.w, l.h, l.c, l.n, l.size, l.pad, l.new_lda, l.mean_arr);</span><br><span class="line"></span><br><span class="line">                    // // then exit from if()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    im2col_cpu_custom((float *)l.bin_re_packed_input, new_c, l.h, l.w, l.size, l.stride, l.pad, state.workspace);</span><br><span class="line">                    //im2col_cpu((float *)bin_re_packed_input, new_c, l.h, l.w, l.size, l.stride, l.pad, b);</span><br><span class="line"></span><br><span class="line">                    //free(bin_re_packed_input);</span><br><span class="line"></span><br><span class="line">                    int new_k = l.size*l.size*l.c / 32;</span><br><span class="line"></span><br><span class="line">                    // good for (l.c == 64)</span><br><span class="line">                    //gemm_nn_bin_32bit_packed(m, n, new_k, 1,</span><br><span class="line">                    //    l.align_bit_weights, l.new_lda/32,</span><br><span class="line">                    //    b, n,</span><br><span class="line">                    //    c, n, l.mean_arr);</span><br><span class="line"></span><br><span class="line">    // // then exit from if()</span><br><span class="line"></span><br><span class="line">                    transpose_uint32((uint32_t *)state.workspace, (uint32_t*)l.t_bit_input, new_k, n, n, new_ldb);</span><br><span class="line"></span><br><span class="line">                    // the main GEMM function</span><br><span class="line">                    gemm_nn_custom_bin_mean_transposed(m, n, k, 1, (unsigned char*)l.align_bit_weights, new_ldb, (unsigned char*)l.t_bit_input, new_ldb, c, n, l.mean_arr);</span><br><span class="line"></span><br><span class="line">                    // // alternative GEMM</span><br><span class="line">                    //gemm_nn_bin_transposed_32bit_packed(m, n, new_k, 1,</span><br><span class="line">                    //    l.align_bit_weights, l.new_lda/32,</span><br><span class="line">                    //    t_bit_input, new_ldb / 32,</span><br><span class="line">                    //    c, n, l.mean_arr);</span><br><span class="line"></span><br><span class="line">                    //free(t_bit_input);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123; // else (l.c % 32 != 0)</span><br><span class="line"></span><br><span class="line">                    //--------------------------------------------------------</span><br><span class="line">                    //printf(&quot; l.index = %d - old XNOR \n&quot;, l.index);</span><br><span class="line"></span><br><span class="line">                    //im2col_cpu_custom_align(state.input, l.c, l.h, l.w, l.size, l.stride, l.pad, b, l.bit_align);</span><br><span class="line">                    im2col_cpu_custom_bin(state.input, l.c, l.h, l.w, l.size, l.stride, l.pad, state.workspace, l.bit_align);</span><br><span class="line"></span><br><span class="line">                    //size_t output_size = l.outputs;</span><br><span class="line">                    //float *count_output = calloc(output_size, sizeof(float));</span><br><span class="line">                    //size_t bit_output_size = output_size / 8 + 1;</span><br><span class="line">                    //char *bit_output = calloc(bit_output_size, sizeof(char));</span><br><span class="line"></span><br><span class="line">                    //size_t intput_size = n * k; // (out_h*out_w) X (l.size*l.size*l.c) : after im2col()</span><br><span class="line">                    //size_t bit_input_size = intput_size / 8 + 1;</span><br><span class="line">                    //char *bit_input = calloc(bit_input_size, sizeof(char));</span><br><span class="line"></span><br><span class="line">                    //size_t weights_size = k * m; //l.size*l.size*l.c*l.n; // l.nweights</span><br><span class="line">                    //size_t bit_weights_size = weights_size / 8 + 1;</span><br><span class="line"></span><br><span class="line">                    //char *bit_weights = calloc(bit_weights_size, sizeof(char));</span><br><span class="line">                    //float *mean_arr = calloc(l.n, sizeof(float));</span><br><span class="line"></span><br><span class="line">                    // transpose B from NxK to KxN (x-axis (ldb = l.size*l.size*l.c) - should be multiple of 8 bits)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //size_t ldb_align = 256; // 256 bit for AVX2</span><br><span class="line">                        int ldb_align = l.lda_align;</span><br><span class="line">                        size_t new_ldb = k + (ldb_align - k%ldb_align);</span><br><span class="line">                        size_t t_intput_size = binary_transpose_align_input(k, n, state.workspace, &amp;l.t_bit_input, ldb_align, l.bit_align);</span><br><span class="line"></span><br><span class="line">                        // 5x times faster than gemm()-float32</span><br><span class="line">                        gemm_nn_custom_bin_mean_transposed(m, n, k, 1, (unsigned char*)l.align_bit_weights, new_ldb, (unsigned char*)l.t_bit_input, new_ldb, c, n, l.mean_arr);</span><br><span class="line"></span><br><span class="line">                        //gemm_nn_custom_bin_mean_transposed(m, n, k, 1, bit_weights, k, t_bit_input, new_ldb, c, n, mean_arr);</span><br><span class="line"></span><br><span class="line">                        //free(t_input);</span><br><span class="line">                        //free(t_bit_input);</span><br><span class="line">                        //&#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                add_bias(l.output, l.biases, l.batch, l.n, out_h*out_w);</span><br><span class="line"></span><br><span class="line">                //activate_array(l.output, m*n*l.batch, l.activation);</span><br><span class="line">                if (l.activation == SWISH) activate_array_swish(l.output, l.outputs*l.batch, l.activation_input, l.output);</span><br><span class="line">                else if (l.activation == MISH) activate_array_mish(l.output, l.outputs*l.batch, l.activation_input, l.output);</span><br><span class="line">                else if (l.activation == NORM_CHAN) activate_array_normalize_channels(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output);</span><br><span class="line">                else if (l.activation == NORM_CHAN_SOFTMAX) activate_array_normalize_channels_softmax(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output, 0);</span><br><span class="line">                else if (l.activation == NORM_CHAN_SOFTMAX_MAXVAL) activate_array_normalize_channels_softmax(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output, 1);</span><br><span class="line">                else activate_array_cpu_custom(l.output, m*n*l.batch, l.activation);</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //printf(&quot; l.index = %d - FP32 \n&quot;, l.index);</span><br><span class="line">				// 由于有分组卷积，所以获取属于当前组的输入im并按一定存储规则排列的数组b，</span><br><span class="line">				// 以方便、高效地进行矩阵（卷积）计算，详细查看该函数注释（比较复杂）</span><br><span class="line">				// 这里的im实际上只加载了一张图片的数据</span><br><span class="line">				// 关于im2col的原理我会讲</span><br><span class="line">                float *im = state.input + (i*l.groups + j)*(l.c / l.groups)*l.h*l.w;</span><br><span class="line">				// 如果这里卷积核尺寸为1，是不需要改变内存排布方式</span><br><span class="line">                if (l.size == 1) &#123;</span><br><span class="line">                    b = im;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //im2col_cpu(im, l.c / l.groups, l.h, l.w, l.size, l.stride, l.pad, b);</span><br><span class="line">					// 将多通道二维图像im变成按一定存储规则排列的数组b，</span><br><span class="line">					// 以方便、高效地进行矩阵（卷积）计算，详细查看该函数注释（比较复杂）</span><br><span class="line">					// 进行重排，l.c/groups为每张图片的通道数分组，l.h为每张图片的高度，l.w为每张图片的宽度，l.size为卷积核尺寸，l.stride为步长</span><br><span class="line">					// 得到的b为一张图片重排后的结果，也是按行存储的一维数组（共有l.c/l.groups*l.size*l.size行，l.out_w*l.out_h列）</span><br><span class="line">                    im2col_cpu_ext(im,   // input</span><br><span class="line">                        l.c / l.groups,     // input channels</span><br><span class="line">                        l.h, l.w,           // input size (h, w)</span><br><span class="line">                        l.size, l.size,     // kernel size (h, w)</span><br><span class="line">                        l.pad, l.pad,       // padding (h, w)</span><br><span class="line">                        l.stride_y, l.stride_x, // stride (h, w)</span><br><span class="line">                        l.dilation, l.dilation, // dilation (h, w)</span><br><span class="line">                        b);                 // output</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">				// 此处在im2col_cpu操作基础上，利用矩阵乘法c=alpha*a*b+beta*c完成对图像卷积的操作</span><br><span class="line">				// 0,0表示不对输入a,b进行转置，</span><br><span class="line">				// m是输入a,c的行数，具体含义为每个卷积核的个数，</span><br><span class="line">				// n是输入b,c的列数，具体含义为每个输出特征图的元素个数(out_h*out_w)，</span><br><span class="line">				// k是输入a的列数也是b的行数，具体含义为卷积核元素个数乘以输入图像的通道数除以分组数（l.size*l.size*l.c/l.groups），</span><br><span class="line">				// a,b,c即为三个参与运算的矩阵（用一维数组存储）,alpha=beta=1为常系数，</span><br><span class="line">				// a为所有卷积核集合,元素个数为l.n*l.c/l.groups*l.size*l.size，按行存储，共有l*n行，l.c/l.groups*l.size*l.size列，</span><br><span class="line">				// 即a中每行代表一个可以作用在3通道上的卷积核，</span><br><span class="line">				// b为一张输入图像经过im2col_cpu重排后的图像数据（共有l.c/l.group*l.size*l.size行，l.out_w*l.out_h列），</span><br><span class="line">				// c为gemm()计算得到的值，包含一张输入图片得到的所有输出特征图（每个卷积核得到一张特征图），c中一行代表一张特征图，</span><br><span class="line">				// 各特征图铺排开成一行后，再将所有特征图并成一大行，存储在c中，因此c可视作有l.n行，l.out_h*l.out_w列。</span><br><span class="line">				// 详细查看该函数注释（比较复杂）</span><br><span class="line">                gemm(0, 0, m, n, k, 1, a, k, b, n, 1, c, n);</span><br><span class="line">                // bit-count to float</span><br><span class="line">            &#125;</span><br><span class="line">            //c += n*m;</span><br><span class="line">            //state.input += l.c*l.h*l.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	// 如果卷积层使用了BatchNorm，那么执行forward_batchnorm，如果没有，则添加偏置</span><br><span class="line">    if(l.batch_normalize)&#123;</span><br><span class="line">        forward_batchnorm_layer(l, state);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        add_bias(l.output, l.biases, l.batch, l.n, out_h*out_w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //activate_array(l.output, m*n*l.batch, l.activation);</span><br><span class="line">	// 使用不同的激活函数</span><br><span class="line">    if (l.activation == SWISH) activate_array_swish(l.output, l.outputs*l.batch, l.activation_input, l.output);</span><br><span class="line">    else if (l.activation == MISH) activate_array_mish(l.output, l.outputs*l.batch, l.activation_input, l.output);</span><br><span class="line">    else if (l.activation == NORM_CHAN) activate_array_normalize_channels(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output);</span><br><span class="line">    else if (l.activation == NORM_CHAN_SOFTMAX) activate_array_normalize_channels_softmax(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output, 0);</span><br><span class="line">    else if (l.activation == NORM_CHAN_SOFTMAX_MAXVAL) activate_array_normalize_channels_softmax(l.output, l.outputs*l.batch, l.batch, l.out_c, l.out_w*l.out_h, l.output, 1);</span><br><span class="line">    else activate_array_cpu_custom(l.output, l.outputs*l.batch, l.activation);</span><br><span class="line">	// 二值网络，前向传播结束之后转回float</span><br><span class="line">    if(l.binary || l.xnor) swap_binary(&amp;l);</span><br><span class="line"></span><br><span class="line">    //visualize_convolutional_layer(l, &quot;conv_visual&quot;, NULL);</span><br><span class="line">    //wait_until_press_key_cv();</span><br><span class="line">	// 暂时不懂</span><br><span class="line">    if(l.assisted_excitation &amp;&amp; state.train) assisted_excitation_forward(l, state);</span><br><span class="line">	// 暂时不懂</span><br><span class="line">    if (l.antialiasing) &#123;</span><br><span class="line">        network_state s = &#123; 0 &#125;;</span><br><span class="line">        s.train = state.train;</span><br><span class="line">        s.workspace = state.workspace;</span><br><span class="line">        s.net = state.net;</span><br><span class="line">        s.input = l.output;</span><br><span class="line">        forward_convolutional_layer(*(l.input_layer), s);</span><br><span class="line">        //simple_copy_ongpu(l.outputs*l.batch, l.output, l.input_antialiasing);</span><br><span class="line">        memcpy(l.output, l.input_layer-&gt;output, l.input_layer-&gt;outputs * l.input_layer-&gt;batch * sizeof(float));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="im2col解析"><a href="#im2col解析" class="headerlink" title="im2col解析"></a>im2col解析</h2><p>从上面的代码可以知道，卷积层的前向传播核心点是im2col操作还有sgemm矩阵计算方法对使用im2col进行重排后的数据进行计算。现在来解析一下im2col算法，sgemm算法就是im2col运行后直接调用即可，就不细讲了。</p><p>这里考虑到结合图片更容易理解im2col的思想，我利用CSDN Tiger-Gao博主的图描述一下。首先，我们把一个单通道的长宽均为4的图片通过im2col重新排布后会变成什么样呢？看下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/649.webp" alt></p><p>来具体看一下变化过程：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/650.webp" alt></p><p>这是单通道的变化过程，那么多通道的呢？首先来看原图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/651.png" alt></p><p>多通道的im2col的过程，是首先im2col第一通道，然后再im2col第二通道，最后im2col第三通道。各通道im2col的数据在内存中也是连续存储的。看下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/652.webp" alt></p><p>这是原图经过im2col的变化，那么kernel呢？看原图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/653.webp" alt></p><p>kernel的通道数据在内存中也是连续存储的。所以上面的kernel图像经过im2col算法后可以表示为下图：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/654.webp" alt></p><p>那么我们是如何得到前向传播的结果呢？在DarkNet中和Caffe的实现方式一样，都是Kernel*Img，即是在矩阵乘法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M=1 </span><br><span class="line">N=output_h * output_w</span><br><span class="line">K=input_channels * kernel_h * kernel_w</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/655.webp" alt></p><p>图像数据是连续存储，因此输出图像也可以如下图所示【output_h x output_w】=【2 x 2】：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/656.png" alt></p><p>对于多通道图像过程类似：</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/657.webp" alt></p><p>同样，多个输出通道图像的数据是连续存储，因此输出图像也可以如下图所示【output_channels x output_h x output_w】=【3 x 2 x 2】</p><p><img src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/ABDarknet/658.webp" alt></p><p>im2col算法的实现在<code>src/im2col.c</code>中，即<code>im2col_cpu</code>函数。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** 从输入的多通道数组im（存储图像数据）中获取指定行，列，通道数处的元素值</span><br><span class="line">** im:  函数的输入，所有的数据存成一个一维数组</span><br><span class="line">** height: 每一个通道的高度(即是输入图像的真正高度，补0之前)</span><br><span class="line">** width: 每一个通道的宽度(即是输入图像的真正宽度，补0之前)</span><br><span class="line">** channles：输入通道数</span><br><span class="line">** row: 要提取的元素所在的行(padding之后的行数)</span><br><span class="line">** col: 要提取的元素所在的列(padding之后的列数)</span><br><span class="line">** channel: 要提取的元素所在的通道</span><br><span class="line">** pad: 图像上下左右补0的个数，四周是一样的</span><br><span class="line">** 返回im中channel通道，row-pad行,col-pad列处的元素值</span><br><span class="line">** 在im中并没有存储补0的元素值，因此height，width都是没有补0时输入图像真正的高、宽；</span><br><span class="line">** 而row与col则是补0之后，元素所在的行列，因此，要准确获取在im中的元素值，首先需要</span><br><span class="line">** 减去pad以获取在im中真实的行列数</span><br><span class="line">*/</span><br><span class="line">float im2col_get_pixel(float *im, int height, int width, int channels,</span><br><span class="line">                        int row, int col, int channel, int pad)</span><br><span class="line">&#123;</span><br><span class="line">	//减去补0长度，获取像素真实的行列数</span><br><span class="line">    row -= pad;</span><br><span class="line">    col -= pad;</span><br><span class="line">	// 如果行列数&lt;0，或者超过height/width，则返回0(刚好是补0的效果)</span><br><span class="line">    if (row &lt; 0 || col &lt; 0 ||</span><br><span class="line">        row &gt;= height || col &gt;= width) return 0;</span><br><span class="line">	// im存储多通道二维图像的数据格式为: 各个通道所有的所有行并成1行，再多通道依次并成一行</span><br><span class="line">    // 因此width*height*channel首先移位到所在通道的起点位置，再加上width*row移位到所在指定</span><br><span class="line">    // 通道行，再加上col移位到所在列</span><br><span class="line">    return im[col + width*(row + height*channel)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//From Berkeley Vision&#x27;s Caffe!</span><br><span class="line">//https://github.com/BVLC/caffe/blob/master/LICENSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">** 将输入图片转为便于计算的数组格式</span><br><span class="line">** data_im: 输入图像</span><br><span class="line">** height: 输入图像的高度(行)</span><br><span class="line">** width: 输入图像的宽度(列)</span><br><span class="line">** ksize: 卷积核尺寸</span><br><span class="line">** stride: 卷积核跨度</span><br><span class="line">** pad: 四周补0的长度</span><br><span class="line">** data_col: 相当于输出，为进行格式重排后的输入图像数据</span><br><span class="line">** 输出data_col的元素个数与data_im个数不相等，一般比data_im个数多，因为stride较小，各个卷积核之间有很多重叠，</span><br><span class="line">** 实际data_col中的元素个数为channels*ksize*ksize*height_col*width_col，其中channels为data_im的通道数，</span><br><span class="line">** ksize为卷积核大小，height_col和width_col如下所注。data_col的还是按行排列，只是行数为channels*ksize*ksize,</span><br><span class="line">** 列数为height_col*width_col，即一张特征图总的元素个数，每整列包含与某个位置处的卷积核计算的所有通道上的像素，</span><br><span class="line">** （比如输入图像通道数为3,卷积核尺寸为3*3，则共有27行，每列有27个元素），不同列对应卷积核在图像上的不同位置做卷积</span><br><span class="line">*/</span><br><span class="line">void im2col_cpu(float* data_im,</span><br><span class="line">     int channels,  int height,  int width,</span><br><span class="line">     int ksize,  int stride, int pad, float* data_col)</span><br><span class="line">&#123;</span><br><span class="line">    int c,h,w;</span><br><span class="line">	// 计算该层神经网络的输出图像尺寸（其实没有必要再次计算的，因为在构建卷积层时，make_convolutional_layer()函数</span><br><span class="line">    // 已经调用convolutional_out_width()，convolutional_out_height()函数求取了这两个参数，</span><br><span class="line">    // 此处直接使用l.out_h,l.out_w即可，函数参数只要传入该层网络指针就可了，没必要弄这么多参数）</span><br><span class="line">    int height_col = (height + 2*pad - ksize) / stride + 1;</span><br><span class="line">    int width_col = (width + 2*pad - ksize) / stride + 1;</span><br><span class="line">	// 卷积核大小：ksize*ksize是一个卷积核的大小，之所以乘以通道数channels，是因为输入图像有多通道，每个卷积核在做卷积时，</span><br><span class="line">    // 是同时对同一位置多通道的图像进行卷积运算，这里为了实现这一目的，将三个通道将三通道上的卷积核并在一起以便进行计算，因此卷积核</span><br><span class="line">    // 实际上并不是二维的，而是三维的，比如对于3通道图像，卷积核尺寸为3*3，该卷积核将同时作用于三通道图像上，这样并起来就得</span><br><span class="line">    // 到含有27个元素的卷积核，且这27个元素都是独立的需要训练的参数。所以在计算训练参数个数时，一定要注意每一个卷积核的实际</span><br><span class="line">    // 训练参数需要乘以输入通道数。</span><br><span class="line">    int channels_col = channels * ksize * ksize;</span><br><span class="line">	// 外循环次数为一个卷积核的尺寸数，循环次数即为最终得到的data_col的总行数</span><br><span class="line">    for (c = 0; c &lt; channels_col; ++c) &#123;</span><br><span class="line">		// 列偏移，卷积核是一个二维矩阵，并按行存储在一维数组中，利用求余运算获取对应在卷积核中的列数，比如对于</span><br><span class="line">        // 3*3的卷积核（3通道），当c=0时，显然在第一列，当c=5时，显然在第2列，当c=9时，在第二通道上的卷积核的第一列，</span><br><span class="line">        // 当c=26时，在第三列（第三通道上）</span><br><span class="line">        int w_offset = c % ksize;</span><br><span class="line">		// 行偏移，卷积核是一个二维的矩阵，且是按行（卷积核所有行并成一行）存储在一维数组中的，</span><br><span class="line">        // 比如对于3*3的卷积核，处理3通道的图像，那么一个卷积核具有27个元素，每9个元素对应一个通道上的卷积核（互为一样），</span><br><span class="line">        // 每当c为3的倍数，就意味着卷积核换了一行，h_offset取值为0,1,2，对应3*3卷积核中的第1, 2, 3行</span><br><span class="line">        int h_offset = (c / ksize) % ksize;</span><br><span class="line">		// 通道偏移，channels_col是多通道的卷积核并在一起的，比如对于3通道，3*3卷积核，每过9个元素就要换一通道数，</span><br><span class="line">        // 当c=0~8时，c_im=0;c=9~17时，c_im=1;c=18~26时，c_im=2</span><br><span class="line">        int c_im = c / ksize / ksize;</span><br><span class="line">		// 中循环次数等于该层输出图像行数height_col，说明data_col中的每一行存储了一张特征图，这张特征图又是按行存储在data_col中的某行中</span><br><span class="line">        for (h = 0; h &lt; height_col; ++h) &#123;</span><br><span class="line">			// 内循环等于该层输出图像列数width_col，说明最终得到的data_col总有channels_col行，height_col*width_col列</span><br><span class="line">            for (w = 0; w &lt; width_col; ++w) &#123;</span><br><span class="line">				// 由上面可知，对于3*3的卷积核，h_offset取值为0,1,2,当h_offset=0时，会提取出所有与卷积核第一行元素进行运算的像素，</span><br><span class="line">                // 依次类推；加上h*stride是对卷积核进行行移位操作，比如卷积核从图像(0,0)位置开始做卷积，那么最先开始涉及(0,0)~(3,3)</span><br><span class="line">                // 之间的像素值，若stride=2，那么卷积核进行一次行移位时，下一行的卷积操作是从元素(2,0)（2为图像行号，0为列号）开始</span><br><span class="line">                int im_row = h_offset + h * stride;</span><br><span class="line">				// 对于3*3的卷积核，w_offset取值也为0,1,2，当w_offset取1时，会提取出所有与卷积核中第2列元素进行运算的像素，</span><br><span class="line">                // 实际在做卷积操作时，卷积核对图像逐行扫描做卷积，加上w*stride就是为了做列移位，</span><br><span class="line">                // 比如前一次卷积其实像素元素为(0,0)，若stride=2,那么下次卷积元素起始像素位置为(0,2)（0为行号，2为列号）</span><br><span class="line">                int im_col = w_offset + w * stride;</span><br><span class="line">				// col_index为重排后图像中的像素索引，等于c * height_col * width_col + h * width_col +w（还是按行存储，所有通道再并成一行），</span><br><span class="line">                // 对应第c通道，h行，w列的元素</span><br><span class="line">                int col_index = (c * height_col + h) * width_col + w;</span><br><span class="line">				// im2col_get_pixel函数获取输入图像data_im中第c_im通道，im_row,im_col的像素值并赋值给重排后的图像，</span><br><span class="line">                // height和width为输入图像data_im的真实高、宽，pad为四周补0的长度（注意im_row,im_col是补0之后的行列号，</span><br><span class="line">                // 不是真实输入图像中的行列号，因此需要减去pad获取真实的行列号）</span><br><span class="line">                data_col[col_index] = im2col_get_pixel(data_im, height, width, channels,</span><br><span class="line">                        im_row, im_col, c_im, pad);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Qiyuan-Z</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qiyuan-z.github.io/2020/02/23/AlexeyAB-DarkNet%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%A7%A3%E6%9E%90/">https://qiyuan-z.github.io/2020/02/23/AlexeyAB-DarkNet%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Qiyuan-Z.github.io" target="_blank">Yuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><a class="post-meta__tags" href="/tags/YOLOv3/">YOLOv3</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/23/Ubuntu%E9%85%8D%E7%BD%AEv2ray%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"><img class="prev-cover" src="/img/No_Cover.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubuntu配置v2ray详细教程</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/22/AlexeyAB-DarkNet%E7%BD%91%E7%BB%9C%E7%9A%84%E5%89%8D%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Alayer%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/"><img class="next-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AlexeyAB DarkNet网络的前向和反向传播介绍以及layer的详细解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02/18/YOLOv3模型构建中的YOLOLayer/" title="YOLOv3模型构建中的YOLOLayer"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3模型构建中的YOLOLayer</div></div></a></div><div><a href="/2020/02/18/YOLOv3网络模型的构建/" title="YOLOv3网络模型的构建"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3网络模型的构建</div></div></a></div><div><a href="/2020/02/18/在YOLOv3模型中添加Attention机制/" title="在YOLOv3模型中添加Attention机制"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">在YOLOv3模型中添加Attention机制</div></div></a></div><div><a href="/2020/02/15/Pytorch版YOLOv3中的代码配置和数据集构建/" title="Pytorch版YOLOv3中的代码配置和数据集构建"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">Pytorch版YOLOv3中的代码配置和数据集构建</div></div></a></div><div><a href="/2020/02/15/YOLOv3中的参数进化/" title="YOLOv3中的参数进化"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3中的参数进化</div></div></a></div><div><a href="/2020/02/15/YOLOv3的数据加载机制和增强方法/" title="YOLOv3的数据加载机制和增强方法"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3的数据加载机制和增强方法</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">2.</span> <span class="toc-text">卷积层的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">卷积层前向传播的代码解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#im2col%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">im2col解析</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022<i id="heartbeat" class="fa fas fa-heartbeat"></i> Qiyuan-Z</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br>昨日までの私は、もうどこにもいない<br></p></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk({clientID:"2d10cfb27783db577e70",clientSecret:"154292876bb14966f6ae57304b67859617b08c94",repo:"gitalk",owner:"Qiyuan-Z",admin:["Qiyuan-Z"],id:"a5e3aa06b5078f3834353391c6bfc8ee",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount}).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/gh/Qiyuan-Z/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body></html>