<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://Qiyuan-Z.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="article">
<meta property="og:title" content="AlexeyAB DarkNet加载数据进行训练">
<meta property="og:url" content="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/index.html">
<meta property="og:site_name" content="Yuan">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-21T03:29:43.809Z">
<meta property="article:modified_time" content="2020-02-21T03:29:43.935Z">
<meta property="article:author" content="Qiyuan-Z">
<meta property="article:tag" content="目标检测">
<meta property="article:tag" content="YOLOv3">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>AlexeyAB DarkNet加载数据进行训练 | Yuan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Qiyuan-Z">
      <meta itemprop="description" content="偉大な魂は目的を持ち、そうでないものは願望を持つ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AlexeyAB DarkNet加载数据进行训练
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-21 11:29:43" itemprop="dateCreated datePublished" datetime="2020-02-21T11:29:43+08:00">2020-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title=" 前言"></a><a id="more"></a> 前言</h2><p>之前讲了DarkNet的底层数据结构，并且将网络配置文件进行了解析存放到了一个<code>network</code>结构体中，那么我们就要来看一下Darknet是如何加载数据进行训练的。</p>
<h2 id="加载训练数据"><a href="#加载训练数据" class="headerlink" title="加载训练数据"></a>加载训练数据</h2><p>DarkNet的数据加载函数<code>load_data()</code>在<code>src/data.c</code>中实现（<code>src/detector.c</code>函数中的<code>train_detector</code>直接调用这个函数加载数据）。<code>load_data()</code>函数调用流程如下：<code>load_data(args)-&gt;load_threads()-&gt;load_data_in_threads()-&gt;load_thread()-&gt;load_data_detection()</code>，前四个函数都是在对线程的调用进行封装。最底层的数据加载任务由<code>load_data_detection()</code>函数完成。所有的数据(图片数据和标注信息数据)加载完成之后再拼接到一个大的数组中。在DarkNet中，图片的存储形式是一个行向量，向量长度为<code>h*w*3</code>。同时图片被归一化到<code>[0, 1]</code>之间。</p>
<h2 id="load-threads-完成线程分配和数据拼接"><a href="#load-threads-完成线程分配和数据拼接" class="headerlink" title="load_threads()完成线程分配和数据拼接"></a>load_threads()完成线程分配和数据拼接</h2><p><code>load_threads</code>在<code>src/data.c</code>中实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; copy from https:&#x2F;&#x2F;github.com&#x2F;hgpvision&#x2F;darknet&#x2F;blob&#x2F;master&#x2F;src&#x2F;data.c#L355</span><br><span class="line">&#x2F;*</span><br><span class="line">** 开辟多个线程读入图片数据，读入数据存储至ptr.d中（主要调用load_in_thread()函数完成）</span><br><span class="line">** 输入：ptr    包含所有线程要读入图片数据的信息（读入多少张，开几个线程读入，读入图片最终的宽高，图片路径等等）</span><br><span class="line">** 返回：void*  万能指针（实际上不需要返回什么）</span><br><span class="line">** 说明：1) load_threads()是一个指针函数，只是一个返回变量为void*的普通函数，不是函数指针</span><br><span class="line">**       2) 输入ptr是一个void*指针（万能指针），使用时需要强转为具体类型的指针</span><br><span class="line">**       3) 函数中涉及四个用来存储读入数据的变量：ptr, args, out, buffers，除args外都是data*类型，所有这些变量的</span><br><span class="line">**          指针变量其实都指向同一块内存（当然函数中间有些动态变化），因此读入的数据都是互通的。</span><br><span class="line">** 流程：本函数首先会获取要读入图片的张数、要开启线程的个数，而后计算每个线程应该读入的图片张数（尽可能的均匀分配），</span><br><span class="line">**       并创建所有的线程，并行读入数据，最后合并每个线程读入的数据至一个大data中，这个data的指针变量与ptr的指针变量</span><br><span class="line">**       指向的是统一块内存，因此也就最终将数据读入到ptr.d中（所以其实没有返回值）</span><br><span class="line">*&#x2F;</span><br><span class="line">void *load_threads(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;srand(time(0));</span><br><span class="line">    int i;</span><br><span class="line">	&#x2F;&#x2F; 先使用(load_args*)强转void*指针，而后取ptr所指内容赋值给args</span><br><span class="line">    &#x2F;&#x2F; 虽然args不是指针，args是深拷贝了ptr中的内容，但是要知道ptr（也就是load_args数据类型），有很多的</span><br><span class="line">    &#x2F;&#x2F; 指针变量，args深拷贝将拷贝这些指针变量到args中（这些指针变量本身对ptr来说就是内容，</span><br><span class="line">    &#x2F;&#x2F; 而args所指的值是args的内容，不是ptr的，不要混为一谈），因此，args与ptr将会共享所有指针变量所指的内容</span><br><span class="line">    load_args args &#x3D; *(load_args *)ptr;</span><br><span class="line">    if (args.threads &#x3D;&#x3D; 0) args.threads &#x3D; 1;</span><br><span class="line">	&#x2F;&#x2F; 另指针变量out&#x3D;args.d，使得out与args.d指向统一块内存，之后，args.d所指的内存块会变（反正也没什么用了，变就变吧），</span><br><span class="line">    &#x2F;&#x2F; 但out不会变，这样可以保证out与最原始的ptr指向同一块存储读入图片数据的内存块，因此最终将图片读到out中，</span><br><span class="line">    &#x2F;&#x2F; 实际就是读到了最原始的ptr中，比如train_detector()函数中定义的args.d中</span><br><span class="line">    data *out &#x3D; args.d;</span><br><span class="line">	&#x2F;&#x2F; 读入图片的总张数&#x3D; batch * subdivision * ngpus，可参见train_detector()函数中的赋值</span><br><span class="line">    int total &#x3D; args.n;</span><br><span class="line">	&#x2F;&#x2F; 释放ptr：ptr是传入的指针变量，传入的指针变量本身也是按值传递的，即传入函数之后，指针变量得到复制，函数内的形参ptr</span><br><span class="line">    &#x2F;&#x2F; 获取外部实参的值之后，二者本身没有关系，但是由于是指针变量，二者之间又存在一丝关系，那就是函数内形参与函数外实参指向</span><br><span class="line">    &#x2F;&#x2F; 同一块内存。又由于函数外实参内存是动态分配的，因此函数内的形参可以使用free()函数进行内存释放，但一般不推荐这么做，因为函数内释放内存，</span><br><span class="line">    &#x2F;&#x2F; 会影响函数外实参的使用，可能使之成为野指针，那为什么这里可以用free()释放ptr呢，不会出现问题吗？</span><br><span class="line">    &#x2F;&#x2F; 其一，因为ptr是一个结构体，是一个包含众多的指针变量的结构体，如data* d等（当然还有其他非指针变量如int h等），</span><br><span class="line">    &#x2F;&#x2F; 直接free(ptr)将会导致函数外实参无法再访问非指针变量int h等（实际经过测试，在gcc编译器下，能访问但是值被重新初始化为0），</span><br><span class="line">    &#x2F;&#x2F; 因为函数内形参和函数外实参共享一块堆内存，而这些非指针变量都是存在这块堆内存上的，内存一释放，就无法访问了；</span><br><span class="line">    &#x2F;&#x2F; 但是对于指针变量，free(ptr)将无作为（这个结论也是经过测试的，也是用的gcc编译器），不会释放或者擦写掉ptr指针变量本身的值，</span><br><span class="line">    &#x2F;&#x2F; 当然也不会影响函数外实参，更不会牵扯到这些指针变量所指的内存块，总的来说，</span><br><span class="line">    &#x2F;&#x2F; free(ptr)将使得ptr不能再访问指针变量（如int h等，实际经过测试，在gcc编译器下，能访问但是值被重新初始化为0），</span><br><span class="line">    &#x2F;&#x2F; 但其指针变量本身没有受影响，依旧可以访问；对于函数外实参，同样不能访问非指针变量，而指针变量不受影响，依旧可以访问。</span><br><span class="line">    &#x2F;&#x2F; 其二，darknet数据读取的实现一层套一层（似乎有点罗嗦，总感觉代码可以不用这么写的:)），具体调用过程如下：</span><br><span class="line">    &#x2F;&#x2F; load_data(load_args args)-&gt;load_threads(load_args* ptr)-&gt;load_data_in_thread(load_args args)-&gt;load_thread(load_args* ptr)，</span><br><span class="line">    &#x2F;&#x2F; 就在load_data()中，重新定义了ptr，并为之动态分配了内存，且深拷贝了传给load_data()函数的值args，也就是说在此之后load_data()函数中的args除了其中的指针变量指着同一块堆内存之外，</span><br><span class="line">    &#x2F;&#x2F; 二者的非指针变量再无瓜葛，不管之后经过多少个函数，对ptr的非指针变量做了什么改动，比如这里直接free(ptr)，使得非指针变量值为0,都不会影响load_data()中的args的非指针变量，也就不会影响更为顶层函数中定义的args的非指针变量的值，</span><br><span class="line">    &#x2F;&#x2F; 比如train_detector()函数中的args，train_detector()对args非指针变量赋的值都不会受影响，保持不变。综其两点，此处直接free(ptr)是安全的。</span><br><span class="line">    &#x2F;&#x2F; 说明：free(ptr)函数，确定会做的事是使得内存块可以重新分配，且不会影响指针变量ptr本身的值，也就是ptr还是指向那块地址， 虽然可以使用，但很危险，因为这块内存实际是无效的，</span><br><span class="line">    &#x2F;&#x2F;      系统已经认为这块内存是可分配的，会毫不考虑的将这块内存分给其他变量，这样，其值随时都可能会被其他变量改变，这种情况下的ptr指针就是所谓的野指针（所以经常可以看到free之后，置原指针为NULL）。</span><br><span class="line">    &#x2F;&#x2F;      而至于free(ptr)还不会做其他事情，比如会不会重新初始化这块内存为0（擦写掉），以及怎么擦写，这些操作，是不确定的，可能跟具体的编译器有关（个人猜测），</span><br><span class="line">    &#x2F;&#x2F;      经过测试，对于gcc编译器，free(ptr)之后，ptr中的非指针变量的地址不变，但其值全部擦写为0；ptr中的指针变量，丝毫不受影响，指针变量本身没有被擦写，</span><br><span class="line">    &#x2F;&#x2F;      存储的地址还是指向先前分配的内存块，所以ptr能够正常访问其指针变量所指的值。测试代码为darknet_test_struct_memory_free.c。</span><br><span class="line">    &#x2F;&#x2F;      不知道这段测试代码在VS中执行会怎样，还没经过测试，也不知道换用其他编译器（darknet的Makefile文件中，指定了编译器为gcc），darknet的编译会不会有什么问题？？</span><br><span class="line">    &#x2F;&#x2F;      关于free()，可以看看：http:&#x2F;&#x2F;blog.sina.com.cn&#x2F;s&#x2F;blog_615ec1630102uwle.html，文章最后有一个很有意思的比喻，但意思好像就和我这里说的有点不一样了（到底是不是编译器搞得鬼呢？？）。</span><br><span class="line">    free(ptr);</span><br><span class="line">	&#x2F;&#x2F; 每一个线程都会读入一个data，定义并分配args.thread个data的内存</span><br><span class="line">    data* buffers &#x3D; (data*)xcalloc(args.threads, sizeof(data));</span><br><span class="line">    pthread_t* threads &#x3D; (pthread_t*)xcalloc(args.threads, sizeof(pthread_t));</span><br><span class="line">	&#x2F;&#x2F; 此处定义了多个线程，并为每个线程动态分配内存</span><br><span class="line">    for(i &#x3D; 0; i &lt; args.threads; ++i)&#123;</span><br><span class="line">		&#x2F;&#x2F; 此处就承应了上面的注释，args.d指针变量本身发生了改动，使得本函数的args.d与out不再指向同一块内存，</span><br><span class="line">        &#x2F;&#x2F; 改为指向buffers指向的某一段内存，因为下面的load_data_in_thread()函数统一了结口，需要输入一个load_args类型参数，</span><br><span class="line">        &#x2F;&#x2F; 实际是想把图片数据读入到buffers[i]中，只能令args.d与buffers[i]指向同一块内存</span><br><span class="line">        args.d &#x3D; buffers + i;</span><br><span class="line">		 &#x2F;&#x2F; 下面这句很有意思，因为有多个线程，所有线程读入的总图片张数为total，需要将total均匀的分到各个线程上，</span><br><span class="line">        &#x2F;&#x2F; 但很可能会遇到total不能整除的args.threads的情况，比如total &#x3D; 61, args.threads &#x3D;8,显然不能做到</span><br><span class="line">        &#x2F;&#x2F; 完全均匀的分配，但又要保证读入图片的总张数一定等于total，用下面的语句刚好在尽量均匀的情况下，</span><br><span class="line">        &#x2F;&#x2F; 保证总和为total，比如61,那么8个线程各自读入的照片张数分别为：7, 8, 7, 8, 8, 7, 8, 8</span><br><span class="line">        args.n &#x3D; (i+1) * total&#x2F;args.threads - i * total&#x2F;args.threads;</span><br><span class="line">		&#x2F;&#x2F; 开启线程，读入数据到args.d中（也就读入到buffers[i]中）</span><br><span class="line">        &#x2F;&#x2F; load_data_in_thread()函数返回所开启的线程，并存储之前已经动态分配内存用来存储所有线程的threads中，</span><br><span class="line">        &#x2F;&#x2F; 方便下面使用pthread_join()函数控制相应线程</span><br><span class="line">        threads[i] &#x3D; load_data_in_thread(args);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i &#x3D; 0; i &lt; args.threads; ++i)&#123;</span><br><span class="line">		&#x2F;&#x2F; 以阻塞的方式等待线程threads[i]结束：阻塞是指阻塞启动该子线程的母线程（此处应为主线程），</span><br><span class="line">        &#x2F;&#x2F; 是母线程处于阻塞状态，一直等待所有子线程执行完（读完所有数据）才会继续执行下面的语句</span><br><span class="line">        &#x2F;&#x2F; 关于多线程的使用，进行过代码测试，测试代码对应：darknet_test_pthread_join.c</span><br><span class="line">        pthread_join(threads[i], 0);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 多个线程读入所有数据之后，分别存储到buffers[0],buffers[1]...中，接着使用concat_datas()函数将buffers中的数据全部合并成一个大数组得到out</span><br><span class="line">    *out &#x3D; concat_datas(buffers, args.threads);</span><br><span class="line">	 &#x2F;&#x2F; 也就只有out的shallow敢置为0了，为什么呢？因为out是此次迭代读入的最终数据，该数据参与训练（用完）之后，当然可以深层释放了，而此前的都是中间变量，</span><br><span class="line">    &#x2F;&#x2F; 还处于读入数据阶段，万不可设置shallow&#x3D;0</span><br><span class="line">    out-&gt;shallow &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; 释放buffers，buffers也是个中间变量，切记shallow设置为1,如果设置为0,那就连out中的数据也没了</span><br><span class="line">    for(i &#x3D; 0; i &lt; args.threads; ++i)&#123;</span><br><span class="line">        buffers[i].shallow &#x3D; 1;</span><br><span class="line">        free_data(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 最终直接释放buffers,threads，注意buffers是一个存储data的一维数组，上面循环中的内存释放，实际是释放每一个data的部分内存</span><br><span class="line">    &#x2F;&#x2F; （这部分内存对data而言是非主要内存，不是存储读入数据的内存块，而是存储指向这些内存块的指针变量，可以释放的）</span><br><span class="line">    free(buffers);</span><br><span class="line">    free(threads);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="load-data-in-thread-分配线程"><a href="#load-data-in-thread-分配线程" class="headerlink" title="load_data_in_thread()分配线程"></a>load_data_in_thread()分配线程</h2><p><code>load_data_in_thread()</code>函数仍然在<code>src/data.c</code>中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">** 创建一个线程，读入相应图片数据（此时args.n不再是一次迭代读入的所有图片的张数，而是经过load_threads()均匀分配给每个线程的图片张数）</span><br><span class="line">** 输入：args    包含该线程要读入图片数据的信息（读入多少张，读入图片最终的宽高，图片路径等等）</span><br><span class="line">** 返回：phtread_t   线程id</span><br><span class="line">** 说明：本函数实际没有做什么，就是深拷贝了args给ptr,然后创建了一个调用load_thread()函数的线程并返回线程id</span><br><span class="line">*&#x2F;</span><br><span class="line">pthread_t load_data_in_thread(load_args args)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">	&#x2F;&#x2F; 同样第一件事深拷贝了args给ptr</span><br><span class="line">    struct load_args* ptr &#x3D; (load_args*)xcalloc(1, sizeof(struct load_args));</span><br><span class="line">    *ptr &#x3D; args;</span><br><span class="line">	&#x2F;&#x2F; 创建一个线程，读入相应数据，绑定load_thread()函数到该线程上，第四个参数是load_thread()的输入参数，第二个参数表示线程属性，设置为0（即NULL）</span><br><span class="line">	&#x2F;&#x2F;当创建线程成功时，函数返回0，若不为0则说明创建线程失败</span><br><span class="line">    if(pthread_create(&amp;thread, 0, load_thread, ptr)) error(&quot;Thread creation failed&quot;); </span><br><span class="line">    return thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="load-data-detection-完成底层的数据加载任务"><a href="#load-data-detection-完成底层的数据加载任务" class="headerlink" title="load_data_detection()完成底层的数据加载任务"></a>load_data_detection()完成底层的数据加载任务</h2><p><code>load_data_detection()</code>函数也定义在<code>src/data.c</code>中，带注释的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">** 可以参考，看一下对图像进行jitter处理的各种效果:</span><br><span class="line">** https:&#x2F;&#x2F;github.com&#x2F;vxy10&#x2F;ImageAugmentation</span><br><span class="line">** 从所有训练图片中，随机读取n张，并对这n张图片进行数据增强，同时矫正增强后的数据标签信息。最终得到的图片的宽高为w,h（原始训练集中的图片尺寸不定），也就是网络能够处理的图片尺寸，</span><br><span class="line">** 数据增强包括：对原始图片进行宽高方向上的插值缩放（两方向上缩放系数不一定相同），下面称之为缩放抖动；随机抠取或者平移图片（位置抖动）；</span><br><span class="line">** 在hsv颜色空间增加噪声（颜色抖动）；左右水平翻转，不含旋转抖动。</span><br><span class="line">** 输入： n         一个线程读入的图片张数（详见函数内部注释）</span><br><span class="line">**       paths     所有训练图片所在路径集合，是一个二维数组，每一行对应一张图片的路径（将在其中随机取n个）</span><br><span class="line">**       m         paths的行数，也即训练图片总数</span><br><span class="line">**       w         网络能够处理的图的宽度（也就是输入图片经过一系列数据增强、变换之后最终输入到网络的图的宽度）</span><br><span class="line">**       h         网络能够处理的图的高度（也就是输入图片经过一系列数据增强、变换之后最终输入到网络的图的高度）</span><br><span class="line">**       c         用来指定训练图片的通道数（默认为3，即RGB图）</span><br><span class="line">**       boxes     每张训练图片最大处理的矩形框数（图片内可能含有更多的物体，即更多的矩形框，那么就在其中随机选择boxes个参与训练，具体执行在fill_truth_detection()函数中）</span><br><span class="line">**       classes   类别总数，本函数并未用到（fill_truth_detection函数其实并没有用这个参数）</span><br><span class="line">**       use_flip  是否使用水平翻转</span><br><span class="line">**       use_mixup 是否使用mixup数据增强</span><br><span class="line">**       jitter    这个参数为缩放抖动系数，就是图片缩放抖动的剧烈程度，越大，允许的抖动范围越大（所谓缩放抖动，就是在宽高上插值缩放图片，宽高两方向上缩放的系数不一定相同）</span><br><span class="line">**       hue       颜色（hsv颜色空间）数据增强参数：色调（取值0度到360度）偏差最大值，实际色调偏差为-hue~hue之间的随机值</span><br><span class="line">**       saturation 颜色（hsv颜色空间）数据增强参数：色彩饱和度（取值范围0~1）缩放最大值，实际为范围内的随机值</span><br><span class="line">**       exposure  颜色（hsv颜色空间）数据增强参数：明度（色彩明亮程度，0~1）缩放最大值，实际为范围内的随机值</span><br><span class="line">**       mini_batch      和目标跟踪有关，这里不关注</span><br><span class="line">**       track           和目标跟踪有关，这里不关注</span><br><span class="line">**       augment_speed   和目标跟踪有关，这里不关注</span><br><span class="line">**       letter_box 是否进行letter_box变换</span><br><span class="line">**       show_imgs</span><br><span class="line">** 返回：data类型数据，包含一个线程读入的所有图片数据（含有n张图片）</span><br><span class="line">** 说明：最后四个参数用于数据增强，主要对原图进行缩放抖动，位置抖动（平移）以及颜色抖动（颜色值增加一定噪声），抖动一定程度上可以理解成对图像增加噪声。</span><br><span class="line">**       通过对原始图像进行抖动，实现数据增强。最后三个参数具体用法参考本函数内调用的random_distort_image()函数</span><br><span class="line">** 说明2：从此函数可以看出，darknet对训练集中图片的尺寸没有要求，可以是任意尺寸的图片，因为经该函数处理（缩放&#x2F;裁剪）之后，</span><br><span class="line">**       不管是什么尺寸的照片，都会统一为网络训练使用的尺寸</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">data load_data_detection(int n, char **paths, int m, int w, int h, int c, int boxes, int classes, int use_flip, int use_blur, int use_mixup, float jitter,</span><br><span class="line">    float hue, float saturation, float exposure, int mini_batch, int track, int augment_speed, int letter_box, int show_imgs)</span><br><span class="line">&#123;</span><br><span class="line">    const int random_index &#x3D; random_gen();</span><br><span class="line">    c &#x3D; c ? c : 3;</span><br><span class="line">    char **random_paths;</span><br><span class="line">    char **mixup_random_paths &#x3D; NULL;</span><br><span class="line">	&#x2F;&#x2F; paths包含所有训练图片的路径，get_random_paths函数从中随机提出n条，即为此次读入的n张图片的路径</span><br><span class="line">    if(track) random_paths &#x3D; get_sequential_paths(paths, n, m, mini_batch, augment_speed);</span><br><span class="line">    else random_paths &#x3D; get_random_paths(paths, n, m);</span><br><span class="line"></span><br><span class="line">    assert(use_mixup &lt; 2);</span><br><span class="line">    int mixup &#x3D; use_mixup ? random_gen() % 2 : 0;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;\n mixup &#x3D; %d \n&quot;, mixup);</span><br><span class="line">	&#x2F;&#x2F; 如果使用mixup策略，需要再随机取出n条数据，即n张图片</span><br><span class="line">    if (mixup) &#123;</span><br><span class="line">        if (track) mixup_random_paths &#x3D; get_sequential_paths(paths, n, m, mini_batch, augment_speed);</span><br><span class="line">        else mixup_random_paths &#x3D; get_random_paths(paths, n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">	&#x2F;&#x2F; 初始化为0,清空内存中之前的旧值</span><br><span class="line">    data d &#x3D; &#123; 0 &#125;;</span><br><span class="line">    d.shallow &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; 一次读入的图片张数：d.X中每行就是一张图片的数据，因此d.X.cols等于h*w*3</span><br><span class="line">    &#x2F;&#x2F; n &#x3D; net.batch * net.subdivisions * ngpus</span><br><span class="line">    &#x2F;&#x2F; 从parse_net_option()函数可知，net.batch &#x3D; net.batch &#x2F; net.subdivision</span><br><span class="line">    &#x2F;&#x2F; net.batch * net.subdivisions就得到了在网络配置文件中设定的batch值，即网络配置文件.cfg中设置的每个batch的图片数量, 然后乘以ngpus，是考虑多个GPU实现数据并行，</span><br><span class="line">    &#x2F;&#x2F; 一次读入多个batch的数据，分配到不同GPU上进行训练。在load_threads()函数中，又将整个的n仅可能均匀的划分到每个线程上，</span><br><span class="line">    &#x2F;&#x2F; 也就是总的读入图片张数为n &#x3D; net.batch * net.subdivisions * ngpus，但这些图片不是一个线程读完的，而是分配到多个线程并行读入，</span><br><span class="line">    &#x2F;&#x2F; 因此本函数中的n实际不是总的n，而是分配到该线程上的n，比如总共要读入128张图片，共开启8个线程读数据，那么本函数中的n为16,而不是总数128</span><br><span class="line">    d.X.rows &#x3D; n;</span><br><span class="line">	&#x2F;&#x2F;d.X为一个matrix类型数据，其中d.X.vals是其具体数据，是指针的指针（即为二维数组），此处先为第一维动态分配内存</span><br><span class="line">    d.X.vals &#x3D; (float**)xcalloc(d.X.rows, sizeof(float*));</span><br><span class="line">    d.X.cols &#x3D; h*w*c;</span><br><span class="line"></span><br><span class="line">    float r1 &#x3D; 0, r2 &#x3D; 0, r3 &#x3D; 0, r4 &#x3D; 0, r_scale;</span><br><span class="line">    float dhue &#x3D; 0, dsat &#x3D; 0, dexp &#x3D; 0, flip &#x3D; 0;</span><br><span class="line">    int augmentation_calculated &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; d.y存储了所有读入照片的标签信息，每条标签包含5条信息：类别，以及矩形框的x,y,w,h</span><br><span class="line">    &#x2F;&#x2F; boxes为一张图片最多能够处理（参与训练）的矩形框的数（如果图片中的矩形框数多于这个数，那么随机挑选boxes个，这个参数仅在parse_region以及parse_detection中出现</span><br><span class="line">    &#x2F;&#x2F; 在其他网络解析函数中并没有出现。同样，d.y是一个matrix，make_matrix会指定y的行数和列数，同时会为其第一维动态分配内存</span><br><span class="line">    d.y &#x3D; make_matrix(n, 5 * boxes);</span><br><span class="line">    int i_mixup &#x3D; 0;</span><br><span class="line">    for (i_mixup &#x3D; 0; i_mixup &lt;&#x3D; mixup; i_mixup++) &#123;</span><br><span class="line">        if (i_mixup) augmentation_calculated &#x3D; 0;</span><br><span class="line">        for (i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">			</span><br><span class="line">            float *truth &#x3D; (float*)xcalloc(5 * boxes, sizeof(float));</span><br><span class="line">            char *filename &#x3D; (i_mixup) ? mixup_random_paths[i] : random_paths[i];</span><br><span class="line">			&#x2F;&#x2F;读入原始的图片</span><br><span class="line">            image orig &#x3D; load_image(filename, 0, 0, c);</span><br><span class="line">			&#x2F;&#x2F; 原始图像长宽</span><br><span class="line">            int oh &#x3D; orig.h;</span><br><span class="line">            int ow &#x3D; orig.w;</span><br><span class="line">			&#x2F;&#x2F; 缩放抖动大小：缩放抖动系数乘以原始图宽高即得像素单位意义上的缩放抖动</span><br><span class="line">            int dw &#x3D; (ow*jitter);</span><br><span class="line">            int dh &#x3D; (oh*jitter);</span><br><span class="line"></span><br><span class="line">            if (!augmentation_calculated || !track)</span><br><span class="line">            &#123;</span><br><span class="line">                augmentation_calculated &#x3D; 1;</span><br><span class="line">                r1 &#x3D; random_float();</span><br><span class="line">                r2 &#x3D; random_float();</span><br><span class="line">                r3 &#x3D; random_float();</span><br><span class="line">                r4 &#x3D; random_float();</span><br><span class="line"></span><br><span class="line">                r_scale &#x3D; random_float();</span><br><span class="line"></span><br><span class="line">                dhue &#x3D; rand_uniform_strong(-hue, hue);</span><br><span class="line">                dsat &#x3D; rand_scale(saturation);</span><br><span class="line">                dexp &#x3D; rand_scale(exposure);</span><br><span class="line"></span><br><span class="line">                flip &#x3D; use_flip ? random_gen() % 2 : 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int pleft &#x3D; rand_precalc_random(-dw, dw, r1);</span><br><span class="line">            int pright &#x3D; rand_precalc_random(-dw, dw, r2);</span><br><span class="line">            int ptop &#x3D; rand_precalc_random(-dh, dh, r3);</span><br><span class="line">            int pbot &#x3D; rand_precalc_random(-dh, dh, r4);</span><br><span class="line">			&#x2F;&#x2F; 这个系数没用到</span><br><span class="line">            float scale &#x3D; rand_precalc_random(.25, 2, r_scale); &#x2F;&#x2F; unused currently</span><br><span class="line"></span><br><span class="line">            if (letter_box)</span><br><span class="line">            &#123;</span><br><span class="line">                float img_ar &#x3D; (float)ow &#x2F; (float)oh; &#x2F;&#x2F;原始图像宽高比</span><br><span class="line">                float net_ar &#x3D; (float)w &#x2F; (float)h; &#x2F;&#x2F;输入到网络要求的图像宽高比</span><br><span class="line">                float result_ar &#x3D; img_ar &#x2F; net_ar; &#x2F;&#x2F;两者求比值来判断如何进行letter_box缩放</span><br><span class="line">                &#x2F;&#x2F;printf(&quot; ow &#x3D; %d, oh &#x3D; %d, w &#x3D; %d, h &#x3D; %d, img_ar &#x3D; %f, net_ar &#x3D; %f, result_ar &#x3D; %f \n&quot;, ow, oh, w, h, img_ar, net_ar, result_ar);</span><br><span class="line">                if (result_ar &gt; 1)  &#x2F;&#x2F; sheight - should be increased</span><br><span class="line">                &#123;</span><br><span class="line">                    float oh_tmp &#x3D; ow &#x2F; net_ar;</span><br><span class="line">                    float delta_h &#x3D; (oh_tmp - oh) &#x2F; 2;</span><br><span class="line">                    ptop &#x3D; ptop - delta_h;</span><br><span class="line">                    pbot &#x3D; pbot - delta_h;</span><br><span class="line">                    &#x2F;&#x2F;printf(&quot; result_ar &#x3D; %f, oh_tmp &#x3D; %f, delta_h &#x3D; %d, ptop &#x3D; %f, pbot &#x3D; %f \n&quot;, result_ar, oh_tmp, delta_h, ptop, pbot);</span><br><span class="line">                &#125;</span><br><span class="line">                else  &#x2F;&#x2F; swidth - should be increased</span><br><span class="line">                &#123;</span><br><span class="line">                    float ow_tmp &#x3D; oh * net_ar;</span><br><span class="line">                    float delta_w &#x3D; (ow_tmp - ow) &#x2F; 2;</span><br><span class="line">                    pleft &#x3D; pleft - delta_w;</span><br><span class="line">                    pright &#x3D; pright - delta_w;</span><br><span class="line">                    &#x2F;&#x2F;printf(&quot; result_ar &#x3D; %f, ow_tmp &#x3D; %f, delta_w &#x3D; %d, pleft &#x3D; %f, pright &#x3D; %f \n&quot;, result_ar, ow_tmp, delta_w, pleft, pright);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F; 以下步骤就是执行了letter_box变换</span><br><span class="line">            int swidth &#x3D; ow - pleft - pright;</span><br><span class="line">            int sheight &#x3D; oh - ptop - pbot;</span><br><span class="line"></span><br><span class="line">            float sx &#x3D; (float)swidth &#x2F; ow;</span><br><span class="line">            float sy &#x3D; (float)sheight &#x2F; oh;</span><br><span class="line"></span><br><span class="line">            image cropped &#x3D; crop_image(orig, pleft, ptop, swidth, sheight);</span><br><span class="line"></span><br><span class="line">            float dx &#x3D; ((float)pleft &#x2F; ow) &#x2F; sx;</span><br><span class="line">            float dy &#x3D; ((float)ptop &#x2F; oh) &#x2F; sy;</span><br><span class="line">			&#x2F;&#x2F; resize到指定大小</span><br><span class="line">            image sized &#x3D; resize_image(cropped, w, h);</span><br><span class="line">            &#x2F;&#x2F; 翻转</span><br><span class="line">			if (flip) flip_image(sized);</span><br><span class="line">			&#x2F;&#x2F;随机对图像jitter（在hsv三个通道上添加扰动），实现数据增强</span><br><span class="line">            distort_image(sized, dhue, dsat, dexp);</span><br><span class="line">            &#x2F;&#x2F;random_distort_image(sized, hue, saturation, exposure);</span><br><span class="line">			&#x2F;&#x2F; truth包含所有图像的标签信息（包括真实类别与位置</span><br><span class="line">            &#x2F;&#x2F; 因为对原始图片进行了数据增强，其中的平移抖动势必会改动每个物体的矩形框标签信息（主要是矩形框的像素坐标信息），需要根据具体的数据增强方式进行相应矫正</span><br><span class="line">            &#x2F;&#x2F; 后面的参数就是用于数据增强后的矩形框信息矫正</span><br><span class="line">            fill_truth_detection(filename, boxes, truth, classes, flip, dx, dy, 1. &#x2F; sx, 1. &#x2F; sy, w, h);</span><br><span class="line"></span><br><span class="line">            if (i_mixup) &#123;</span><br><span class="line">                image old_img &#x3D; sized;</span><br><span class="line">                old_img.data &#x3D; d.X.vals[i];</span><br><span class="line">                &#x2F;&#x2F;show_image(sized, &quot;new&quot;);</span><br><span class="line">                &#x2F;&#x2F;show_image(old_img, &quot;old&quot;);</span><br><span class="line">                &#x2F;&#x2F;wait_until_press_key_cv();</span><br><span class="line">				&#x2F;&#x2F; 做mixup，混合系数为0.5</span><br><span class="line">                blend_images(sized, 0.5, old_img, 0.5);</span><br><span class="line">				&#x2F;&#x2F; 标签也要对应改变</span><br><span class="line">                blend_truth(truth, boxes, d.y.vals[i]);</span><br><span class="line">                free_image(old_img);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            d.X.vals[i] &#x3D; sized.data;</span><br><span class="line">            memcpy(d.y.vals[i], truth, 5 * boxes * sizeof(float));</span><br><span class="line"></span><br><span class="line">            if (show_imgs)&#x2F;&#x2F; &amp;&amp; i_mixup)</span><br><span class="line">            &#123;</span><br><span class="line">                char buff[1000];</span><br><span class="line">                sprintf(buff, &quot;aug_%d_%d_%s_%d&quot;, random_index, i, basecfg(filename), random_gen());</span><br><span class="line"></span><br><span class="line">                int t;</span><br><span class="line">                for (t &#x3D; 0; t &lt; boxes; ++t) &#123;</span><br><span class="line">                    box b &#x3D; float_to_box_stride(d.y.vals[i] + t*(4 + 1), 1);</span><br><span class="line">                    if (!b.x) break;</span><br><span class="line">                    int left &#x3D; (b.x - b.w &#x2F; 2.)*sized.w;</span><br><span class="line">                    int right &#x3D; (b.x + b.w &#x2F; 2.)*sized.w;</span><br><span class="line">                    int top &#x3D; (b.y - b.h &#x2F; 2.)*sized.h;</span><br><span class="line">                    int bot &#x3D; (b.y + b.h &#x2F; 2.)*sized.h;</span><br><span class="line">                    draw_box_width(sized, left, top, right, bot, 1, 150, 100, 50); &#x2F;&#x2F; 3 channels RGB</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                save_image(sized, buff);</span><br><span class="line">                if (show_imgs &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    show_image(sized, buff);</span><br><span class="line">                    wait_until_press_key_cv();</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;\nYou use flag -show_imgs, so will be saved aug_...jpg images. Press Enter: \n&quot;);</span><br><span class="line">                &#x2F;&#x2F;getchar();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            free_image(orig);</span><br><span class="line">            free_image(cropped);</span><br><span class="line">            free(truth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(random_paths);</span><br><span class="line">    if (mixup_random_paths) free(mixup_random_paths);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line">#endif    &#x2F;&#x2F; OPENCV</span><br></pre></td></tr></table></figure>
<h2 id="load-data-args-使用方法"><a href="#load-data-args-使用方法" class="headerlink" title="load_data(args)使用方法"></a>load_data(args)使用方法</h2><p>在<code>src/detector.c</code>中的的<code>train_detector()</code>函数共有<code>3</code>次调用<code>load_data(args)</code>，第一次调用是为训练阶段做好数据准备工作，充分利用这段时间来加载数据。第二次调用是在<code>resize</code>操作中，可以看到这里只有<code>random</code>和<code>count</code>同时满足条件的情况下会做<code>resize</code>操作，也就是说<code>resize</code>加载的数据是未进行<code>resize</code>过的，因此，需要调整<code>args</code>中的图像宽高之后再重新调用<code>load_data(args)</code>加载数据。反之，不做任何处理，之前加载的数据仍然可用。第三次调用就是在数据加载完成后，将加载好的数据保存起来<code>train=buffer</code>; 然后开始下一次的加载工作。这一次的数据就会进行这一次的训练操作(调用<code>train_network</code>函数)。</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
	<div>

	  

		<div>

    

        <div >-------------本文结束感谢您的阅读-------------</div>

    

</div>

	  

	</div>
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag"><i class="fa fa-tag"></i> 目标检测</a>
              <a href="/tags/YOLOv3/" rel="tag"><i class="fa fa-tag"></i> YOLOv3</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/21/AlexeyAB-DarkNet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/" rel="prev" title="AlexeyAB DarkNet数据结构解析">
      <i class="fa fa-chevron-left"></i> AlexeyAB DarkNet数据结构解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/22/AlexeyAB-DarkNet%E7%BD%91%E7%BB%9C%E7%9A%84%E5%89%8D%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Alayer%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/" rel="next" title="AlexeyAB DarkNet网络的前向和反向传播介绍以及layer的详细解析">
      AlexeyAB DarkNet网络的前向和反向传播介绍以及layer的详细解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>



<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text"> 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载训练数据"><span class="nav-text">加载训练数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load-threads-完成线程分配和数据拼接"><span class="nav-text">load_threads()完成线程分配和数据拼接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load-data-in-thread-分配线程"><span class="nav-text">load_data_in_thread()分配线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load-data-detection-完成底层的数据加载任务"><span class="nav-text">load_data_detection()完成底层的数据加载任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load-data-args-使用方法"><span class="nav-text">load_data(args)使用方法</span></a></li></ol></div>
      </div>
      <!--/noindex-->
	  
     
	  
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qiyuan-Z"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Qiyuan-Z</p>
  <div class="site-description" itemprop="description">偉大な魂は目的を持ち、そうでないものは願望を持つ</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Qiyuan-Z" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qiyuan-Z" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengqiyuan@stu.jiangnan.edu.cn" title="E-Mail → mailto:zhengqiyuan@stu.jiangnan.edu.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://project-inkstone.github.io/project-inkstone/?tdsourcetag=s_pctim_aiomsg" title="https:&#x2F;&#x2F;project-inkstone.github.io&#x2F;project-inkstone&#x2F;?tdsourcetag&#x3D;s_pctim_aiomsg" rel="noopener" target="_blank">project-inkstone</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.jngwl.top/" title="https:&#x2F;&#x2F;www.jngwl.top" rel="noopener" target="_blank">清风与归</a>
        </li>
    </ul>
  </div>

      </div>
	  
      <div id="music163player">
		   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29784463&auto=1&height=66"></iframe>
		   </iframe>
	  </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiyuan-Z</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">577k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:45</span>
</div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span> 
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("12/01/2019 13:14:21");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
	<script type="text/javascript">
    		var gitalk = new Gitalk({
		        clientID: '2d10cfb27783db577e70',
		        clientSecret: '154292876bb14966f6ae57304b67859617b08c94',
		        id: md5(location.pathname),
		        repo: 'gitalk',
		        owner: 'Qiyuan-Z',
		        admin: 'Qiyuan-Z',
			distractionFreeMode: '',

		    });
	    gitalk.render('gitalk-container');
	</script>



  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
	<script type="text/javascript">
    		var gitalk = new Gitalk({
		        clientID: '2d10cfb27783db577e70',
		        clientSecret: '154292876bb14966f6ae57304b67859617b08c94',
		        id: md5(location.pathname),
		        repo: 'gitalk',
		        owner: 'Qiyuan-Z',
		        admin: 'Qiyuan-Z',
			distractionFreeMode: '',

		    });
	    gitalk.render('gitalk-container');
	</script>


  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
</body>
</html>

