<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AlexeyAB DarkNet加载数据进行训练 | Yuan</title><meta name="keywords" content="目标检测,YOLOv3"><meta name="author" content="Qiyuan-Z"><meta name="copyright" content="Qiyuan-Z"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言之前讲了DarkNet的底层数据结构，并且将网络配置文件进行了解析存放到了一个network结构体中，那么我们就要来看一下Darknet是如何加载数据进行训练的。 加载训练数据DarkNet的数据加载函数load_data()在src&#x2F;data.c中实现（src&#x2F;detector.c函数中的train_detector直接调用这个函数加载数据）。load_data()函数调用流程如下：load"><meta property="og:type" content="article"><meta property="og:title" content="AlexeyAB DarkNet加载数据进行训练"><meta property="og:url" content="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/index.html"><meta property="og:site_name" content="Yuan"><meta property="og:description" content="前言之前讲了DarkNet的底层数据结构，并且将网络配置文件进行了解析存放到了一个network结构体中，那么我们就要来看一下Darknet是如何加载数据进行训练的。 加载训练数据DarkNet的数据加载函数load_data()在src&#x2F;data.c中实现（src&#x2F;detector.c函数中的train_detector直接调用这个函数加载数据）。load_data()函数调用流程如下：load"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><meta property="article:published_time" content="2020-02-21T03:29:43.809Z"><meta property="article:modified_time" content="2022-01-02T11:22:13.625Z"><meta property="article:author" content="Qiyuan-Z"><meta property="article:tag" content="目标检测"><meta property="article:tag" content="YOLOv3"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:200,languages:{author:"作者: Qiyuan-Z",link:"链接: ",source:"来源: Yuan",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-02 19:22:13"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuan</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i> <span>番剧</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">AlexeyAB DarkNet加载数据进行训练</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-21T03:29:43.809Z" title="发表于 2020-02-21 11:29:43">2020-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-02T11:22:13.625Z" title="更新于 2022-01-02 19:22:13">2022-01-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前讲了DarkNet的底层数据结构，并且将网络配置文件进行了解析存放到了一个<code>network</code>结构体中，那么我们就要来看一下Darknet是如何加载数据进行训练的。</p><h2 id="加载训练数据"><a href="#加载训练数据" class="headerlink" title="加载训练数据"></a>加载训练数据</h2><p>DarkNet的数据加载函数<code>load_data()</code>在<code>src/data.c</code>中实现（<code>src/detector.c</code>函数中的<code>train_detector</code>直接调用这个函数加载数据）。<code>load_data()</code>函数调用流程如下：<code>load_data(args)-&gt;load_threads()-&gt;load_data_in_threads()-&gt;load_thread()-&gt;load_data_detection()</code>，前四个函数都是在对线程的调用进行封装。最底层的数据加载任务由<code>load_data_detection()</code>函数完成。所有的数据(图片数据和标注信息数据)加载完成之后再拼接到一个大的数组中。在DarkNet中，图片的存储形式是一个行向量，向量长度为<code>h*w*3</code>。同时图片被归一化到<code>[0, 1]</code>之间。</p><h2 id="load-threads-完成线程分配和数据拼接"><a href="#load-threads-完成线程分配和数据拼接" class="headerlink" title="load_threads()完成线程分配和数据拼接"></a>load_threads()完成线程分配和数据拼接</h2><p><code>load_threads</code>在<code>src/data.c</code>中实现，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy from https://github.com/hgpvision/darknet/blob/master/src/data.c#L355</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 开辟多个线程读入图片数据，读入数据存储至ptr.d中（主要调用load_in_thread()函数完成）</span></span><br><span class="line"><span class="comment">** 输入：ptr    包含所有线程要读入图片数据的信息（读入多少张，开几个线程读入，读入图片最终的宽高，图片路径等等）</span></span><br><span class="line"><span class="comment">** 返回：void*  万能指针（实际上不需要返回什么）</span></span><br><span class="line"><span class="comment">** 说明：1) load_threads()是一个指针函数，只是一个返回变量为void*的普通函数，不是函数指针</span></span><br><span class="line"><span class="comment">**       2) 输入ptr是一个void*指针（万能指针），使用时需要强转为具体类型的指针</span></span><br><span class="line"><span class="comment">**       3) 函数中涉及四个用来存储读入数据的变量：ptr, args, out, buffers，除args外都是data*类型，所有这些变量的</span></span><br><span class="line"><span class="comment">**          指针变量其实都指向同一块内存（当然函数中间有些动态变化），因此读入的数据都是互通的。</span></span><br><span class="line"><span class="comment">** 流程：本函数首先会获取要读入图片的张数、要开启线程的个数，而后计算每个线程应该读入的图片张数（尽可能的均匀分配），</span></span><br><span class="line"><span class="comment">**       并创建所有的线程，并行读入数据，最后合并每个线程读入的数据至一个大data中，这个data的指针变量与ptr的指针变量</span></span><br><span class="line"><span class="comment">**       指向的是统一块内存，因此也就最终将数据读入到ptr.d中（所以其实没有返回值）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">load_threads</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//srand(time(0));</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 先使用(load_args*)强转void*指针，而后取ptr所指内容赋值给args</span></span><br><span class="line">    <span class="comment">// 虽然args不是指针，args是深拷贝了ptr中的内容，但是要知道ptr（也就是load_args数据类型），有很多的</span></span><br><span class="line">    <span class="comment">// 指针变量，args深拷贝将拷贝这些指针变量到args中（这些指针变量本身对ptr来说就是内容，</span></span><br><span class="line">    <span class="comment">// 而args所指的值是args的内容，不是ptr的，不要混为一谈），因此，args与ptr将会共享所有指针变量所指的内容</span></span><br><span class="line">    load_args args = *(load_args *)ptr;</span><br><span class="line">    <span class="keyword">if</span> (args.threads == <span class="number">0</span>) args.threads = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 另指针变量out=args.d，使得out与args.d指向统一块内存，之后，args.d所指的内存块会变（反正也没什么用了，变就变吧），</span></span><br><span class="line">    <span class="comment">// 但out不会变，这样可以保证out与最原始的ptr指向同一块存储读入图片数据的内存块，因此最终将图片读到out中，</span></span><br><span class="line">    <span class="comment">// 实际就是读到了最原始的ptr中，比如train_detector()函数中定义的args.d中</span></span><br><span class="line">    data *out = args.d;</span><br><span class="line">	<span class="comment">// 读入图片的总张数= batch * subdivision * ngpus，可参见train_detector()函数中的赋值</span></span><br><span class="line">    <span class="keyword">int</span> total = args.n;</span><br><span class="line">	<span class="comment">// 释放ptr：ptr是传入的指针变量，传入的指针变量本身也是按值传递的，即传入函数之后，指针变量得到复制，函数内的形参ptr</span></span><br><span class="line">    <span class="comment">// 获取外部实参的值之后，二者本身没有关系，但是由于是指针变量，二者之间又存在一丝关系，那就是函数内形参与函数外实参指向</span></span><br><span class="line">    <span class="comment">// 同一块内存。又由于函数外实参内存是动态分配的，因此函数内的形参可以使用free()函数进行内存释放，但一般不推荐这么做，因为函数内释放内存，</span></span><br><span class="line">    <span class="comment">// 会影响函数外实参的使用，可能使之成为野指针，那为什么这里可以用free()释放ptr呢，不会出现问题吗？</span></span><br><span class="line">    <span class="comment">// 其一，因为ptr是一个结构体，是一个包含众多的指针变量的结构体，如data* d等（当然还有其他非指针变量如int h等），</span></span><br><span class="line">    <span class="comment">// 直接free(ptr)将会导致函数外实参无法再访问非指针变量int h等（实际经过测试，在gcc编译器下，能访问但是值被重新初始化为0），</span></span><br><span class="line">    <span class="comment">// 因为函数内形参和函数外实参共享一块堆内存，而这些非指针变量都是存在这块堆内存上的，内存一释放，就无法访问了；</span></span><br><span class="line">    <span class="comment">// 但是对于指针变量，free(ptr)将无作为（这个结论也是经过测试的，也是用的gcc编译器），不会释放或者擦写掉ptr指针变量本身的值，</span></span><br><span class="line">    <span class="comment">// 当然也不会影响函数外实参，更不会牵扯到这些指针变量所指的内存块，总的来说，</span></span><br><span class="line">    <span class="comment">// free(ptr)将使得ptr不能再访问指针变量（如int h等，实际经过测试，在gcc编译器下，能访问但是值被重新初始化为0），</span></span><br><span class="line">    <span class="comment">// 但其指针变量本身没有受影响，依旧可以访问；对于函数外实参，同样不能访问非指针变量，而指针变量不受影响，依旧可以访问。</span></span><br><span class="line">    <span class="comment">// 其二，darknet数据读取的实现一层套一层（似乎有点罗嗦，总感觉代码可以不用这么写的:)），具体调用过程如下：</span></span><br><span class="line">    <span class="comment">// load_data(load_args args)-&gt;load_threads(load_args* ptr)-&gt;load_data_in_thread(load_args args)-&gt;load_thread(load_args* ptr)，</span></span><br><span class="line">    <span class="comment">// 就在load_data()中，重新定义了ptr，并为之动态分配了内存，且深拷贝了传给load_data()函数的值args，也就是说在此之后load_data()函数中的args除了其中的指针变量指着同一块堆内存之外，</span></span><br><span class="line">    <span class="comment">// 二者的非指针变量再无瓜葛，不管之后经过多少个函数，对ptr的非指针变量做了什么改动，比如这里直接free(ptr)，使得非指针变量值为0,都不会影响load_data()中的args的非指针变量，也就不会影响更为顶层函数中定义的args的非指针变量的值，</span></span><br><span class="line">    <span class="comment">// 比如train_detector()函数中的args，train_detector()对args非指针变量赋的值都不会受影响，保持不变。综其两点，此处直接free(ptr)是安全的。</span></span><br><span class="line">    <span class="comment">// 说明：free(ptr)函数，确定会做的事是使得内存块可以重新分配，且不会影响指针变量ptr本身的值，也就是ptr还是指向那块地址， 虽然可以使用，但很危险，因为这块内存实际是无效的，</span></span><br><span class="line">    <span class="comment">//      系统已经认为这块内存是可分配的，会毫不考虑的将这块内存分给其他变量，这样，其值随时都可能会被其他变量改变，这种情况下的ptr指针就是所谓的野指针（所以经常可以看到free之后，置原指针为NULL）。</span></span><br><span class="line">    <span class="comment">//      而至于free(ptr)还不会做其他事情，比如会不会重新初始化这块内存为0（擦写掉），以及怎么擦写，这些操作，是不确定的，可能跟具体的编译器有关（个人猜测），</span></span><br><span class="line">    <span class="comment">//      经过测试，对于gcc编译器，free(ptr)之后，ptr中的非指针变量的地址不变，但其值全部擦写为0；ptr中的指针变量，丝毫不受影响，指针变量本身没有被擦写，</span></span><br><span class="line">    <span class="comment">//      存储的地址还是指向先前分配的内存块，所以ptr能够正常访问其指针变量所指的值。测试代码为darknet_test_struct_memory_free.c。</span></span><br><span class="line">    <span class="comment">//      不知道这段测试代码在VS中执行会怎样，还没经过测试，也不知道换用其他编译器（darknet的Makefile文件中，指定了编译器为gcc），darknet的编译会不会有什么问题？？</span></span><br><span class="line">    <span class="comment">//      关于free()，可以看看：http://blog.sina.com.cn/s/blog_615ec1630102uwle.html，文章最后有一个很有意思的比喻，但意思好像就和我这里说的有点不一样了（到底是不是编译器搞得鬼呢？？）。</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">	<span class="comment">// 每一个线程都会读入一个data，定义并分配args.thread个data的内存</span></span><br><span class="line">    data* buffers = (data*)<span class="built_in">xcalloc</span>(args.threads, <span class="built_in"><span class="keyword">sizeof</span></span>(data));</span><br><span class="line">    <span class="keyword">pthread_t</span>* threads = (<span class="keyword">pthread_t</span>*)<span class="built_in">xcalloc</span>(args.threads, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">	<span class="comment">// 此处定义了多个线程，并为每个线程动态分配内存</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; args.threads; ++i)&#123;</span><br><span class="line">		<span class="comment">// 此处就承应了上面的注释，args.d指针变量本身发生了改动，使得本函数的args.d与out不再指向同一块内存，</span></span><br><span class="line">        <span class="comment">// 改为指向buffers指向的某一段内存，因为下面的load_data_in_thread()函数统一了结口，需要输入一个load_args类型参数，</span></span><br><span class="line">        <span class="comment">// 实际是想把图片数据读入到buffers[i]中，只能令args.d与buffers[i]指向同一块内存</span></span><br><span class="line">        args.d = buffers + i;</span><br><span class="line">		 <span class="comment">// 下面这句很有意思，因为有多个线程，所有线程读入的总图片张数为total，需要将total均匀的分到各个线程上，</span></span><br><span class="line">        <span class="comment">// 但很可能会遇到total不能整除的args.threads的情况，比如total = 61, args.threads =8,显然不能做到</span></span><br><span class="line">        <span class="comment">// 完全均匀的分配，但又要保证读入图片的总张数一定等于total，用下面的语句刚好在尽量均匀的情况下，</span></span><br><span class="line">        <span class="comment">// 保证总和为total，比如61,那么8个线程各自读入的照片张数分别为：7, 8, 7, 8, 8, 7, 8, 8</span></span><br><span class="line">        args.n = (i+<span class="number">1</span>) * total/args.threads - i * total/args.threads;</span><br><span class="line">		<span class="comment">// 开启线程，读入数据到args.d中（也就读入到buffers[i]中）</span></span><br><span class="line">        <span class="comment">// load_data_in_thread()函数返回所开启的线程，并存储之前已经动态分配内存用来存储所有线程的threads中，</span></span><br><span class="line">        <span class="comment">// 方便下面使用pthread_join()函数控制相应线程</span></span><br><span class="line">        threads[i] = <span class="built_in">load_data_in_thread</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; args.threads; ++i)&#123;</span><br><span class="line">		<span class="comment">// 以阻塞的方式等待线程threads[i]结束：阻塞是指阻塞启动该子线程的母线程（此处应为主线程），</span></span><br><span class="line">        <span class="comment">// 是母线程处于阻塞状态，一直等待所有子线程执行完（读完所有数据）才会继续执行下面的语句</span></span><br><span class="line">        <span class="comment">// 关于多线程的使用，进行过代码测试，测试代码对应：darknet_test_pthread_join.c</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 多个线程读入所有数据之后，分别存储到buffers[0],buffers[1]...中，接着使用concat_datas()函数将buffers中的数据全部合并成一个大数组得到out</span></span><br><span class="line">    *out = <span class="built_in">concat_datas</span>(buffers, args.threads);</span><br><span class="line">	 <span class="comment">// 也就只有out的shallow敢置为0了，为什么呢？因为out是此次迭代读入的最终数据，该数据参与训练（用完）之后，当然可以深层释放了，而此前的都是中间变量，</span></span><br><span class="line">    <span class="comment">// 还处于读入数据阶段，万不可设置shallow=0</span></span><br><span class="line">    out-&gt;shallow = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 释放buffers，buffers也是个中间变量，切记shallow设置为1,如果设置为0,那就连out中的数据也没了</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; args.threads; ++i)&#123;</span><br><span class="line">        buffers[i].shallow = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">free_data</span>(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 最终直接释放buffers,threads，注意buffers是一个存储data的一维数组，上面循环中的内存释放，实际是释放每一个data的部分内存</span></span><br><span class="line">    <span class="comment">// （这部分内存对data而言是非主要内存，不是存储读入数据的内存块，而是存储指向这些内存块的指针变量，可以释放的）</span></span><br><span class="line">    <span class="built_in">free</span>(buffers);</span><br><span class="line">    <span class="built_in">free</span>(threads);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="load-data-in-thread-分配线程"><a href="#load-data-in-thread-分配线程" class="headerlink" title="load_data_in_thread()分配线程"></a>load_data_in_thread()分配线程</h2><p><code>load_data_in_thread()</code>函数仍然在<code>src/data.c</code>中，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 创建一个线程，读入相应图片数据（此时args.n不再是一次迭代读入的所有图片的张数，而是经过load_threads()均匀分配给每个线程的图片张数）</span></span><br><span class="line"><span class="comment">** 输入：args    包含该线程要读入图片数据的信息（读入多少张，读入图片最终的宽高，图片路径等等）</span></span><br><span class="line"><span class="comment">** 返回：phtread_t   线程id</span></span><br><span class="line"><span class="comment">** 说明：本函数实际没有做什么，就是深拷贝了args给ptr,然后创建了一个调用load_thread()函数的线程并返回线程id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">load_data_in_thread</span><span class="params">(load_args args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="comment">// 同样第一件事深拷贝了args给ptr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_args</span>* <span class="title">ptr</span> =</span> (load_args*)<span class="built_in">xcalloc</span>(<span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct load_args));</span><br><span class="line">    *ptr = args;</span><br><span class="line">	<span class="comment">// 创建一个线程，读入相应数据，绑定load_thread()函数到该线程上，第四个参数是load_thread()的输入参数，第二个参数表示线程属性，设置为0（即NULL）</span></span><br><span class="line">	<span class="comment">//当创建线程成功时，函数返回0，若不为0则说明创建线程失败</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thread, <span class="number">0</span>, load_thread, ptr)) <span class="built_in">error</span>(<span class="string">&quot;Thread creation failed&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="load-data-detection-完成底层的数据加载任务"><a href="#load-data-detection-完成底层的数据加载任务" class="headerlink" title="load_data_detection()完成底层的数据加载任务"></a>load_data_detection()完成底层的数据加载任务</h2><p><code>load_data_detection()</code>函数也定义在<code>src/data.c</code>中，带注释的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 可以参考，看一下对图像进行jitter处理的各种效果:</span></span><br><span class="line"><span class="comment">** https://github.com/vxy10/ImageAugmentation</span></span><br><span class="line"><span class="comment">** 从所有训练图片中，随机读取n张，并对这n张图片进行数据增强，同时矫正增强后的数据标签信息。最终得到的图片的宽高为w,h（原始训练集中的图片尺寸不定），也就是网络能够处理的图片尺寸，</span></span><br><span class="line"><span class="comment">** 数据增强包括：对原始图片进行宽高方向上的插值缩放（两方向上缩放系数不一定相同），下面称之为缩放抖动；随机抠取或者平移图片（位置抖动）；</span></span><br><span class="line"><span class="comment">** 在hsv颜色空间增加噪声（颜色抖动）；左右水平翻转，不含旋转抖动。</span></span><br><span class="line"><span class="comment">** 输入： n         一个线程读入的图片张数（详见函数内部注释）</span></span><br><span class="line"><span class="comment">**       paths     所有训练图片所在路径集合，是一个二维数组，每一行对应一张图片的路径（将在其中随机取n个）</span></span><br><span class="line"><span class="comment">**       m         paths的行数，也即训练图片总数</span></span><br><span class="line"><span class="comment">**       w         网络能够处理的图的宽度（也就是输入图片经过一系列数据增强、变换之后最终输入到网络的图的宽度）</span></span><br><span class="line"><span class="comment">**       h         网络能够处理的图的高度（也就是输入图片经过一系列数据增强、变换之后最终输入到网络的图的高度）</span></span><br><span class="line"><span class="comment">**       c         用来指定训练图片的通道数（默认为3，即RGB图）</span></span><br><span class="line"><span class="comment">**       boxes     每张训练图片最大处理的矩形框数（图片内可能含有更多的物体，即更多的矩形框，那么就在其中随机选择boxes个参与训练，具体执行在fill_truth_detection()函数中）</span></span><br><span class="line"><span class="comment">**       classes   类别总数，本函数并未用到（fill_truth_detection函数其实并没有用这个参数）</span></span><br><span class="line"><span class="comment">**       use_flip  是否使用水平翻转</span></span><br><span class="line"><span class="comment">**       use_mixup 是否使用mixup数据增强</span></span><br><span class="line"><span class="comment">**       jitter    这个参数为缩放抖动系数，就是图片缩放抖动的剧烈程度，越大，允许的抖动范围越大（所谓缩放抖动，就是在宽高上插值缩放图片，宽高两方向上缩放的系数不一定相同）</span></span><br><span class="line"><span class="comment">**       hue       颜色（hsv颜色空间）数据增强参数：色调（取值0度到360度）偏差最大值，实际色调偏差为-hue~hue之间的随机值</span></span><br><span class="line"><span class="comment">**       saturation 颜色（hsv颜色空间）数据增强参数：色彩饱和度（取值范围0~1）缩放最大值，实际为范围内的随机值</span></span><br><span class="line"><span class="comment">**       exposure  颜色（hsv颜色空间）数据增强参数：明度（色彩明亮程度，0~1）缩放最大值，实际为范围内的随机值</span></span><br><span class="line"><span class="comment">**       mini_batch      和目标跟踪有关，这里不关注</span></span><br><span class="line"><span class="comment">**       track           和目标跟踪有关，这里不关注</span></span><br><span class="line"><span class="comment">**       augment_speed   和目标跟踪有关，这里不关注</span></span><br><span class="line"><span class="comment">**       letter_box 是否进行letter_box变换</span></span><br><span class="line"><span class="comment">**       show_imgs</span></span><br><span class="line"><span class="comment">** 返回：data类型数据，包含一个线程读入的所有图片数据（含有n张图片）</span></span><br><span class="line"><span class="comment">** 说明：最后四个参数用于数据增强，主要对原图进行缩放抖动，位置抖动（平移）以及颜色抖动（颜色值增加一定噪声），抖动一定程度上可以理解成对图像增加噪声。</span></span><br><span class="line"><span class="comment">**       通过对原始图像进行抖动，实现数据增强。最后三个参数具体用法参考本函数内调用的random_distort_image()函数</span></span><br><span class="line"><span class="comment">** 说明2：从此函数可以看出，darknet对训练集中图片的尺寸没有要求，可以是任意尺寸的图片，因为经该函数处理（缩放/裁剪）之后，</span></span><br><span class="line"><span class="comment">**       不管是什么尺寸的照片，都会统一为网络训练使用的尺寸</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">data <span class="title">load_data_detection</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> **paths, <span class="keyword">int</span> m, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> c, <span class="keyword">int</span> boxes, <span class="keyword">int</span> classes, <span class="keyword">int</span> use_flip, <span class="keyword">int</span> use_blur, <span class="keyword">int</span> use_mixup, <span class="keyword">float</span> jitter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span> hue, <span class="keyword">float</span> saturation, <span class="keyword">float</span> exposure, <span class="keyword">int</span> mini_batch, <span class="keyword">int</span> track, <span class="keyword">int</span> augment_speed, <span class="keyword">int</span> letter_box, <span class="keyword">int</span> show_imgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> random_index = <span class="built_in">random_gen</span>();</span><br><span class="line">    c = c ? c : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> **random_paths;</span><br><span class="line">    <span class="keyword">char</span> **mixup_random_paths = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// paths包含所有训练图片的路径，get_random_paths函数从中随机提出n条，即为此次读入的n张图片的路径</span></span><br><span class="line">    <span class="keyword">if</span>(track) random_paths = <span class="built_in">get_sequential_paths</span>(paths, n, m, mini_batch, augment_speed);</span><br><span class="line">    <span class="keyword">else</span> random_paths = <span class="built_in">get_random_paths</span>(paths, n, m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(use_mixup &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> mixup = use_mixup ? <span class="built_in">random_gen</span>() % <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;\n mixup = %d \n&quot;, mixup);</span></span><br><span class="line">	<span class="comment">// 如果使用mixup策略，需要再随机取出n条数据，即n张图片</span></span><br><span class="line">    <span class="keyword">if</span> (mixup) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track) mixup_random_paths = <span class="built_in">get_sequential_paths</span>(paths, n, m, mini_batch, augment_speed);</span><br><span class="line">        <span class="keyword">else</span> mixup_random_paths = <span class="built_in">get_random_paths</span>(paths, n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 初始化为0,清空内存中之前的旧值</span></span><br><span class="line">    data d = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    d.shallow = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一次读入的图片张数：d.X中每行就是一张图片的数据，因此d.X.cols等于h*w*3</span></span><br><span class="line">    <span class="comment">// n = net.batch * net.subdivisions * ngpus</span></span><br><span class="line">    <span class="comment">// 从parse_net_option()函数可知，net.batch = net.batch / net.subdivision</span></span><br><span class="line">    <span class="comment">// net.batch * net.subdivisions就得到了在网络配置文件中设定的batch值，即网络配置文件.cfg中设置的每个batch的图片数量, 然后乘以ngpus，是考虑多个GPU实现数据并行，</span></span><br><span class="line">    <span class="comment">// 一次读入多个batch的数据，分配到不同GPU上进行训练。在load_threads()函数中，又将整个的n仅可能均匀的划分到每个线程上，</span></span><br><span class="line">    <span class="comment">// 也就是总的读入图片张数为n = net.batch * net.subdivisions * ngpus，但这些图片不是一个线程读完的，而是分配到多个线程并行读入，</span></span><br><span class="line">    <span class="comment">// 因此本函数中的n实际不是总的n，而是分配到该线程上的n，比如总共要读入128张图片，共开启8个线程读数据，那么本函数中的n为16,而不是总数128</span></span><br><span class="line">    d.X.rows = n;</span><br><span class="line">	<span class="comment">//d.X为一个matrix类型数据，其中d.X.vals是其具体数据，是指针的指针（即为二维数组），此处先为第一维动态分配内存</span></span><br><span class="line">    d.X.vals = (<span class="keyword">float</span>**)<span class="built_in">xcalloc</span>(d.X.rows, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>*));</span><br><span class="line">    d.X.cols = h*w*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>, r3 = <span class="number">0</span>, r4 = <span class="number">0</span>, r_scale;</span><br><span class="line">    <span class="keyword">float</span> dhue = <span class="number">0</span>, dsat = <span class="number">0</span>, dexp = <span class="number">0</span>, flip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> augmentation_calculated = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// d.y存储了所有读入照片的标签信息，每条标签包含5条信息：类别，以及矩形框的x,y,w,h</span></span><br><span class="line">    <span class="comment">// boxes为一张图片最多能够处理（参与训练）的矩形框的数（如果图片中的矩形框数多于这个数，那么随机挑选boxes个，这个参数仅在parse_region以及parse_detection中出现</span></span><br><span class="line">    <span class="comment">// 在其他网络解析函数中并没有出现。同样，d.y是一个matrix，make_matrix会指定y的行数和列数，同时会为其第一维动态分配内存</span></span><br><span class="line">    d.y = <span class="built_in">make_matrix</span>(n, <span class="number">5</span> * boxes);</span><br><span class="line">    <span class="keyword">int</span> i_mixup = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i_mixup = <span class="number">0</span>; i_mixup &lt;= mixup; i_mixup++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i_mixup) augmentation_calculated = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">float</span> *truth = (<span class="keyword">float</span>*)<span class="built_in">xcalloc</span>(<span class="number">5</span> * boxes, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">            <span class="keyword">char</span> *filename = (i_mixup) ? mixup_random_paths[i] : random_paths[i];</span><br><span class="line">			<span class="comment">//读入原始的图片</span></span><br><span class="line">            image orig = <span class="built_in">load_image</span>(filename, <span class="number">0</span>, <span class="number">0</span>, c);</span><br><span class="line">			<span class="comment">// 原始图像长宽</span></span><br><span class="line">            <span class="keyword">int</span> oh = orig.h;</span><br><span class="line">            <span class="keyword">int</span> ow = orig.w;</span><br><span class="line">			<span class="comment">// 缩放抖动大小：缩放抖动系数乘以原始图宽高即得像素单位意义上的缩放抖动</span></span><br><span class="line">            <span class="keyword">int</span> dw = (ow*jitter);</span><br><span class="line">            <span class="keyword">int</span> dh = (oh*jitter);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!augmentation_calculated || !track)</span><br><span class="line">            &#123;</span><br><span class="line">                augmentation_calculated = <span class="number">1</span>;</span><br><span class="line">                r1 = <span class="built_in">random_float</span>();</span><br><span class="line">                r2 = <span class="built_in">random_float</span>();</span><br><span class="line">                r3 = <span class="built_in">random_float</span>();</span><br><span class="line">                r4 = <span class="built_in">random_float</span>();</span><br><span class="line"></span><br><span class="line">                r_scale = <span class="built_in">random_float</span>();</span><br><span class="line"></span><br><span class="line">                dhue = <span class="built_in">rand_uniform_strong</span>(-hue, hue);</span><br><span class="line">                dsat = <span class="built_in">rand_scale</span>(saturation);</span><br><span class="line">                dexp = <span class="built_in">rand_scale</span>(exposure);</span><br><span class="line"></span><br><span class="line">                flip = use_flip ? <span class="built_in">random_gen</span>() % <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pleft = <span class="built_in">rand_precalc_random</span>(-dw, dw, r1);</span><br><span class="line">            <span class="keyword">int</span> pright = <span class="built_in">rand_precalc_random</span>(-dw, dw, r2);</span><br><span class="line">            <span class="keyword">int</span> ptop = <span class="built_in">rand_precalc_random</span>(-dh, dh, r3);</span><br><span class="line">            <span class="keyword">int</span> pbot = <span class="built_in">rand_precalc_random</span>(-dh, dh, r4);</span><br><span class="line">			<span class="comment">// 这个系数没用到</span></span><br><span class="line">            <span class="keyword">float</span> scale = <span class="built_in">rand_precalc_random</span>(<span class="number">.25</span>, <span class="number">2</span>, r_scale); <span class="comment">// unused currently</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (letter_box)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> img_ar = (<span class="keyword">float</span>)ow / (<span class="keyword">float</span>)oh; <span class="comment">//原始图像宽高比</span></span><br><span class="line">                <span class="keyword">float</span> net_ar = (<span class="keyword">float</span>)w / (<span class="keyword">float</span>)h; <span class="comment">//输入到网络要求的图像宽高比</span></span><br><span class="line">                <span class="keyword">float</span> result_ar = img_ar / net_ar; <span class="comment">//两者求比值来判断如何进行letter_box缩放</span></span><br><span class="line">                <span class="comment">//printf(&quot; ow = %d, oh = %d, w = %d, h = %d, img_ar = %f, net_ar = %f, result_ar = %f \n&quot;, ow, oh, w, h, img_ar, net_ar, result_ar);</span></span><br><span class="line">                <span class="keyword">if</span> (result_ar &gt; <span class="number">1</span>)  <span class="comment">// sheight - should be increased</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">float</span> oh_tmp = ow / net_ar;</span><br><span class="line">                    <span class="keyword">float</span> delta_h = (oh_tmp - oh) / <span class="number">2</span>;</span><br><span class="line">                    ptop = ptop - delta_h;</span><br><span class="line">                    pbot = pbot - delta_h;</span><br><span class="line">                    <span class="comment">//printf(&quot; result_ar = %f, oh_tmp = %f, delta_h = %d, ptop = %f, pbot = %f \n&quot;, result_ar, oh_tmp, delta_h, ptop, pbot);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">// swidth - should be increased</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">float</span> ow_tmp = oh * net_ar;</span><br><span class="line">                    <span class="keyword">float</span> delta_w = (ow_tmp - ow) / <span class="number">2</span>;</span><br><span class="line">                    pleft = pleft - delta_w;</span><br><span class="line">                    pright = pright - delta_w;</span><br><span class="line">                    <span class="comment">//printf(&quot; result_ar = %f, ow_tmp = %f, delta_w = %d, pleft = %f, pright = %f \n&quot;, result_ar, ow_tmp, delta_w, pleft, pright);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 以下步骤就是执行了letter_box变换</span></span><br><span class="line">            <span class="keyword">int</span> swidth = ow - pleft - pright;</span><br><span class="line">            <span class="keyword">int</span> sheight = oh - ptop - pbot;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> sx = (<span class="keyword">float</span>)swidth / ow;</span><br><span class="line">            <span class="keyword">float</span> sy = (<span class="keyword">float</span>)sheight / oh;</span><br><span class="line"></span><br><span class="line">            image cropped = <span class="built_in">crop_image</span>(orig, pleft, ptop, swidth, sheight);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> dx = ((<span class="keyword">float</span>)pleft / ow) / sx;</span><br><span class="line">            <span class="keyword">float</span> dy = ((<span class="keyword">float</span>)ptop / oh) / sy;</span><br><span class="line">			<span class="comment">// resize到指定大小</span></span><br><span class="line">            image sized = <span class="built_in">resize_image</span>(cropped, w, h);</span><br><span class="line">            <span class="comment">// 翻转</span></span><br><span class="line">			<span class="keyword">if</span> (flip) <span class="built_in">flip_image</span>(sized);</span><br><span class="line">			<span class="comment">//随机对图像jitter（在hsv三个通道上添加扰动），实现数据增强</span></span><br><span class="line">            <span class="built_in">distort_image</span>(sized, dhue, dsat, dexp);</span><br><span class="line">            <span class="comment">//random_distort_image(sized, hue, saturation, exposure);</span></span><br><span class="line">			<span class="comment">// truth包含所有图像的标签信息（包括真实类别与位置</span></span><br><span class="line">            <span class="comment">// 因为对原始图片进行了数据增强，其中的平移抖动势必会改动每个物体的矩形框标签信息（主要是矩形框的像素坐标信息），需要根据具体的数据增强方式进行相应矫正</span></span><br><span class="line">            <span class="comment">// 后面的参数就是用于数据增强后的矩形框信息矫正</span></span><br><span class="line">            <span class="built_in">fill_truth_detection</span>(filename, boxes, truth, classes, flip, dx, dy, <span class="number">1.</span> / sx, <span class="number">1.</span> / sy, w, h);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i_mixup) &#123;</span><br><span class="line">                image old_img = sized;</span><br><span class="line">                old_img.data = d.X.vals[i];</span><br><span class="line">                <span class="comment">//show_image(sized, &quot;new&quot;);</span></span><br><span class="line">                <span class="comment">//show_image(old_img, &quot;old&quot;);</span></span><br><span class="line">                <span class="comment">//wait_until_press_key_cv();</span></span><br><span class="line">				<span class="comment">// 做mixup，混合系数为0.5</span></span><br><span class="line">                <span class="built_in">blend_images</span>(sized, <span class="number">0.5</span>, old_img, <span class="number">0.5</span>);</span><br><span class="line">				<span class="comment">// 标签也要对应改变</span></span><br><span class="line">                <span class="built_in">blend_truth</span>(truth, boxes, d.y.vals[i]);</span><br><span class="line">                <span class="built_in">free_image</span>(old_img);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            d.X.vals[i] = sized.data;</span><br><span class="line">            <span class="built_in">memcpy</span>(d.y.vals[i], truth, <span class="number">5</span> * boxes * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (show_imgs)<span class="comment">// &amp;&amp; i_mixup)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">1000</span>];</span><br><span class="line">                <span class="built_in">sprintf</span>(buff, <span class="string">&quot;aug_%d_%d_%s_%d&quot;</span>, random_index, i, <span class="built_in">basecfg</span>(filename), <span class="built_in">random_gen</span>());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> t;</span><br><span class="line">                <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; boxes; ++t) &#123;</span><br><span class="line">                    box b = <span class="built_in">float_to_box_stride</span>(d.y.vals[i] + t*(<span class="number">4</span> + <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!b.x) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> left = (b.x - b.w / <span class="number">2.</span>)*sized.w;</span><br><span class="line">                    <span class="keyword">int</span> right = (b.x + b.w / <span class="number">2.</span>)*sized.w;</span><br><span class="line">                    <span class="keyword">int</span> top = (b.y - b.h / <span class="number">2.</span>)*sized.h;</span><br><span class="line">                    <span class="keyword">int</span> bot = (b.y + b.h / <span class="number">2.</span>)*sized.h;</span><br><span class="line">                    <span class="built_in">draw_box_width</span>(sized, left, top, right, bot, <span class="number">1</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">50</span>); <span class="comment">// 3 channels RGB</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">save_image</span>(sized, buff);</span><br><span class="line">                <span class="keyword">if</span> (show_imgs == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">show_image</span>(sized, buff);</span><br><span class="line">                    <span class="built_in">wait_until_press_key_cv</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\nYou use flag -show_imgs, so will be saved aug_...jpg images. Press Enter: \n&quot;</span>);</span><br><span class="line">                <span class="comment">//getchar();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free_image</span>(orig);</span><br><span class="line">            <span class="built_in">free_image</span>(cropped);</span><br><span class="line">            <span class="built_in">free</span>(truth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(random_paths);</span><br><span class="line">    <span class="keyword">if</span> (mixup_random_paths) <span class="built_in">free</span>(mixup_random_paths);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">// OPENCV</span></span></span><br></pre></td></tr></table></figure><h2 id="load-data-args-使用方法"><a href="#load-data-args-使用方法" class="headerlink" title="load_data(args)使用方法"></a>load_data(args)使用方法</h2><p>在<code>src/detector.c</code>中的的<code>train_detector()</code>函数共有<code>3</code>次调用<code>load_data(args)</code>，第一次调用是为训练阶段做好数据准备工作，充分利用这段时间来加载数据。第二次调用是在<code>resize</code>操作中，可以看到这里只有<code>random</code>和<code>count</code>同时满足条件的情况下会做<code>resize</code>操作，也就是说<code>resize</code>加载的数据是未进行<code>resize</code>过的，因此，需要调整<code>args</code>中的图像宽高之后再重新调用<code>load_data(args)</code>加载数据。反之，不做任何处理，之前加载的数据仍然可用。第三次调用就是在数据加载完成后，将加载好的数据保存起来<code>train=buffer</code>; 然后开始下一次的加载工作。这一次的数据就会进行这一次的训练操作(调用<code>train_network</code>函数)。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Qiyuan-Z</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/">https://qiyuan-z.github.io/2020/02/21/AlexeyAB-DarkNet%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Qiyuan-Z.github.io" target="_blank">Yuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><a class="post-meta__tags" href="/tags/YOLOv3/">YOLOv3</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/22/AlexeyAB-DarkNet%E7%BD%91%E7%BB%9C%E7%9A%84%E5%89%8D%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Alayer%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/"><img class="prev-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AlexeyAB DarkNet网络的前向和反向传播介绍以及layer的详细解析</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/21/AlexeyAB-DarkNet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"><img class="next-cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AlexeyAB DarkNet数据结构解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/02/18/在YOLOv3模型中添加Attention机制/" title="在YOLOv3模型中添加Attention机制"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">在YOLOv3模型中添加Attention机制</div></div></a></div><div><a href="/2020/02/18/YOLOv3模型构建中的YOLOLayer/" title="YOLOv3模型构建中的YOLOLayer"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3模型构建中的YOLOLayer</div></div></a></div><div><a href="/2020/02/18/YOLOv3网络模型的构建/" title="YOLOv3网络模型的构建"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-18</div><div class="title">YOLOv3网络模型的构建</div></div></a></div><div><a href="/2020/02/15/YOLOv3中的参数进化/" title="YOLOv3中的参数进化"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3中的参数进化</div></div></a></div><div><a href="/2020/02/15/YOLOv3的数据加载机制和增强方法/" title="YOLOv3的数据加载机制和增强方法"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">YOLOv3的数据加载机制和增强方法</div></div></a></div><div><a href="/2020/02/14/YOLOv3的cfg文件解析/" title="YOLOv3的cfg文件解析"><img class="cover" src="https://gitee.com/qiyuan-z/yuan-blog-image/raw/master/img/paper.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-14</div><div class="title">YOLOv3的cfg文件解析</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">加载训练数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-threads-%E5%AE%8C%E6%88%90%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">load_threads()完成线程分配和数据拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-data-in-thread-%E5%88%86%E9%85%8D%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">load_data_in_thread()分配线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-data-detection-%E5%AE%8C%E6%88%90%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">load_data_detection()完成底层的数据加载任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-data-args-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">load_data(args)使用方法</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022<i id="heartbeat" class="fa fas fa-heartbeat"></i> Qiyuan-Z</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a><br>昨日までの私は、もうどこにもいない<br></p></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk({clientID:"2d10cfb27783db577e70",clientSecret:"154292876bb14966f6ae57304b67859617b08c94",repo:"gitalk",owner:"Qiyuan-Z",admin:["Qiyuan-Z"],id:"d817de44565f053655d8c5a8f32d420e",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!1,updateCountCallback:commentCount}).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/gh/Qiyuan-Z/live2d-widget/autoload.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>